,,,Predictable (1),Effective (2),Satisfaction (2),Trust (2),Efficient (2),Vector: ,Invoke (1),Row Range, Predictable (0), Effective (1), Satisfaction (0), Trust (0), Efficient (2),Not Predictable (1),Not Effective (1),Not Satisfaction (2),Not Trust (2),Not Efficient (0),Refactorings
Task 1,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm not familiar with Java or IntelliJ so my way to refactor will be manual. If I used this tool all the time I may look into how the refactoring works. Although in this case I would need something very specific..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What kind of tool would you look into? [09:28],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I don't know if there is a plugin or something where I can say that I want to move the following classes or methods to another file you can probably write that, I don't know if it exists. [09:38]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
But you could also just do it by hand.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is that similar to any tool you have used elsewhere?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In the rubyworld we usually do it by hand but usually we don't let it get to a point where it is this bad. [10:02],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
StringUtilsBlankTest... [14:48],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Find the string utils test. Find everything that has to do with blanks. This is quite common for us. You don't know how much of the constructors and headers you have to copy over.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The easiest thing we typically do is to copy everything and then delete what we don't want.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
One way to not have to decide what to go where is to start by duplicating the file and then decide what to remove. Here it is so much stuff maybe it is not worth it. I don't know what part of a constructor .. the nice thing with a second step is that you clean up the constructor so you only have what you need in each file.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
the empty... they're all in order. I'm sure there are nicer ways to do this.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Before I do it I would just try to search.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I see the names here anyEmpty any nonempty. I don't want to have to read all these. I will just delete this and make sure all the tests I want are still there. [17:44],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I did not include the... there is another file. [17:53],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm saving this file. In theory this should just run.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So these tests pass which means I can remove these from the other side. It is a bit tedious - I don't know if there is a faster way here - this is how I would normally do it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"It is kind of mechanical because you don't want to do 100 things at a time, you only want to do a small thing and if you only do a small thing then automating it is no faster than doing it by hand. [19:36]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So I can remove the duplicates from here now. [19:41],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Run this one. [19:44],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Seems to pass. Let me do the same thing for the other one. StringUtilsTrimEmptyTest. [20:42],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So in the previous case the test class grew too big and we split it out but in this case the tests are just in the wrong place. It is different root causes but addressed in the same way. [20:55],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Hopefully again if I move these over we may discover that we need somthing from the constructor. For example these imports i would need to reconsile with the ones from the other. The easiest thing is just to copy and see if it works. [21:27],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The nature of these one that they are missing is that it will not run. If they are missing the next thing is to move them over. This is again a challenge when you break up test files you look at their shared dependencies and there is a culture of abstracting it like this and some people say that if you abstract it too much your tests become like code so some people say duplicate it in every test then you get more lines of code but it makes the test more independent.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So let's see I don't see foo here if it depends on it then we will get an error. And we do. [22:34],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Were you expecting the error to show you the next step?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes. And hopefully I get the right error. As part of TDD you expect failure but you expect the right kind of failure.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
What I want do is see a diff of all that changed. Should I go to the terminal?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is this how you would normally check?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes. [24:25],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We are removing things from the tripEmpty and adding to ... I'm a bit lost. [24:56],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I just made a mistake I pasted them to the bottom of this file.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Would your usual editor have helped you navigate this?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Not really but it doesn't have any of this so it is less noise on the screen to distract me. [25:30] But this can still happen and I would use the terminal to guide me here. [25:42],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And if I miss something I would note it in the git diff and assuming it works there would be the code review when someone notice I attached stuff in the wrong place. [25:49],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
A next step I would do is to reorder these. But that is not in the instruction. [26:42],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Foo is missing as I expect. As expected. I must go and get it - foo is used twice so I would go and get it. Another thing is I would not use foo because it doesn't tell me what it is supposed to do.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
There is bonus work I would do but should I stop?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Yes. In your own words what code changes did you do in order to solve this task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
This isn't even extract I just moved method from one file to another. Logically - I mean that is the mechanism the intent is to break things down from one file into where they belong more logically. That is all we did. We didn't do any more structural effect we just moved things around.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What tools do you know of or would you usually use to do this?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Usually I would do what I just did. [29:13] I can speculate that there is some kind of IDE support that allows me to specify moving some code from this file to that file but even then 
 it probably wouldn't be smart enough to also move the required imports and move the foo over and would just tell me something is wrong - and if it is too smart it may move too much.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you said that the tool would make some changes you would then have to clean up?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We don't have true AI yet so the tool does not understand the intent of what I am trying to do. It only mechanistically does that kind of operations. I can imagine a tool where I say move this from this file to that file. I don't expect it to understand all the dependencies that needs to be met like the variables the imports it may be smart enough,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
but I would be weary using such a smart tool because it might do more than I want or because in this case copying things blindly may not be what I want. If there are dependencies I may want to clean them up. [31:22],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Of course instead of ten files if these were a thousands files I would need to look it up and then maybe instead of an IDE try with some kind of grep or regex to match and move. Worse case you can just write your own - it dependens on the volume of the operations. For this small operation a tool would not save me more than a minute so even if it existed if there was any risk of it not doing something right I would just go back to the manual. [32:00],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Can you think of an example of the tool doing something you don't want?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Let's say I moved things from two files I moved this foo. The tool would probably not move it over. An example of too much in this case there's this constructor. [32:35] In production I would not leave it like this I would try to remove it completely see what breaks and see if I can use a smaller version of this. Or I would not move it at all and see if I have a dependency problem. Or I could move it like I did now which would work but it is probably not what I want. A tool could get me half the way but I doubt it would be smart enough to get me exactly what I want. [33:12],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If it could I would be curious to know. Even then I am not sure I would use it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Even if it had gotten you to the point where you are now similarly to your manual changes a tool may have gotten you there faster. Would you mind that the tool automated part of it and finished manually?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I would give it a shot. My experience with tools is that they rarely give you exactly what you want and the downside even if it goes all the way is that I don't know what it did. If I do it manually I see a step by step description of the dependencies. There is a step in projects where it is too complex to do on your own and you must rely on tools but that is like the difference between visual flying and instrument flying. Visual flying you see everything going on and you can use your intution but instrument flying you can only see the effects.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I have done this before a simple but more common example: you need to rename a function. An ide can tell the semantic of a function so it knows to rename that and not all related stuff whereas in ruby it does a string search search and replace. [34:32] So if it replaces 100 instances 20 may not be the right thing so it can break other instances. There is no magic we just do the slow way and see what breaks. [34:48],"Reflection
Effective 
 (“An ide can tell the semantic of a function so it knows to rename that and not all related stuff”)",,0,1,0,0,0,"<0,1,0,0,0>",0,54-54,0,1,0,0,0,0,0,0,0,0,
Task 2,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I can remove them but what do I do when the caller depends on them. In this case to be a refactoring I would need to find a way to rewrite the code depending on these two be written in a way that depends on the other one maybe in a bit of predicate logic .. [36:04],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I would question this because I don't have a problem with these methods being there. [36:14],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I want to check who is using I can do a simple search.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It is used in a bunch of tests which is ok because we are just going to remove the tests. But it is also used here. [38:26],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So.. interesting because allBlank is implemented as a negation of isAnyNot. The simplest way I see is to take the implementation of this method and directly copy it here. [38:42],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
One thing we can do is to invert the implementation so we can keep the tests running. [39:29],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"This is just a first step, not necessarily a final form.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Here is the first problem I would not write this as a bunch of returns but as a single expression. Because now I need to go to each branch and do something there and it is annoying. [40:23],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now I have to actually think about the right solution here. Hopefully this is covered by tests. [40:52],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"If I make a mistake here hopefully the tests will fail. I can actually check that - that is a common pattern we will write the tests, put some wrong logic to intentionally fail the test.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You already found the tests but didn't really look at them right?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
No I can test first or I can do this first. I will first write this correctly.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
This seems to me like it should work. This is in stringUtils right so stringutilstest. I wil run it. It should pass. [42:31],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The tests pass so now I can start messing with the booleans and now this should fail. [42:53],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It is not failing which means there is no covering of this edge case at least. Now this is an edge case but this should fail on all - actually we moved it over I am running the wrong file. [43:33],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In reality I would also run the whole build so something would have failed. [43:51],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So now I change this to false. [44:01],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
ok good something failed. I want to see what failed. [44:37],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ok so it is what I expect. And then test the other boolean as well. [44:55],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Three booleans here. [44:58],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
There are tools that do this. [45:41],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The next step is to change the - isAllBlank don't depends on isAnyNot. So this can be gone. I searched for dependencies. So the only test that should fail is the test that checks that file. [46:23],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
isANyNotBlank. so remove this as well. [46:32],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Then I would repeate the steps for the other method although in the interest of time I will not repeat all of them. [46:47],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
But I would test for coverage. And again if instead of two it was ten or twenty I might look for a more general solution.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What do you think a more general solution would look like?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I don't know because this would require inverting dependencies either .. what I am doing here require a bit of human intelligence to realize the implementation must be reverted. Now there may be some smart method if there is one method negating another then switch it around so the other negate the first and then you can measure coverage with fuzzing tools.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So it all can probably be automated. It's just that the threshold to use that, the cognitive load, is much more than what is needed here. [48:08]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ok so isanynotempty.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Find usages. Same here. isALlEmpty. So I need to find is anyNone. So I take these ones,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
replace it with implementation and negate [49:10],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
because how to negate it.. you need to flip every case. Something I would do I would try to write it as an expression instead of procedural returns because then it is easier to reason about.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
How I do this would depend on how much I trust the tests.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I think this task is complete but if I was doing it in production I would take some time to rewrite it as an expression so I could only make a change in one place instead of three. [53:05],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Which code changes did you do in order to solve the task.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I don't know the proper name but I call it reverting the method dependencies. If method A depends on method B then I move all the logic into method A and in this case negate it and then either remove method B or if we keep it move the dependency. [54:11],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Is there a refactoring name for this? It is not dependency inversion because that is OOP.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: There is no refactorig that matches exactly what you explained now. There are some that may be used for a similar problem.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Like what?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Inline method.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Is it moving a body into the other.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Yes and then doing the tweaking of the code that is required.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So it is the opposite of method extraction where you unextract. So I guess I gave a more specific use case. So I guess you could call one inline, one extract, so they .. together they create a method invert. I am just making this up.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What would you extract?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So let's say the requirement was not to remove this method, but change dependency order. So in this case what you are doing is the same thing.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
You are inlining a representation and extracting a representation. You are doing two things extract and inline. [55:56],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
But you are doing them in a logically cohesive way not randomly - they are cohesive so I would call that method inversion. [56:08],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: If you were to do that how would that impact the tests?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The biggest danger here - both for inlining and inverting is that I would have to change the booleans. [56:35],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I am hoping that there is coverage for this because you may make a mistake. This is a simple example but I've worked with code - this is a common thing having to change boolean logic - when changing booleans especially in combination with operators. [57:27],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You seemed to make sure that you changed your test last [59:33],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
When you refactor and you do not change the logic you should be comfortable changing the code without changing the tests. The code and tests are kind of double book keeping. One keeps track of another. You can make a mistake in either.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I wanted to change the implementation and the test should not fail. [1:00:39],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You said if you refactor in a way that does not change logic - is there a way to refactor that does change logic? [1:00:48],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
well if you change logic it is not really a refactoring. Maybe I just repeated myself. If I refactor and not change logic. A refactoring may have side effects. What is considered as logic depends on your scope. It is an academic question whether optimization is a refactoring or not.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you sort of overload the concept of refactorings?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes. [1:03:50],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Task 3 [1:03:54],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So we need to essentially .. how many cases of forceaccess do we have. [1:09:14],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I want to understand the general pattern of these being used. Part of refactoring would be the comments, say it is deprecated or has no effect.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So one first step I could do is not to remove it because it would change the interface of the method but to just ignore it. [1:09:42],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
For example. This will make it be ignored without changing the signature. [1:09:58],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now if I run it it should fail otherwise it does not have coverage. [1:10:02],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ok so something failed. [1:10:32],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We want to deprecate this behavior. We change it in one place .I can go and look at what fails. This one tests forceaccess and it's all it does - I can probably drop it. This will take me a while because there is 24 matches.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
With this level of quantity I would start looking into what tools are available. [1:12:04],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Instead of doing it by hand I wonder if there is a refactor pattern to remove a function argument. Removing it here is difficult because of all the logic inside: a refactoring tool would probably not be smart enough to know what to do with it. [1:12:25],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Although it could be smart enough to just remove the if-condition here. [1:12:40],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is that what you would like for a tool to do here?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ideally yes - this is a simple example I don't know if it is possible in all cases.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Another thing to do is what I did. to make those ignored everywhere and see what breaks. Let us change, you change something and many things break. You should start fixing one type of problem at a time because what I really care about is logic behavior that I have been told to remove. That allows me to see what really breaks. In theory if no one is using it the only tests that should break is this one and if nothing else breaks then I know that no one depends on this logic. Then I can go and change the signature and a lot of logic might break but it is only syntax level. [1:13:44]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I don't need to worry about breaking behavior.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is that what you mean with types of changes?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
A logic change versus a type level. You can change the signature - like if you had an argument that was never used but since it is there people need to pass it in so before removing it I want to test if there is actually any logic that depends on it and one way to do that is to keep it there and make it not be used anywhere. I don't know what tools exist I'd look at them but I'll just continue by hand now. If it was houndreds of files I would just search and replace and find this pattern and then insert a new line. [1:14:37],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"The ultimate goal is to remove the argument this is just an intermediate step. This is not something you would check in, so it is not really a refactoring pattern, it's just a step. [1:15:08]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I expect there to be a - for every function there is a parameter declaration and a usage so there should be 8 times 3 is 24. This is not the only way to do it. I could just take the file and clean it up all at once if I wanted to. this is a bit more careful. [1:15:49],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What informs your decision to choose either one of those options. [1:15:58],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The level of work per method? Eight is enough for me to want to break it down. [1:16:04],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why is that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If I make a mistake somewhere in the middle I don't know exactly where if I changed a lot of lines at the same time. I changed one case and the only failure was that test so now I apply the same pattern to all the rest. [1:16:29] If that works then the next step will be to start removing them. I don't know when is the right time to get rid of the test I could just do it now - I don't need it. [1:16:49],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: It sounds like you are learning more about the code changes you make while doing the small steps is that right?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I don't learn more about the goal but about the consequences of what I am doing. [1:16:57],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
This is actually not final for some reason. [1:17:14],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Let's see what happens now. 
  [1:17:36]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What made you decide to get rid of it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
All of them are testing forceaccess. [1:17:57],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We know we don't need to support it any more when we remove code we can remove the test that test for it. I could be more careful and see if there is something in there.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: It's still in the git diff.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes although I hope I don't have to go there that is more of a backup plan. I do something and I'll go there to discover what I did. So all these ones are forceaccess with true so again I don't need to test for this path any more. I can just get rid of it. [1:18:39],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Some of the stuff still fails. More forceaccess stuff. [1:18:54],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now before I move on I want to run the entire build. I don't know what else depends on this so I want to check before starting to change the type level stuff.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In production I would check this in with a commit at this point not a pull request but an intermediate step so if I make a mistake I can roll back to this. [1:20:49],,Undo,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: what would you call the commit?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Just some kind of work in progress. Stop accepting ..stop using forceaccess. If this passes at this stage it means all the logic is fine and it is purely a type change from this. [1:21:16],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now it is just a bunch of cleanup. I remove it here. [1:21:22],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Again there may be tools for this I suppose you could write something for this but I will just do it by hand. We just remove the true branch.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now I will run the tests again there are two types of errors one is a type level... (undo undo) actually,,Undo,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I will tell you what I'd do in production before I do this - next step is I will stop using this [1:22:34],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
and actually start removing. This gives me a sanity check that nothing is wrong. This will help me catch it if I make a mistake in the logic. This one tells me I may make a mistake in terms of using them. I will still keep it here as a sanity check. But in the body I can start getting rid of this.,,run tests,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Something else failed? I might have made a mistake in the logic here. [1:23:39],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
What did I do?,,undo,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Right I made a mistake here I removed the wrong branch.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In this way I get a small error at a time and only in a class. If you get many errors and they're all very different it is difficult to sort out.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ok and then I do the same for the other one. [1:24:18],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So for .. forceaccess remove if .. so this is not negating it is asserting so I can just return null. [1:24:36],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now this is more complex because it has an and condition. && means I can remove this entire branch. [1:24:55],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: If you had a tool that was clever enough to do these logical reductions would you batch run it or still go through one and one case.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I would pilot on one to make sure my structure is correct maybe one more to make sure and then I would apply it all around. [1:25:35],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
This calls with another argument so I just stop passing it. For example this should still pass. [1:25:49],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Again this would probably be difficult for a tool.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I would list the function to change it would find all its callers and change them this is something we have done before.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now I see the pattern repeating.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I think I removed all forceaccess except the signatures.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: How would you describe the repeating pattern you mentioned?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"this is all part of removing a function argument. [1:28:43] 
 First you stop using it. Then you stop passing it in. Then you can remove it from the functions.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Next step now is to remove this and see what breaks .,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ah this is java overloading. Now that I removed it it is apparently a conflict. [1:29:55],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
This one just defers to the other one. In this case we must do an inline. So we stop using this special case and start using the general case instead. For the sake of the exercise I am not going to unify the comments but that is also something. [1:30:19],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Make sure the signature is the same.. something like this.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now lets run the entire build to make sure nothing else depends on this. [1:30:51],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Was this a big change for you? You're rerunning the build.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes the goal of the previous change was to maintian locality. While I was only changing the logic if something else rely on it.. now I want to make sure nothing else rely on it. [1:31:24],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now it is the same thing here. Remove it here remove it here and I already know what to expect I am going to search for declared field is it the same signature looks like it [1:31:50],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We just need to inline this one. There might be a tool that does it i don't know. [1:32:16],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In theory if you only want the behavior change what we did in the beginning would be enough because we cannot use it any more. But of course it is not good refactoring you should clean up.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
How come the second one is not the error as opposed to the first one. I would expect the second to be the error. [1:33:29] As opposed to inlining I just remove it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Why is the error still there? ReadField? How is this different to this one. There are now three. [1:34:08],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: They have different types. [1:34:15],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So in this case I don't need both.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Point is I remove this one where is this defined how do I go there. [1:34:46],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Which method is this one in conflict with. [1:35:04],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
What actually changed here? [1:35:33],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Still an error...,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Anyway we can continue but I would just do this and if there is a large volume i would investigate the tools to try and automate this stuff. Something may be, stop using a variable, like inserting a value at the beginning. Another would be stop calling the function with this variable. which is find all callers to this method and remove it. and then remove the variable from the .. it is optional .. if the tool is reliable you can do both at once. The part where it does not really work is where you need to change the body to stop using it. Sometimes there is a boolean expression with logical operations and there could be more complex examples. [1:37:40]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: can you summarise the code changes you did in order to solve this?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Stop using the function argument. Short circut it to the variable that used to come from outside it just gets a value assigned. That is a first step and I run the tests. Some tests already fail that tested the other path I made sure they are tests we don't care about. [1:38:18],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The next step is to change the input to the function and change everything that fails. The next step is actually to remove in the body stop using the argument not in terms of hardcoding it but see at all the places it is used and refacor the actual if-statements and the argument in other functions stop using it. And the last step is removing the argument from the method signatures and again changing all the callers. [1:39:02],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Then it is the inline step and update the documentation. And of course in the real world show that no consumers will be impacted by this change. [1:39:20],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: If you were doing this kind of change during your work how would you keep track of the different code changes? [1:39:28],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I would make intermediate commits in git. Before you merge you can just squash them together. For me I may make one for each small thing I may want to revert of when the tests are working. [1:39:54],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If I try one change and it works and I apply it to ten other things it can be one thing. Even though the scope is different it logically is the same.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If I make a kind of qualitative change like a change in the logic the first one would catch some logic problem that is wrong in principle and then I may make a mistake in the scaling approach. Git is one example - this is what git is for.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is there any automated tools in the IDE you would use to help you? [1:40:42],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I haven't personally used IDEs that much but some people do. Some things - basic things like rename method extract method there may be tools in your IDE. For this one I am sure there is a tool that removes a function argument but I'm not sure.. I'd have to test it. Everything I have do so far can be automated easily but I'm not sure if someone would make a tool that works in a general case. [1:41:26],"Reflection
Not Trust
 (“I’d have to test it”)",,0,0,0,1,0,"<0,0,0,1,0>",0,201-201,0,0,0,0,0,0,0,0,1,0,
I: Would you still use it if it did not support complex cases?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If the quantity of work was like this I would not. [1:41:54],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Unless I had to do this like five times a day. The volume times the frequency. [1:42:08],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ultimately how much time do I spend on doing this. If I do something very often or it is very big I am more insentiviced. [1:42:30],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
When you change something there may be a risk for side effects that is why I am weary to trust the tool and using it. [1:42:46],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: It sounds like you are unlikely to trust the tool?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
That is too strong a statement. If it is small changes I can just do it by hand. If I am wasting too much time then I would do it. [1:43:29],"Reflection
Efficient
 (“If I am wasting too much time then I would do it.”)",,0,0,0,0,1,"<0,0,0,0,1>",0,208-208,0,0,0,0,1,0,0,0,0,0,
I: What were some repetitive things you were doing in these tasks?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The last one was particularly annoying there were eight functions that had a small amount of things like removing the parameter but some things were different like som places I had to rewrite the conditional to a smaller one and some I had to stop using the argument so the overall goal was the same but the changes were different.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: If you were able to use a tool that did those things and you ran the tests and it worked would you trust it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes if I trusted the tests. And then it is the problem of clients which you said which is difficult to measure.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: In this case as well you had a particular order of doing things. It seemed that the order made compile errors appear which helped you with your progress. Would you mind explaining that? [1:45:21],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
When you have compile errors or test errors then they tell you about the state of the system. It is very convenient to leverage that. Sometimes I intentionally want to get something to a failing state which again then I look at what fails. If it is a compile error it is a syntax error and if the compiler pass and the tests fail I can test which logic errors happened. In the real world this happens often I change something I think is a boolean logic but there is some app... but sometimes the absence of an error is as bad as the error. When you do TDD there is a bunch of refactoring but there is always the risk of it not being covered so if you change it to be intentionally wrong you know that it is tested. [1:46:49],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
then you can change it to be what you want after. You want to see a pass after a failure not always passing. [1:46:56],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: If you are using a tool for example a refactoring tool how would you gain the same assurance from it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I would do the same thing. The refactoring tool would automate the code I am doing - again this is why it is clunky to run some big thing that changes thousands of lines of code because then it's like what do I test? Maybe I do one manually and then apply automated and then do a couple of spot checks.,"Reflection
Not Satisfaction
 (“it is clunky”)
 Not Trust 
 (“what do I test”)",,0,0,1,1,0,"<0,0,1,1,0>",0,217-217,0,0,0,0,0,0,0,1,1,0,
I: What do you mean with spot checks?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If I change 100 functions I would flip the logic in say five of them and see that I get five different errors. [1:47:57],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The other option is to look at the test. Everyone say to look at the tests. You say the test file houndreds of tests how do you even know which test to look at. If you are writing it sure but when it is already there you don't know where to look. I find my approach higher quality than just looking at the test. Of course if the tests fails you will look at it but for regression tests .. it is fine to test for behavior it is hard for regression testing.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: During the second task we talked about the inline method refactoring. Did you consider using it here?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I just did.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Yes manually. Did you consider checking the refactoring menu. [1:49:46] Why did you not consider using it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So I would inline this into this.. How would I do this? I have never used this before. Here is the refactoring menu. So it says it has 20 occurrances. What do I even do here? This is like - this is not even the function it is usages of it? Will this change the invocation? This is not what I want. This is already discouraging me from pursuing it forward. Only if I discover that what I want to do is impossible or taking too long then I would research.,"Invocation
Not Predictable
 (“What do I even do here”)
 Not Satisfaction 
 (“already discouraging me from pursuing it forward”)
 Not Effective 
 (“This is not what I want. “)
 Efficient 
 (“Only if I discover that what I want to do is..taking too long”)",Invoke (Inline),1,1,1,0,1,"<1,1,1,0,1>",1,224-224,0,0,0,0,1,1,1,1,0,0,Inline
I: What is your cutoff for too long? [1:51:01],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I don't know. For this kind of thing? 15 minutes. Maybe 10. For a few minutes I would just do by hand. For this one I would need to verify it too. You could argue it is an investment into learning the tool but in this case I would first want to see that the cost times frequency - if I do it over and over then I would look into it but if I then don't need it for 6 months I will forget it by the next time anyway.[1:51:58],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
fin,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,0,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,0,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,0,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,0,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,0,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,0,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,0,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,0,0,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
T1 [05:13],,,Predictable (1),Effective (0),Satisfaction (0),Trust (1),Efficient (3),Vector: ,Invoke (1),Row Range, Predictable (0), Effective (0), Satisfaction (0), Trust (0), Efficient (0),Not Predictable (1),Not Effective (0),Not Satisfaction (0),Not Trust (1),Not Efficient (3),Refactorings
So it just matches the name of the class or the name of the test or something. Usually I wouldn't like structure my tests based on what people want to run but if that's what they want then sure. [06:54],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
[08:17] These should be moved into a class that doesn't exist yet.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
[08:49] Usually what I like to do when I do something that is pretty close to what I have is to copy what I already have. Just copy the entire class pasting it in here giving it a name. [09:43],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So we want these tests. These we don't want.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Save that. And just to be sure.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Run this one and see if it works. It works. Then we go back now we got them duplicated so we remove them from here. [10:57],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And we rerun the trimempty one.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And since we have a nice IDE it shows us things we don't need any more. [11:27],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So we already moved the first one. Ah this is called trimEmptyTest. Trim trim... I guess this one we're not supposed to move trimToEmpty. This should really be called trimAndStrip test. [12:07],,Invoke (Rename),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Rename
Then we go in here.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now this may be a bit more complicated. It's a pretty big class and we have to find the methods we want to move. For example test is any empty. I'm not sure if ...,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Well usually code is not that well organized. So usually that would take a while. [13:01],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So in this case it seems like we will be able to.. there may be ways in the IDE..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I remember I used the extract before. I don't quite remember how that works any more. [13:14],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I don't know if extract would allow me to move the method. [13:26],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm going to do it the old school way.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Usually there may be separate setup that is required in this case not. There is only static class methods so there's not a lot of objects that need to be created to set up the tests. That was stringUtilsTest I think. Then we might be done. Before we're done we should check how many there were before.. [15:05],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Looks like we got all of them. We're just going to run all the tests again. [15:16],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
1335 that's the same we had before. That seems like we successfully moved everything. [15:35],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What did you do in order to solve this task. [15:48],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I read the tasks to see what we wanted to move I looked around to find that functionality. I ran all the tests to begin with to make sure they work and then I just created a - actually I copied a class just in case there's a setup that's usually a good way to get the setup structure especially in Java. Then I cut and pasted the methods in there and that was enough. There was no extrac setup needed just moving them around. Updating class names to reflect what they contained and the documentation. And then ran the tests again in the end. [16:53],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you know of any tools that could have automated any of the things you did?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Not really. Again the right click refactor maybe.. there might be the extract. Oh no there's a move. I don't know if this.. move instance method. [17:20],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I'm not sure. The IDE might provide some things. I've definitely used extract in the past when we had a lot of classes. That would have worked the first time when I copied them into a new class. Extract, you usually extract into a new class. And then for the other one you could also extract into an existing class I assume. [17:52]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why didn't you try to use it? [18:02],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I figured that trying to figure out the IDE for this would probably take as long as trying to do it manually this time. If however I had started a new job in a Java shop with this specific IDE then I probably would have tried to figure out how it work. [18:28],"Reflection
Not Efficient (“trying to figure out the IDE for this would probably take as long as trying to do it manually this time.”)",,0,0,0,0,1,"<0,0,0,0,1>",0,27-27,0,0,0,0,0,0,0,0,0,1,
I: Would you invest time specifically to learn it or would you have tried it during the task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It depends. Since I haven't used it for so long I'd probably try it a little in advance and play around especially with shortcuts. [19:00],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I remember when I used IntelliJ i had those commands memorized to compile, run tests for the current class, the whole project, and so on. That I would do in advance. But if there was something specific, the IDE just has so many features, I would learn that as I go.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Are there any of your changes you are unsure about or unsure that you got right. [19:32],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
No in this case I'm sure about the changes mostly because the code was very well organized and I checked in the beginning that everything was set together and it was. I checked before I started making a new change it wasn't like I started to move things around and then I had to go find pieces I was missing. I could copy the code from both files in one big block and then I ran the tests again.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: When you were copying and pasting how did you decide which parts to copy? [20:16],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Usually the bigger the tests are the more setup they have. If you don't have an IDE that doesn't show you the imports then that it hard - you may be able to do it on save. It is often easy to copy way to much and it's hard to take it out in the beginning so I always try to copy as little as possible so I understand it instead of copying one giant thing that I don't understand and removing things from it. [21:10],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
T2 [21:14] reads task [21:55],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We are removing methods with bad naming and they already have pretty much an inverse of them as well and just extend the surface area. It looks like in this case we can actually just remove-remove them and don't just have to remove the logic and call the inverted method underneath as you often will when you expose a rest API or something and remove an endpoint you might have to like just rewrite it under the hood and make it call another one.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In this case we just remove two methods and remove the tests as well. We might have to check if there are any usages of them any callers inside this project. If something rely on them we have to change that. First find the methods then find out if they are used anywhere. [23:23],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So this checks if it is not empty not null ...,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Then you can do.. find usages. [24:10],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
There is anyNotEmpty... oh it's actually used in isAllEmpty. And .. yeah as expected it's the negated version of it. We'll have to move that code into isAllEmpty method. [24:52],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
First I need to check if isAllEmpty has its own tests or rely on the other method's test. It's in the stringutils test or we might have moved them to the StringUtilsBlankandEmptyTest. So the good news is that there are tests of isAllBlank. [25:47],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So those two do have tests that we're gonna trust.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Then we can have a closer look at what the original implementation actually does. [26:18],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So what we need to do is just to return the negated version. We need to always return the inverse of this. How do we do that best.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In this case I would just go with my true and tried cut and paste approach. [27:09],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What does 'do it best' mean to you?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I don't know. There's always multiple ways to do it. For example we could just rename this method to be the new one there are many ways of doing it that would all amount to the same thing. I feel like the easiest will be - sine we're replacing the method call in the other method - to just move this code that it implements into that instead of renaming the method here. [28:05],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why would that be easier?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
For one it is basically substitution since we already call this method. There is also less moving pieces especially with the nicely formatted documentation here. I feel like I just touch things inside the method body instead of all over the place. [28:47],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So we will remove that.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I often comment things out especially if they are small just to see what the original was. So in this case I can see that the method was not just called directly but it was negated in front.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
and it gives me a chance to check the signature.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Looking at the code it seems that we can just reverse the boolean values we return but just to make sure I'm just going to make sure that the meaning make sense so I will read through the code. [30:20],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We have to be careful that we don't return too early.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
That seems to make sense.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And then we go back to our test class we just refactored the isAllEmpty,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We want to remove this method anyway so we can just remove it already. [32:29],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now it's complaining about - it's the problem in a compiled language the compiler is complaining about all kinds of things.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So again we could probably just delete this but just to be sure I'm going to comment it out for now just so I know what I would have deleted but we have git so that would help as well. [33:13],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: it sounded like the error you got now was not what you wanted or expected.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I mean it makes sense that I got the error now since I removed the method and it compiles the whole project. But in Ruby I would be able to just run this one test anyway as long as I don't call the method I deleted it will be fine anyway but we can argue that that is a good thing or a bad thing. [33:45],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So this is isNoneEmpty is all empty ..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So it passed that's good. I have't looked at all the these but it looks like we have pretty good test coverage. [34:11],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm not sure if there is a tool built in that show us the coverage as well. That would be good to know. I think for now this is good. One down that was allEmpty that we just replaced and now that it works we don't need those tests any more so we clean up before we forget that.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
[34:54] Even though if we use git we will not forget because we see the change.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now we go back and repeat the same with the other one.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We are going to remove isAnyNotBlank [35:14] which looks pretty much exactly the same as the previous one just blank instead of empty. I will just do the same as before and move this code to where,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
isAnyNotBlank is called. The one down here.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Again to be safe we won't delete the code here.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Basically same here in reverse. [36:19],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now we probably have the same as before - isanyNot -,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The IDE even highlight it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
then we run the tests. If it pass we run the whole test file. And the tests pass that's good then we only have to clean up the mess of the commented code that we has. so that looks good in here. Then I want to go and remove this one as well. [37:30],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Depending on the size we can run all tests locally to make sure that everything still passes. If it does - we have two fewer tests now because we removed two.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
They all pass that looks good.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What did you do in order to solve this task? [38:20],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I first looked at like what is the part that should be removed and what should it be replaced with. Then I looked for any usages and it turned out that only the part we were going to replace it with used it so I just moved the code into where it belonged. So I just removed that public API method that we wanted to remove. And had to adapt it since we were calling the negated version of that and just to be safe I read through the code as well to make sure it made sense. Then I updated the tests and ran them and they all passed. The only way to do that with less code change would be to make them private and still call them. In that case we would not have had to do that many code changes but that would have introduced technical debt which is confusing. The whole purpose is to get rid of additional surface anyway so that would have only half accomplished the task. [39:43],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you know of any tools that could have automated any of the steps you did?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I don't think so.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What impacted your decision to do it manually rather than look for a tool?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
There was only one usage of the function. There was not many usages or many different kinds of usages. There was just one place in the same file. There was only one usage each. So it seemed like doing it manually and actually knowing what is going on was better than finding some automated way and not knowing what was going on. [40:39],"Reflection
Not Efficient (""it seemed like doing it manually and actually knowing what is going on was better than finding some automated way and not knowing what was going on.”)",,0,0,0,0,1,"<0,0,0,0,1>",0,82-82,0,0,0,0,0,0,0,0,0,1,
I: What do you mean by not knowing what is going on?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It's not that I don't trust the IDE but those refactoring things that are built in they're a bit magical for moving code around so if you haven't used it a lot you don't know where it will move it. It may move it to the wrong place. Again git is a good tool to show you changes so it should be easy to find where it ended up but if it doesn't do exactly what you want you have to try again and you may end up spending more time than just doing it. [41:24],"Reflection
Not Trust 
 Not Predictable (“f you haven't used it a lot you don't know where it will move it.”)
 Not Efficient (“if it doesn't do exactly what you want you have to try again and you may end up spending more time than just doing it.”)",,1,0,0,1,1,"<1,0,0,1,1>",0,84-84,0,0,0,0,0,1,0,0,1,1,
I: By doing it again do you mean undo?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah undo either in the IDE or if you don't trust the IDE because it already did something you did not want once you have to via git or something and then you do it again but do something different. For example if there are some options along the way of where you want to move it making it private etc then choose different options. Trying to figure out which ones were the ones responsible for having a different outcome than you expect. [42:00],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You mentioned different kinds of usages or kinds of callers what did you mean by that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In this case both methods were called with the bang in front the negation operator. If there would be a bunch without the negation or with arguments overloaded or different arguments passed at different points or if the method signature would be slightly changed or something like that. [42:42],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
T3 [43:33],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
A bit similar to the first one changing the API again but this it is not just duplicated on the surface level we're actually removing functionality. [43:48],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
First we will take a look at the code and the tests and see what the easiest or best way is to remove that functionality. [44:28],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It is the fieldUtils file.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Usually I don't use the sidebar too much unless I want an overview of the classes that are close together in files. [45:16],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Here is the extra argument for the forceaccess which is just used in here.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
One of the things I use in the IDE a lot is the highlighting so just clicking a variable to see where it is used so I can see where it is used or how much very deep or very high level. [47:00],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Then this getDeclaredField same as the over with forceaccess readfield the same. [47:15],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
There's another. Oh ..they're duplicate ok. [47:25],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
readfield readdeclaredField then writing the fields. [47:38],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
looks like all of these methods already have an equivalent API with the access parameter that all call the one with the parameter with the value false. [47:55],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm going to have a look at the tests as well. [49:39],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We're taking away the method with the third parameter which is overloaded right now. All the invocations to the method without the parameter should be as if the third parameter was false which is actually the default behavior already. We probably don't have to make any changes to that behavior to the non-force-case so we only have to see if there is any specific behavior to the force-case and then basically just remove that to clean up the code. [50:40],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Same as the last time we must make sure that all the test scenarios are covered and the tests all pass. [50:59],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
They always come in pairs. We will just start with the first one getField which has the forceAccess in here. [51:24],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
First we check what forceaccess does.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The parameter is just a branch condition in here. If it is true we set the field accessible if not continue. So we basically always continue. So it should be simple to remove this code.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now it is the same as if forceaccess is false and the compiler is telling us that we don't use this parameter any more and we can remove it. Now the method is similar to the method before which means that we can delete this part in between. The signatures are duplicated and the documentation looks pretty much the same and so since we are removing the method with the extra parameter we say that we remove that documentation and use the other instead of trying to merge the two. [53:05],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We could also spend some extra time to improve documentation at the same time to see if there is something mentioned there but let's assume the documentation is pretty good. Now we removed the one with the extra parameter. And now I see that this method is actually used in here as well. This time we didn't check the usages before. Which I guess is what happens when I start refactoring straight away which is actually not so smart. [53:53],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
But it should be fine. Maybe just bring back that method again. [54:11],,undo,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why are you choosing to undo now?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I want to check if the method is used anywhere outside of this class as well. [54:13],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And I think the compiler makes a difference between the one with the two and three arguments. But we're lucky this time even thought it is used inside this class it is not used outside except in the test class of course. [54:38],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And we did like what we do so we're going to redo those. Then we will go back and fix the warnings that the compiler gives us. This one is the readFieldMethods with the forceaccess. Let's see what this one does. Basically all forceaccess does in this case is being passed into the getFieldMethod. So we can actually change readField straight away too. We're going to remove it here in the method call.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Then it is going to say it is not used anywhere anymore. Now I do want to get to a - I want to stop the compiler yelling at me so I'm just going to leave this one for now and just fix the other usages.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why is it important for you to make the compiler happy? [55:56],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Otherwise the compiler doesn't let me run anything and that means I can't run any tests. I don't want to break everything at once and fix everything at once so I'll just break that one method first and then fix things one by one. [56:21],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'll do the same down here for writeField.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Then I will return to our tests which is our safety net. Here we'll have a whole bunch of tests fail as well. We can see here that they're all called with true which doesn't apply any more so the forceaccess test doesn't apply any more. We can keep them for now just in case we want to check if there's any test cases we want to move over. [57:05],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
There's also some tests that are definitely not needed any more for expected exceptions. I will remove those as well. If we do need to get anything back we have git so that is good. IF this wasn't in source control I would definitely be more careful with deleting and just comment things out.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you usually rely on source control in cases like this?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes I basically never to anything without source control. [57:58],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now we have our getDeclaredFields and we will run just this one and make sure it still works. [58:15],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It passes which means it compiled and it also passes the test cases which is good. I think the test cases all look idential so we don't need this any more.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We could always get it from git but it is easier to get it back from comments so now that the tests pass and I skimmed through the other tests it looks ok to delete. Luckily these tests are pretty easy to just skim through with your eyes without reading too much. [59:11],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
There seemed to have been like a parity between the two test methods so there seems to be no test cases that are missing which is good. You often have to be careful with changing tests that you don't remove any scenarios that are covered in only one case. Like for example if we had any forceAccessFalse in the forceaccess test then we should have moved them in here. [59:55],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I think so far so good in our first case. It seems like the strategy is working.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What is the strategy?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
To remove the overloaded methods one at a time. In this case it was the getFieldMethod. To remove the overloaded one and move the code in here. To make it work without the overloaded parameter for the false case and remove all the usages and refactor the tests. So I would do exactly the same for the other ones. GetDeclaredField is the next with forceaccess over here[1:00:47],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I look what the forceaccess is doing, same thing as the previous one.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It's just setting the field accessible otherwise returning null. We can do the same as before assume that it is always false so we will always return null. [1:01:17],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I was just looking at the difference between the two methods getField and getDeclaredField. Sometimes when doing these refactorings you discover that there is very similar code that you can refactor further and in that case I would make a note - I wouldn't do it right away because otherwise you go down a rabbit hole - but I would make a note to come back to this and see if we can combine getDeclaredField and getField as well. But just looking at it it doesn't look like it. The code we changed inside that if-statement looked very similar but it doesn't look like it is that similar. [1:02:14],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: if you were going to make such a note how would you make it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It depends on the timeline for when I think I would get back to this. Either offline on a postit note or on a textdocument on screen. if it is a longer timeline I would put it in one of my todo notetaking apps or even if I'm pretty sure we should look into it I would create a ticket in our ticket system.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So it is the same I will remove this from here. [1:03:02],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And I assume it is the same that the compiler will complain that the method is the same as the one above which is good.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: It is good?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It is good in this case because it means that we achieved that this method has the same signature as that one. [1:03:18],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It's basically calling itself with that now obsolete argument so because it was duplicate we can remove it and now the compiler is truly happy.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Was that part of your strategy?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes. [1:03:33],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
But of course same as last time it's the same as before down here it's passing through the argument which we can remove and the same down here also just passing this through.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Then we go back to our tests. These are the tests for forceaccess which we are just going to comment out for now. Then it is error handling which I'm pretty sure is duplicated for the other one. THen it's testGetDeclaredField then it's the other one up here so I'm going to run the testGetDeclaredField.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Test passes so that's good. I look in here it looks like the same as the force case so we can get rid of this one. It all looks good in here and since the tests are really fast it doesn't hurt to run more so we will run the whole file. There is another here. testWriteFieldForceAccess. This is one of the methods were we removed the parameter. And now this one - can not locate declared field publicChild.b. ok. [1:06:09],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Oh forceaccess true. I see. So now since we removed some of the other methods that used getDeclaredField and getField with forceaccess and they are not working now, write with forceaccess is failing as well, since we just removed the boolean forceaccess parameter from those calls. [1:06:48]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Same for this one over here. Now I have to change the strategy a little bit. Instead of going for the next one maybe we look into this one first.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"testReadNamedFieldForceAccess means that maybe we need to look at this one next ReadNamedField and writeNamedField. This stacktrace should send us to where we need to go. Oh I see, in the test it is using the readField forceaccess true. [1:07:58]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So we did getDeclared and getField and readField - ah there is a lot. [1:08:18],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We always pass in false. I'm consider if it makes sense to change all the tests first to always pass in false before we change the signature and then break the signature and remove all the tests that have the true in as well then clean up the code after. Which would make sense since we are removing that functionality of forceaccess true behavior. So we could just remove all the tests for that first instead of removing the code first and breaking the tests. [1:09:22],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
However if that is really faster I don't really know. It doesn't seem like an obvious time or effort change. In the end we need to remove both. The difference is are the tests green in the meantime or are they red. But at least if they're red we see what is broken. So maybe we will just keep going the way we were. The readField now was causing some tests to fail. [1:10:10],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
if forceaccess and not field is accessible set accessible force access would always be false second condition doesn't matter.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So it would always return field.get. Remove this one here. Remove this one here. [1:10:38],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And then have that one duplicated again with this one remove duplication. And now same as before fix the warnings in here forceaccess false is good that we can just remove.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And same here false.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Just remove the false. This false seems file. The test readNamedFieldForceAccess. [1:11:32],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
readNamedField.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Those two look a lot different. ReadNamedField,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now there is a few cases that tests not illegal argument exception. Whereas here there are much more but they are all the force true behaviors. [1:12:31],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm not sure if those tests need to be here for the none-force as well. What we can do is temporarily move the code into the none force version of the test and see if it has anything to do with the force. [1:13:18],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I'm not sure these scenarios that are tested here are specific to the force true case or they are more general since I have not really looked into the setup steps here and tried the whole thing. I assume the private something are going to fail when we don't forceaccess but I don't know if the public will,so for that reason I'll drop them in here and see if I can run them. [1:14:27]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ok we get illegalAccessException. As expected the public one still works but the private one doesn't since we are not forcing the access.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So in this case I'm just going to comment out and later remove the one that are private. Then I will run those again. [1:15:17],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you just checked the first one but you commented out all of them?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes they follow the same pattern of checking a field on a differently named object and since it's about accessing public and private field I figured that all the ones that are called private are not going to work and the public ones are.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now this one still seems to fail.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Just based on the naming I would expect this to work but it doesn't. So we'll look into the naming and see why it doesn't work. Here is the public child which is a class.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
has a value extends a parent.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Right now I'm just looking at the object being tested to see what is going on and I'm looking for the b object the boolean which we can see is protected. And because it is protected it can not be accessed. So it seems like this is an expected case. So it seems that this test case was right in the forceAccess case. [1:18:28],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So this one is basically expected that this one fails. [1:18:44],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
let's have a quick look if this ss public child fieldname s,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We can see that this is further below but for example the string value here was not tested in publicly tested field. So we will comment out that one for now. Let's try again and go to the next one.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Now you are checking each line?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes if these were written as separate test cases it would be easier since I could run them all at once. Usually each test should test one thing and not 20 things. But in practice it is a tradeoff between readability and functionality. [1:20:18],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
On the public child we can not access the I.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Before we actually run it here is the public child again so let's have a quick look there is a d in here which is private so I can comment out that one as well. [1:21:21],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now it passes so it seems like all the one on publicly shadowed child we can access. So those ones were correct to have forceAccess on them because they don't work without and since we removed that functionality we can remove them. [1:22:03],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And I think I saw that - yes the boolean value was here as well so then we can remove the one up there. [1:22:19],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Oh I see public child .. I should have read this before.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I saw that the test cases I just ruled out manually they were actually present even thought they didn't look the same. [1:23:07],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The public child with field b is tested here with an exception. That could have saved us some time if we saw this one before. [1:23:43],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We just spent som time trying to add additional test cases from the other one that were covered already. That was a bit of waste of time but better than missing some test cases. [1:24:09],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
For the next time I will look a bit closer even if they look different we can check a bit more toroughly that the test cases exist. [1:24:28],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now I believe we can run the whole file again. There is still one. writeNamedFieldAccess. That would be the next one to change. [1:24:47],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So we go back into the fieldUtils and find the writeNamedField.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We can see that one is here. writeField writeField.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It seems... field object object field object object field string object. So there are two versions of the writeField both with forceaccess each with slightly different signature. We are just going to look into what the difference between those are. The first one takes a field and an object to be called on a value to be set and the other one takes a target - oh the field name which is getting the field value finding the field first then the value. [1:26:38],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
As expected this one is using the writeField method so it is getting the field first and then writing the field. That means we will start with the one that has less we will start with the one where we already have the field. [1:27:10],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why did you choose that one?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It is the one both has in common. It is the inner method. The other just does some extra work and calls this one. So I change this first because if this one works the other one would be easier to change after and should behave the same since it rely on the functionality in here.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So we see in here forceaccess and it will always be false we are going to remove this branch. [1:27:49],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And then we remove the parameter. [1:28:00],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It is the same as before so we remove the writeField so now we only have one writeField and we are getting compiler errors in here which is fine because this is always passing in false anyway so we just remove that argument. [1:28:34],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And then this is going to be easy after but we won't go there just yet we will just check now that the file is compiling what the tests are doing we will check the tests before we go on.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It's the same we have the testForceaccess and test without forceaccess up here.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
This time we check that all the tests are implemented. [1:29:24],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Looks like all of these tests are also in here and of course a few of them are expected to fail without forceaccess.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In the past we commented out but now since we checked we can just remove the test. [1:30:04],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And now everything semes like it compiles so we can run first the test method we are most interested in.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And then we are also going to run the whole file as well. [1:30:33],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And see that there is one more here that fails now the writeNamedFieldForceAccess which is the other method that we saw earlier we are passing in the field name first. [1:31:00],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Then this will get the field to write on. This is related to the other writeField method that we have not refactored yet. So we are going to change this one first.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
[1:31:22] We can already see that this is not used anymore in here the parameter. So we can remove it and it will be the same as before we can combine those two methods.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
This one is not used anywhere in here so we are not getting compiler errros here but this one we get compile errors in the test so we will look for the accompanying method that test without forceaccess. Same as before we will have a quick check to see if it implements all the scenarios. [1:32:25],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Looks like there's no test for the privately shadowed field this one. [1:33:07],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In this case I think we can add this one since it is missing in here. We expect the same as for the other ones that it will fail because we had to force access in here. [1:33:49],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Just to check my assumption we will have a quick look at what the privately shadowed child is. [1:34:06],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"has a private string s. yeah, we should not be able to access this one.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Move this one up here. [1:34:45],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It will be the same as the other ones we will use a try catch without the force parameter and let's see on the other ones expecting this to fail. And then we move this one in here. Comment this one out so we don't have any compiler errors. Run the most important one the one we refactored first to see if it work.s And it doesn't. [1:35:39],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Hmm. Parent. So the parent has a public string s. Maybe that is the reason why we can access this one. [1:36:30],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Long story short this is the time to ask someone on the time why that is. So since that was not an original testcase I don't know why it needed the forceaccess before but it seems that it works. So now we have two options to either add it to the test case here and make it so it works or skip it. [1:37:25],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I would usually bring this up with someone on the time so I will skip it for now. Then it passes and we can delete the commented out one. [1:37:43],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Then what do we have left. We are looking for something with the boolean at the end. writeDeclaredField forceaccess. We already removed the parameter in the body so this is an easy one to change. It is the same as the one above. [1:38:41],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
No compile errors in the file. No compile errors in the test. I will still run the tests. The more often the better. They pass.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Another forceAccess that is not used any more for readDeclaredField same as before we can remove that duplicate method now.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
See if that gives us any compile errors. [1:39:32] No errors.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And run the tests again. They work. I complained about the compiler before but it's actually sometimes really nice. Then another for the readField forceaccess is not used any more remove this part. [1:39:55],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The compiler was telling me that certain parameters were not being used and when I removed it I could not see anything red on the side so nothing is broken here whereas if it was ruby or some other non-compiled language I would have to run it and hope that the test coverage would take it otherwise I would find out in production. So same as before we run the test suite they all pass. [1:40:45],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Then I believe there is no more forceacces in here.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We are just going to search.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Even though the variable is not being used there are still some comments. This is why some people say code comments are bad because they don't update with the code. It says it was already forced before but we won't force any more so we don't need this. Or we could change it to say that it won't throw any more. That's really useful information. This comment is not really useful any more. [1:41:55],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So we just remove that comment. I saw it a few times in here. We remove all of them regarding force access.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
No more force in here that is good. Now I run the whole test suite again to be sure that everything still works and that it is not used elsewhere and now we hope that not everything breaks. All passes.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So we have removed the parameters including the tests that were forcing and we have no more usages of forced in here and [1:43:02],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
now we are done.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What did you do in order to solve this task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I first looked at where the forceaccess is used and then noticed that as expected from the task there is a version with forceaccess and one without and the one without just called the one with with false so I was planning to move all the code, to remove the forceaccess branch code from the method implementation and then I could move the method non code into the method body and as I did that I had to fix the compiler errors telling me where it was used. Sometimes it was nice when it was used with the false value already that was easy. When it was used with true I had to decide if we can just remove the true value as well because we are going to get rid of that behavior or something else. Especially for the tests. For the tests I tried to make sure that we did not lose any test scenarios. I should have looked a bit more closely at the test implementation. I found one small thing that I could not explain so I would bring that up. Otherwise it looks pretty solid. [1:44:57]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: When you started out you were going pretty slow and methiculously and then you sped up a bit and ran into some problems and mentioned that you changed your strategy. How did those different strategies compare and what impacted your decision to change?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I started out slow to see exactly what is going on and tried to find a balance between going too deep and missing things and not missing things at the same time. Then I saw that there was a pattern present so I could skip over some things after that.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What was the pattern?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The method calling the method with forceaccess false and also that it seemed that the parameter the forceaccess parameter did not do too much in the method. It was just a small branch not like the majority of the code. So it seemed pretty straightforward in the beginning to remove those. Later I noticed that another method that I didn't expect to rely on it right away relied on it and it failed some tests. Turns out that it makes sense that writeField uses getField to do that.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: When you said that you were trying to find a balance between digging too deep and not missing things can you talk more about that? [1:47:00],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Since I am not familiar with the code base and especially later in the tests with the different levels of access in Java - like private and protected it's a bit confusing - I didn't want to go too deep in the implementation because there's a lot of code in here. I mean even now - ok now it is only 200 lines and most is documentation but for example the getField method actually has 30 lines of code including some like loops two loops. They are not like too trivial. I did not want to - and I don't think I didn't had to understand everything to make some changes but I also had to make sure I didn't miss anything crucial. [1:48:03],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: How did you go about balancing that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Usually I try to look at even within the method especially if code formatting standards are followed so the code break down into certain blocks for example we can see there is one block here and one up here. [1:48:28],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And then since for example the forceaccess was only used in this line I focused more on this block of code since this one seemed to matter less. That's why I didn't really look into what this code does.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why is code formatting important for this? [1:48:55],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It's important to see like you can see a few things based on the formatting like the more indented the code is the more for loops and if statements and other branching conditions. Each of the blocks that indent when it comes out it implies that it is kind of separated from the next block. Usually one is the input to the next or they depend on the previous [1:49:35],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
but in terms of functionality they are usually pretty isolated. Often for example you loop through a list of things to find the value and then if you can't find anything you return early already and if you do find it you do something with it. So if you look at the a block and there is if null return or something then you know that the previous block was really just to find that thing and if you don't have it you just move on. [1:50:10],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
That's how you can split those. You can think about less things and ignore the previous part and keep them separate.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you know of any tools that could have automated any of the things you did?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I think there are some tools to automatically run the tests when you save that could have been useful cause I went and ran them manually a lot. but most of the time I had to go into the test file anyways to change something so not sure how much that would have saved. [1:51:01],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I guess probably not.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You did a lot of code changes in this file do you know of any tool that could have automated those?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
No I don't. I have a feeling that maybe the refactoring option in the IDE maybe could have done something to combine methods but definitely when I started programming IDEs were not advanced enough to do refactorings like this. [1:51:47],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I usually only use them to rename things or maybe move around a bit. This one was more complex so I am not sure tools can do that. [1:52:03],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I had to remove code and I prefer to see the code that I remove to actually see what is being removed. The method was overloaded with additional parameters so I'm not sure in what way .. if we would have removed one I don't know how we could have told the compiler that we always want to treat the parameter as if it is false and since it is false we could have removed it automatically or something. [1:52:45],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It seems like too many steps involved. And some mental state to keep like where you were along the way. For example I did one set of methods at a time but each had substeps of going into the method with the force parameter removing it inside the method then I could remove it form the method signature and then I could remove it from the usages somewhere and the steps to do them in order and not trying to remove the parameter already when it is still there. [1:53:40],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you had to mentally keep track of where in that process you were?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: what made you decide to use those exact steps?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Partially the help I get from the tests and in this case the compiler. for example by removing it from the body the compiler would tell me that I don't need it in the signature any more. [1:54:14],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And once I remove it from the signature the compiler can tell me everywhere it is being used so I can remove it from there as well. Once I did those and ran the tests I can be fairly confident that the cycle has been finished. Whereas if I had started this somehow trying to find all the usages first and change all the usages from true to false or something like that I would have to still remove it from the code after anyway. It seemed like doing it this way the compiler would always give you the next step where you would continue so even if you lose where you were or got distracted you could jump in more easily. [1:55:09],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You were repeating the steps that you described now and it seemed like the first time you were almost collecting information about the code as you went and noticing these patterns was that right?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes absolutely. The first time it's usually about finding the balance between not moving too slow but also avoiding mistakes especially the first time it is important to take a bit more time and collect as much information as possible to see if assumptions are right and not to make too many assumptions but as you keep going and you are on the forth and fifth iteration you shouldn't get careless but you can move a bit faster. Just make sure that you keep observing the same patterns and structures as before but you don't have to try and find them any more becuase you know what they are. [1:56:33],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What are some examples of information or structure that you look for like that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If code is well named and there is a certain level of consistency that helps a lot. For example all the methods were grouped together so it was easy to see that they were overloeaded and that the one was calling the other with the false value. Also for the tests they were also all structured. It was a bit confusing with the public shadow child the variables there weren't named too clearly but they were all organised together so at some point I could check that it was all the s i b and so on that they were all covered. [1:57:53] That would be the kind of patterns I was looking for.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: How would you normally organise these changes to make sure that they are correct or not miss something?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Not missing something is one of the harder things for sure. That is why in the end I did a simple text search and I found the code comment which was not picked up by the compiler. It depends on how unique the word is that you are looking for. Test coverage is the most important thing. Obviously in a compiled language the compiler. And the last line of defence is the text search and looking at it manually.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Now you were selecting from curly brancket to curly bracket but if the methods had not been next to each other like that what would you have done?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Sometimes I do some pre-refactoring tasks especially using git so if I had seen that the methods were all over the place so I may do a commit first to bring them in order.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: But even if they had been just the other way around it wouldn't have worked to delete like that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes true. I don't know. I do like deleting code and I do that a lot in different ways. Another favorite is just to delete four lines like that so that probably would have worked.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Any final Qs?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
No I just wish it was always code coverage like that.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
fin,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
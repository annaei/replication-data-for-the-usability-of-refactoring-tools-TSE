T1 Ready to start. [03:16],,,Predictable (4),Effective (9),Satisfaction (8),Trust (6),Efficient (7),Vector: ,Invoke (9),Row Range, Predictable (4), Effective (6), Satisfaction (6), Trust (5), Efficient (5),Not Predictable (0),Not Effective (3),Not Satisfaction (2),Not Trust (1),Not Efficient (2),Refactorings
I'll look through to find the things that are referenced. Probably create a new test class and ideally refactor-move a bunch of methods. That will be a little dependent on what kind of setup structure they depend on. I haven't read through to see what the tests are. This is using a fair bit of static context here. [04:29],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So in this StringUtilsTrimEmtpyTest .. I see we're only pulling out the null and empty bits from trimEmpty. But trimempty has a bunch of additional.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So StringUtilsTrimEmtpyTest seems to be a fairly straightforward test. There is no dependencies between tests. So it's an easy one to start with. Just duplicate it and delete what I don't want. [05:37],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I only want these first four tests. [05:42],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Should remove them from TrimEmpty.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Then in moving things from stringUtils here things look a little less well [06:05] no this looks fine.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
These are all standalone. [06:33],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So in theory now we would like .. Oh.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Sorry you can only use mvn in the IDE.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Oh. ok.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Would you usually interact with it through the terminal?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes. I wouldn't do anything except import into the IDE from inside the IDE. I think those are the tests as specified. It's just copy-paste. I suppose the duplicate with rename is an IDE function.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you feel done?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Which source code changes did you do in order to solve this task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I moved a bunch of independent methods from one class to another.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: How did you do that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Using copy-paste trusting that my IDE would automatically manage my imports for me.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You indicated that you wanted to refactor-move them but ended up copy-pasting.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The more complicated the operation the more likely I would be to use the IDE's tools. Because the methods were not related to any other code it was more efficient to move them all at once. I think refactor-move lets you select multiple but it's just unnecessary when methods are independent.,"Reflection
Efficient",,0,0,0,0,1,"<0,0,0,0,1>",0,21-21,0,0,0,0,1,0,0,0,0,0,
I: So if this had been more complicated you would have been more inclined to use the tool?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Have you used this tooling before?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Can you elaborate?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If I were to move a more complicated one.. like this one using the constant here so this one has a reference to a private member. [09:30],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
This is not the shortcut..,,Invoke (Move),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Move
I: What is happening now? [09:56],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm actually not sure what this error message is.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
All candidate variables have types that are not .. I think this is telling me that the method could be static. That it is not using any instance variables from the class it is starting in. Which would be fine except that it would break JUnit. But in theory if I were to continue here. I would select the members that I want to move and where I am moving them to. And it will automatically escalate visibility of dependent members if I want it to. [10:49],"Reflection
Effective
 (“it will automatically escalate visibility of dependent members if I want it to”)",Invoke (Move) ,0,1,0,0,0,"<0,1,0,0,0>",1,31-31,0,1,0,0,0,0,0,0,0,0,Move
Definitely was easier to copy-paste than to use this for this example.,"Invocation
Not Efficient 
 (“definitely was easier to copy-paste than to use this”)",,0,0,0,0,1,"<0,0,0,0,1>",0,32-32,0,0,0,0,0,0,0,0,0,1,
I: But in a more complex one..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Have you used this only for static methods before or for instance as well?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Not sure. For instance methods it would be more likely that you are pulling up or pushing down rather than between adjacent classes. I don't know that that is a sensical mutation on an instance method because the call sites would not be equivalent if it's not inheritance related.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Yes you would need to update those as well.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: That's not something you do?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If you are moving a method from one class to another that probably implies that there is a relationship between the two classes you're moving it between so either that's a superclass relationship or an instance field and then you'd be using a different refactoring like trying to introduce indirection or .. it's hard to think about these without motivating example. So like pull up or push down or replace inheritance with delegation or encapsulate field. These are more .. like moving between tests ..cheats because there are no call sites. All calls are through the test runner.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Yes when you have calls you need to update those.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And that's when the IDE really helps because those are the places where you need to know to update and ideally the IDE can update for you if the transformation is regular. [12:53],"Reflection
Satisfaction 
 (“when the IDE really helps”)",,0,0,1,0,0,"<0,0,1,0,0>",0,42-42,0,0,1,0,0,0,0,0,0,0,
I: And you've used MIM for that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
These are things I have done but I don't necessarily remember the exact tools I have used.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: When you do the copy-past approach how do you keep track of the changes you make?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In git. I can see them here they're nicely highlighted. Once I have done this work I would check the diff and see if it makes sense. I may go this change is clearly unrelated and I don't want it. I should see that my new file has the method in question and the sources no longer do. Which is the case.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Are there any of the changes you did that you are uncertain if you got right?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The tests pass. The counterpositive is kind of hard here there aren't tests that were failing that I expect will still fail. This was a pretty simple change I'm not worried about it. [14:31],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
T2 [14:39],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So isanynotblank is a bad name for like not is all blank which presumably is also in the same file.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ah. I see. Which calls the bad one. So the easy thing to do here is to.. haah.,,Invoke (Inline),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Inline
So this isn't strictly inlinable because the IDE sees that there are multiple return points which are ..dumb. Because the caller is equally simple.,"Invocation
Not Effective 
 (“this isn't strictly inlinable”)
 Not Satisfaction 
 (“which are .. dumb”)",,0,1,1,0,0,"<0,1,1,0,0>",0,52-52,0,0,0,0,0,0,1,1,0,0,
I: What would you expect it to do here?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I would expect... so isallblank here. IF it had a single return then I would expect the body of the method above and the value not-ed in here.,,Invoke (Extract Local Variable),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Extract Local Variable
I mean we can do that manually but it doesn't actually help us. Anynotblank.. but this is still not inlineable because it has returns in execution flow in the method I'm inlining. In this case I think it's probably more useful to swap the implementations and then inline one of them in this case because the method we want to keep is not the method with the actual implementation. We want to swap the implementations and then inline the deprecated method. [17:02],,Invoke (Inline Method),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Inline Method
So ... I mean really what we could do here is introduce an intermediate step. [17:43],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So this is the method we want to delete. This is just to keep current code running. We can redefine this as not .. what's the other one.. isallblank. Which is the method we want to keep. Then.. [18:07],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
How do I actually want to do this.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What are the considerations you're doing now?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
My long-term goal is that I want to inline this method. So by keeping this kind of stub implementation of it - stub isn't the right word - I'm preserving it as long as possible so any tests calling it is still working while I do my refactoring. What I want to do is move the implementation into the method I am going to keep and ensure that the tests are all passing and then remove the method I want to remove.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'll just fall back to copy and paste because if the IDE doesn't help me that's what I do.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Actually we can do this better. [19:10],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I should just do what I do.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
But now unfortunately I have to think about this.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What do you need to think about? [19:40],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I have to invert all of the returns here. This is now .. allblank if it's empty. If anything in it is not blank it is not all blank otherwise it is all blank. Now I hope all tests pass.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is this usually how you would have done this?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I don't think there's anything here that felt weird. I don't think I would usually feel this conscious about the activities I'm doing.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Would you usually try to inline it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes. I trust that the IDE will do the right thing. [20:36],"Reflection
Trust",,0,0,0,1,0,"<0,0,0,1,0>",0,70-70,0,0,0,1,0,0,0,0,0,0,
If it had inlined it I wouldn't have inspected the body. It would have been inline it would have been done it would have been fine. But because it didn't automatically inline it I had to stop and think ok what happens when I inline the body of this method.,"Reflection
Not Effective (“it didn't automatically inline it“)",,0,1,0,0,0,"<0,1,0,0,0>",0,71-71,0,0,0,0,0,0,1,0,0,0,
I: Would you have inlined this occurrence or all occurrences?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
This occurrence. I haven't .. then I would swap the implementation in the other method and then replace all occurrences of it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"[21:20] All tests are passing. I trust that I've moved the method correctly. 
 So now isAnyNotBLank we want to get rid of which is only used in tests, only used in one test. I keep this in my context and I can delete the method because it's only used in one place. If it had been used in application code then inline would have been the appropriate next step.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Inline to?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Inline this. [22:00],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I would inline this method to migrate all callers to allIsBlank.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So then you would have risk to get a double negation at the call-sites?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes - that's not a bug it is intent preserving. Then I would have wanted to look through the changes do I want to apply a cleanup to any of the inlining. But that is the next step to something I didn't do.,"""Reflection
Effective (“that's not a bug it is intent preserving.”)
 Not Trust (“Then I would have wanted to look through the changes”)""",,0,1,0,1,0,"<0,1,0,1,0>",0,80-80,0,1,0,0,0,0,0,0,1,0,
I: Would that always have been your next step?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Look at the change? Definietly.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: How would you find them?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Git changes. That's the easiest way to find them.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If I was worried about where they were being used... my first step there was find usages. I might have inspected things before doing the inlining to understand what context it was being used in. Depends on the complexly of the method being inlined. [23:03],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
That was one. There is another one here. IsAnyNotEmpty. Presumably this is going to follow a similar pattern. [23:21],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It's got one test and one usage which is the inverted function. So here I am presuming that again I can't inline it because the logic isn't smart enough to do that. But because I'm doing the same thing again I'm not going to bother with the intermediate step. I forgot where I was going.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
cause this methods has its own tests that I trust will validate my change. So isanynotempty Is all empty ..,,run tests,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
This..only has one callsite. Which I will delete. remove the implementation. And I'm done.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Why does this say there's an error?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It may just be sick.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
While that is running I can read my changes and see if I'm happy with them.,,git diff,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
removed one method,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
inlining it,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
removed one method into the other,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
and removed both of their tests,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
if I was doing this properly I would have committed after the first task. [25:43],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Tests pass. I assume this is done.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Which source code changes did you do in order to solve this task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"First step was to understand the relationship between the deprecated method and the method that should remain. After finding that the implementation is in the deprecated method and the new method is just a negation of the result of the old method move the implementation to the new method.. basically swap the implementation of the new and old method. Checked for call sites to the old method. Would have inlined, there weren't any, delete it. [27:13]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is there any part of this you're unsure if you got right?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I didn't examine the test cases. I assumed they were of high quality. Generally deleting test cases are bad. I would not have deleted the old test cases if the new method didn't have equvalent test coverage. Without looking at it in detail it looked like they basically had the same test method copy-pasted. I trusted the test coverage would remain if I deleted the old method. I trusted the coverage would remain if I deleted the old test.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you essentially did a manual inline right?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Can you describe the steps you took in order to do it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I couldn't use the automated inline because there were returns in the middle of the method I tried to inline. I could've tried to refactor that method in place to have a single function exit point because then it would have been inlineable and the negation would have been trivial to apply on the last return point. [28:35],"Reflection
Not Effective (“I couldn't use the automated inline”)",,0,1,0,0,0,"<0,1,0,0,0>",0,106-106,0,0,0,0,0,0,1,0,0,0,
instead I inlined the whole function and - I forget the word - instead of having the not outside put the not inside each of the returns. [28:49],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
which works for boolean return values. Doesn't necessarily work for more complicated structures.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: If the inline function would have worked and done the same thing you did would you have been happy with that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes. I would have been happy to do less work. I think if it had inlined it with a temporary variable and then negated the variable before returning then that would have been a sign that there needed to be some manual cleanup before calling the task done.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: I want to spend some time on that. You mentioned the workaround with the variable. But that would run a little differently.,,(Tests would have failed),0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes because you would have to explicitly would have to - say internal code flow instead of external codeflow - to say stop here,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Yes. So how would you have liked that result?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm not sure how I would have done that in this example.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Yes this is now beyond what the IDE can do. [30:10],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I think that's the same. I'd run my tests to make sure.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Let's try that.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So that's a transformation that'd... and yes I'd run my tests to make sure it did the right thing.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: If the tool did that would you look at it and be like yes that's what I wanted? [31:30],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
No! This is much worse than what it was before. It just happens to be inlineable.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What's worse about it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Break is a confusing construct. Early returns are very easy to reason about - in a small method; early returns in large methods are generally signs of other bad things. Here I need to understand all three conditions together in order to understand the result where in the previous form I could reason about them independently which is important to the method being understandable. If IntelliJ had performed that transformation and then inlined it I would have looked at the result and said I'm not sure that inlining was correct and I don't like the code it resulted in. [32:22],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Then would you have done?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Probably what I did copy-pasted,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You would have undone?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes. [32:34],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Probably in other languages this would have been simpler. In an imaginary language where you can non-local - like how do you have a return inside the function that isn't the function's return. Like that'd be some kind of expression object or expression construct that Java doesn't have.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Refactoring tools should leave code looking like a developer wrote it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What does that mean?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Maybe that's just expressing what I said further back. Which is good code looks like a human wrote it. It looks like it was written by a uniform author with a uniform style and is understandable to humans. Computers writing code typically don't feel the same constraints and so sometimes you can identify computer written code by awkward constructs or strange control flow or whatever. It looks like machine genereated code and it's not what I would like to call the output of my work. If the goal here is to clean up the api it should not have the side effect of ruining the implementation. [34:14],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I think that if - if intelliJ had been able to do the refactoring but given me a less beautiful result I would have been ok with it I would have just had to clean it up.,"Reflection
Effective (“if IntelliJ had been able to do the refactoring”)
 Satisfaction (“I would have been ok with it”)",,0,1,1,0,0,"<0,1,1,0,0>",0,131-131,0,1,1,0,0,0,0,0,0,0,
I: Less beautiful being for example what you described?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You mentioned that you trusted the IDE so if it let you do it you wouldn't have checked the body?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Right. I guess there is classes of things I trust it to do well. This is a simple method. There's no name conflicts, there's no multiple scopes interacting I trust that the IDE can do things like that. At least to the same degree that I trust that I can do things like that.","Reflection
Trust",,0,0,0,1,0,"<0,0,0,1,0>",0,135-135,0,0,0,1,0,0,0,0,0,0,
I: We just talked about how the change may change the code would that fall under your sense of trust.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If the IDE moves code and it looks like the code it started from I'm more likely to trust it. Because my mental model of the code hasn't changed it's probably doing the right thing. The more complicated transformations are happening the more manual review is going to need to happen.,"Reflection
Trust
 Predictable",,1,0,0,1,0,"<1,0,0,1,0>",0,137-137,1,0,0,1,0,0,0,0,0,0,
T3. [36:11],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
This is forceaccess.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Please explain the task to me before you start.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
My understanding is that this is probably using private unsafe-to-set flags to set private fields accessible. We want to make users explicitly opt-in to that unsafe transformation - sorry that's the current state. The desired state is that you cannot set the flag it is always false. That sounds very amendable to automated refactoring tools. The difficulty in applying this change is changing caller not in actually making the change itself. You're removing functionality from the API. The work is going to be in migrating everyone who is using the API to work without this elevated access.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Yes. So you don't need to worry about that just the code that is present in the IDE.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So looking here I see this static getField method with the extra flag for forceaccess. It's only used once here so if forceaccess set accessible true. So I could do my initial inline here it's always false [38:38],,Invoke (Change Signature),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Change Signature
This parameter is now unused. What happens if we just delete the parameter. [38:55],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ah yes. So there's already a shortened version of this method. These now collide. Although.. I think the doc for the previous one ..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
There are now two methods with the same name and I'm now deciding which javadoc to keep because they say different things. The second one is wrong we will not break scope if requested. so this.. awkward in there.. What I'm looking at here is that the exceptions are different but they're calling the same method so I expect that one of these docblocs are just wrong. Done. [40:09],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
if class is null it'll throw.. is blank it'll throw..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And we throw again..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So it's just that one of the methods were missing the documentation for that.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So the refactoring there was magical - I assume it did the right thing but it's a little suspect. [40:50] So in the test,"Invocation
Effective (“the refactoring there was magical”)
 Trust (“it's a little suspect”)",,0,1,0,1,0,"<0,1,0,1,0>",0,150-150,0,1,0,1,0,0,0,0,0,0,
Some of these tests should be failing because they should be testing behavior that is no longer supported. So I should go through and look at the tests. Maybe I should have done this before deleting the parameter cause now it's going to be hard to look at the tests and know what they were doing before. Oops. [41:35],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Did you expect the refactoring you used to do this?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes. I just didn't think far enough ahead to think if this is what I wanted. Probably the right thing here is to undo. Except I can't. [41:51],"Invocation
Not Satisfaction (“I just didn't think far enough ahead to think if this is what I wanted”)",Undo,0,0,1,0,0,"<0,0,1,0,0>",0,153-153,0,0,0,0,0,0,0,1,0,0,
So ...,,Restart (git reset),0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Now you rolled back all your changes?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I reverted all my changes since task two. I will inline the other method instead. So now all calls have the boolean parameter.,,Invoke (Inline),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Inline
I: Can you explain?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
There used to be a two argument method and a three argument method. Now every call-site will have a boolean parameter and every call-site with true is now invalid.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Tests should all be passing because I haven't changed the implementation yet but I can go through here and. I'm just looking here. So forceaccess true. It looks like all of these are grouped in one test. Let me think about the word for this.. test method. [43:27],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
All of these forceaccess ones have true.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
These ones also have forceaccess true.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Maybe what to do now is to ignore the flag and go through failing tests. [44:02],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm not sure that I can search for call sites by argument value by this tool. For that I could write a regex or something and do it externally. If I had a larger code base I'd be more worried about that. Otherwise I would just have to look at every - you know find usages and manually examine every call site to see if it's using allowed behavior or not. Instead I have ignored the flag and I'm going to go through failing tests and go through them and identify them. [45:00],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Looks like this test has forceaccesss true in every case so it's now invalid. We don't support that behavior.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
This is also forceaccess true in all cases. This is also forceaccess true in all cases. I'm assuming I can delete test cases without worrying about callers because that would be strange. All tests are now passing. That doesn't necessarily mean everything is right. There could be tests that were passing forceaccess true but don't depend on it. Kinda depends on what this is do I care? Readfield also has forceaccecss [46:10],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
it's probably also one that should be updated. I can come to this one. Wait. I just changed getField. There's going to be a whole bunch of these that all follow the same pattern. but they should all fall back to getField as the bottom of the implementation. Like both read and write will be calling getField I assume to access the field before performing operations. So readfield writefield these both need to be addressed. These are all false false false.. true [47:15],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
This is a test with forceaccess true. Which I think is probably duplicated above. We can get rid of this test it is duplicated once we get rid of forceaccess true. Not sure this public child one has a clear parallel. Again this is me trying to decide how much I should trust that test-cases are well distributed. Can I delete all the tests for forceaccess true without reducing test coverage on forceaccess false. Test coverage in this library looks really good; I think I can do that. [48:30],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I can now get rid of the two argument getField cause all callers forceaccess false or come through readField or writeField which I want to address next. So this is probably next. Readfield has no callers. And.. writeField presumably also has no callers because it seems symmetric.. oh writefield does not have no callers. [49:30],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So there are some callers to writeField with forceaccess which we're no longer going to support. So I can just .. well. test write field. We have write field tests. We have writeFieldTests that expects illegalaccessexception. WriteField with forceaccess has no callers approximately and can be inlined into the twoargument version. I think that's also what I saw for readField the three-argument readfield has only false callers so I can inline that.. So starting from the bottom I think I want to go back to getField. Now I can do the refactoring here to get rid of the third parameter which is not going to be used because I believe all callers are passing true. This code here [51:00] is now a little wrong. And then address the other callers that have this parameter. And declareField. [51:28],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Here I can see forceAccess is unused because I've changed the signature of getField. Before I do it I will just check one more time. Only ever called with false. So I can,,Invoke (Change Signature),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Change Signature
.. well this will be like the first time I can get rid of it find out if the methods collide then resolve that conflict.,,Invoke (Change Signature),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Change Signature
I: So you expect that conflict?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes because I could see that the method was right here. The two argument version.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So the refactoring did break the code but it was what you expected nonetheless.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes it was more helpful for the refactoring to result in code that did not compile than to say I can not do that.,"Reflection
Predictable
 Satisfaction 
 (“it was more helpful for the refactoring to result in code that did not compile than to say I can not do that. “)",,1,0,1,0,0,"<1,0,1,0,0>",0,175-175,1,0,1,0,0,0,0,0,0,0,
I: how come?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"It was more in line with the change I would have done manually. I would make the change, see that there was an in-collision and then resolve the collision. Asking me to modify unrelated code in order to delete the unrelated code feels like an extra step.","Reflection
Efficient (“Asking me to modify unrelated code in order to delete the unrelated code feels like an extra step.”)",,0,0,0,0,1,"<0,0,0,0,1>",0,177-177,0,0,0,0,1,0,0,0,0,0,
I: That isn't relevant to what you really want,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah don't want this name to not collide I want to delete it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Right 'cause you could do that: rename it,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes that would have avoided the collision. [53:20],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now I think the documentation for the two argument version is correct because this one - well it's nice it actually removed the parameter from the comment but the surrounding comment saying it only reads public fields and will throw if it is not public is more correct on the old method than on the new method. [53:45],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
That's readfield; writefield should be the same. Both callers are false. Why are there two callers. There's writeField .. It looks like here forceaccess is always false [54:16],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
so one caller is here in writefield.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What made you go and look at those two callers?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I was just starting from three argument writefield saying before I delete this method who is using it. I was expecting to only see one which is writefield without the boolean. So I'm trying to figure out what the other one is. [54:56],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
This is a helper method that uses a different argument for .. it writes object and string instead of a field object. So this is fine. Interesting. So this method reads the field with forceaccess but then writes the field without forceaccess. I guess that's fine because set access is stateful and you don't need to call it on each access. But seems weird. [55:44],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
There is writeField object string value which I think just replaces this one. [56:00],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And there is writeField .. here they are right next to each other and it's fast to delete them.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So what to do here. Forceaccess is false so this top branch is always false. Not sure what setAccessibleWorkaround is.. oh default access. I'm going to ignore this assuming this will continue to work. I know that my transformation did not change behavior. That I don't understand what is going on here is not particularly relevant. [56:57],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So I think there is still a couple of methods that are three argument. I see a forceaccess here.. So there few methods I didn't find in my first pass is not calling getField through it is calling getDeclaredField through. It's more api scope that I hadn't seen in my first iteraton.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If it's compiling I should probably run the tests.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why did you decide to do that just now?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If i was being very careful I would run it after every transformation. I felt like I had done several and not run the tests so maybe it was a good time to validate that I hadn't broken anything.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So get declared field with forceaccess is called with false it's called from readDeclaredField which we don't need to address [58:28] and writeDeclaredField which we don't need to address.It also has the test case with forceaccess true - which can all go away. [58:42],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And this one as well. These are all forceaccess. [58:53],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So readDeclared writeDeclared calls.. So I will just delete the three argument and only support the two argument. Then again on writeField .. wait which one did I .. writeDeclaredField. I don't think it has any usages - only used here - so ..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You said you didn't do the inline because they were positioned like that. If they had been the other way around ?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah maybe. It's just like - is there one left. GetDeclaredField.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I want to get rid of getDeclared Field. Yes I can just inline it here. Except I pressed the wrong button. SO I want to inline and remove. But then I have to say like yeah I actually did mean this one I didn't mean that one. It would have been just faster to delete it. And I still need to go through and look at you know get rid of these checks hope that my transformation was good. It was faster to delete it. When I see that I can just do the transformation simply I'll just do that. I'll just delete the code.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Let's run the tests.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It's interesting that i was not consistent in my approach between the different methods. I think my initial removing of the parameter was definitely too hasty. Undoing it and inspecting the call sites before removing it made it a lot easier to reason about the code I was deleting. [1:01:56],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: How would you describe the final approach you took and the steps you did? [1:02:06],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
For getField first I made all calls explicit in wether or not they wanted to force access. I then inspected every call with forceaccess true in this case they were all tests they all got deleted.. That's not true. It was also called with true from wrapper methods methods with additional functionality that delegated to getField that also exposed a forceaccess flag so then I repeated the process on them. They didn't have nearly as many callers so it was less time spent reviewing callers - for several they had no callers - so it was easy to change the api to longer expose the flag. Then after removing the flag there was a little bit of cleanup. Removing the code in the method that was using the flag.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Which of these changes would you consider essential or insidental? I got a sense in your explanation that you did some things and there was a cleanup or in order to do what you wanted you had to do some other things.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I don't know. The minimal change to do this would have been to not inspect any callers not clean up the method implementation but just force the parameter to be always false. That would accomplish the goal of preventing access to things you do'nt want to see.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
But to actually work in a code base that has crafty little things like flags that don't do anything or methods that show evidence of there used to be different ways of doing things that's not high quality code. That's not helping future me use this code. I guess the essential part really depends on what your goals are. If my goals was.. these tasks are all fairly self-contained. They are not really expressing a business need or consumer request. They're just I want to make this change. So the real goal is outside the real goal is like .. I want to something. I'd say largely all of this work is incidental to the real goal.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Maybe not in task 3 - like changing the API that's real. An API is an artifact of something that will live for a long time. The majority of the work would have been in actually cleaning up client code not cleaning up the API itself.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What code changes if any did you repeat in order to solve this task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
One thing I noticed myself doing repeatedly was find callsites kind of iteratively. Kind of find callsites then find callsites from the thing I just found. Which I think is a defect in intelliJ: that should be an expandable tree. Eclipse has that it's like .. c'mon.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The kind of repeated remove a parameter collapse with the fewer parameter version of the parameter I don't really know what I would call that as a transformation. It does seem like a common one in API evolution that - I think in large because Java doesn't have good support for optional parameters so you end up writing a lot of wrapper methods that introduce default arguments [1:07:38],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So managing those wrappers is an automateable but not automated task.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: I thought it was interesting how you used inline in the beginning to make the flag explicit in callers was that a change you thought would take you directly towards your goal or a change you did to learn something.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In calling code I would have inspected that transformation and then undone it before the transformation was complete so yes that was incidental. It was largely to make it clear to me what callers were doing to help me identify callers that were doing the wrong thing.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
An alternative approach would have been to find all callers of the three argument method and change them to the two argument method when possible but that is much more manual. That would have involved me going into the calling code and change it to mark that I had identified or thought about it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Whereas inlining makes it very explicit. It also means that I could stop the refactoring there. It is a compiling state it's fine and pick it up again after some intermediate changes or something else going on. [1:09:19],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why is it important that it's a compiling state?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Then you can run tests.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Later you did refactorings that led you to a not compiling state.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
For how long is it not in a compiling state and how many files was not in a compiling state.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Are there some limits for that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It depends on what you're doing. For a library method like this you really don't want to leave your callers in a broken state because they may be in thousands of files whereas if the file I'm working in is not compiling I know what I'm doing here I have that context in my head. I can resolve that before moving on. I think that is just a human skill: like how many things can be broken at once while you can still reason about the system. [1:10:20],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: how did you organise your code changes when you were solving this? I'm thinking about the order in which you did things.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If I was trying to teach this I'd say you should start at the leaf nodes first. I should have looked at all the callers found all the callers until I found the edge of the API boundary.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why is that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Principallay for the same reasons: to maintain a maximal running codebase. If I had eliminated read or Write declared field first they touched very little code. But by the time I got to getField it touched all the code. It's kind of tricky because you need to look at the root change to understand the scope of the impact but when applying the change you may want to work in the reverse direction. [1:11:29],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It is kind of a temporal thing: if I am going to effect all the change immediately it doesn't matter. But if the change is going to be incrimental you have to start around the edges. Or have an API adaptor in the middle that lets you maintain the old form.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: How would you normally organise something like this?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It is important to have the end API in mind and try to use it. Because often what you will find is that your ideal API does not work. For a more complicated example - in this case I think it was fine - but if getField took a bunch of options - maybe you were trying to reduce the number of options or combination of possible options you need to look at the callsites to understand what options are being used whether you can reduce that API surface. So you couldn't just start from a small part and simplify it you need to start from the most complicated part. To understand all the complexity you're trying to manage. Otherwise you'll - like you can start from something really simple and try to roll it out and pick up complexity as you go or you can start from the really complex end say this is all the complexity possible how can I make it more reasonable. [1:13:15],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is that to determine the kind of change you want to make in the API or to actually implement the change?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
That's a hard question to answer that often you don't know enough until you're kind of implementing it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: I see. That kind of happened here to.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes. I had an idea of the API I wanted I started implementing it and then I realised there were more callers than I knew about so i needed to rewind a bit what are all the places that use this API can I satisfy them.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you think the first part was useful?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes. Automated code transformations can be informative. I could also have done that by looking but I could also do it by doing and seeing what happen as long as I can undo. [1:14:16],"Reflection
Satisfaction (“Automated code transformations can be informative.”)",,0,0,1,0,0,"<0,0,1,0,0>",0,235-235,0,0,1,0,0,0,0,0,0,0,
I: And you actually went to git to undo.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I did. I could have done it in the IDE but especially if it touches many files you have to choose which files to touch.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: If you had been working with the API you said you'd work with client usages.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Callers yes.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: How would you find them?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In the case of commons lang you can't. I have never maintained a library that didn't have a consumer next door. For this kind of chagne this is a major version bomb. Do I go and find some consumers and see what they're using? If this was more of a service API rather than a very small helper API you'd say I want to instrument my callers to see how often these options are being used who I am going to impact. You can't really do that for this but it really depends on the scale of the API you're trying to transform.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: I want to go back to the organization of the changes. It seemed to me when you moved through the code that you distinquished between changing the signature changing the body - cleaning up the implementation - and changing or in this case of then removing the tests. [1:15:56] is that a correct interpretation?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes I think those are separate things. You can just assume that you can implement your API so you can just roll out your API change before you actually implement it and then actually make it work. Those are separate tasks. And cleaning up making it work those are stages of the same thing. [1:16:23],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: That's for example the ethod implementation?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes. And tests are just another thing. I was deleting them as I went but equally it could have been rewriting them to test the new behavior or ensure that the old behavior could be delivered through different means.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Would you normally organise changes in that way?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I think in this case both API already existed the desired API and the existing API. If the desired API didn't exist yet maybe the thing to do is - I think the order would be differnt if the desired API didn't exist. Then I would say I'm doing to do TDD today so I'm going to write some tests first or I don't know that this API is actually implementable so I need to prove that it is implementable before I do any more work.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Even in that case you're talking about the order not the manner in which it is organised.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Some general refactoring tool questions. You usually use refactoring tools right?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Are there some cases you choose to not do that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes definitely when I know the tool is going to pick up unrelated things. It most often come up when I want to rename a variable but I don't want to rename a bunch of strings that happen to be laying around nearby. And that's just the tool being too smart or not smart enough because sometimes that is what I want and sometimes it is not. [1:18:35],"Reflection
Satisfaction
 Effective",,0,1,1,0,0,"<0,1,1,0,0>",0,253-253,0,1,1,0,0,0,0,0,0,0,
I don't know how I would express that intent.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Isn't there some configuration option for it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
But I want both.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Can't you just click this..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
But it's the speed of doing it. It's like is it going to be faster for me to use the tool with it's default and fix the things it get wrong or use the tool and it gets everythign right or do it by hand.,"Reflection
Efficient (“the speed of doing it”)",,0,0,0,0,1,"<0,0,0,0,1>",0,258-258,0,0,0,0,1,0,0,0,0,0,
Several layers further down there's use the tool and click checkboxes to make it right. It really depends on the refactoring. I think that particularly is one I encounter a lot. It is more common in less well-scoped or less strongly typed code. Where the thing you want to rename is less clear.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: It almost turns into find and replace.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes. Which I could do by hand if I wanted. I think another place where manual tools win are if you have - like trying to do transformations on things that are sort of code but not really like typically if you've got a bunch of constants or a static block of repetitive code I could try to use refactoring tools to change the signature or .. but it's faster to just find and replace or multi-cursor the new parameter where I want it because I know that there is some regularity in the structure I'm trying to transform that may not be apparent to an automated refactoring tool. [1:20:58],"Reflection
Not Efficient(“I could try to use refactoring tools to change the signature or .. but it's faster to just find and replace”)",,0,0,0,0,1,"<0,0,0,0,1>",0,261-261,0,0,0,0,0,0,0,0,0,1,
I: So those are all cases where it is faster to do it by hand rather than using the tool?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes faster or possible whereas using the tool - there is no way for me to communicate my intent through a refactoring.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You mentioned trust as an aspect of these tools. What are some example of cases in which you don't trust the tools?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In my work I typically work in typescript and I know that the find references tool does not find all references so I know that any automated refactoring will miss some call sites. Sometimes it's still worth it to use the refactoring tool and find the remaining call sites myself but I know that I need to do my own search after to either verify or complete the remained of the transformation.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It is really a tool specific thing that if you know the tool well enough you recognize the bugs and you know you will hit them again. And maybe you stop using the tool. I don't have any big dogmatic that I don't trust the tool to do X it is just that over the years of using refactoring tools I've known there to be buggy tools I've seen them.,"Reflection
Predictable (“if you know the tool well enough you recognize the bugs and you know you will hit them again”)",,1,0,0,0,0,"<1,0,0,0,0>",0,266-266,1,0,0,0,0,0,0,0,0,0,
I: And you kept using them?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I kept using them. Because they are much faster than doing it by hand.,"Reflection
Efficient",,0,0,0,0,1,"<0,0,0,0,1>",0,268-268,0,0,0,0,1,0,0,0,0,0,
I: Which refactorings do you usually use them for?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The most common one is adjust method signature. Like reordering method parameters. Like that is trivial. I trust the tool to do it and it is a lot of work to do by hand. Or introduce a new parameter. If I can introduce a default parameter to all callsites. Maybe I have to go through and see what the real value is at each call site but the tool has identified the callsites for me and has injected a marker for you need to do some work here.,"Reflection
Trust 
 Effective 
 Efficient",,0,1,0,1,1,"<0,1,0,1,1>",0,270-270,0,1,0,1,1,0,0,0,0,0,
I: What do you mean by injecting a marker here?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Defaulting it to null or.. in IntelliJ when you introduce a parameter you get the choice to.. like I think it even has the option to pick a local variable that looks plausible - it's like well ok I really need to audit that - but sometimes it's right and that saves a lot of time.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: And in the cases when it is not right?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Then I have to fix it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: But you need to navigate around?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes but by making the change automatically it has marked all those places for me. I see them as changes in git. It is like having used find all call sites and navigating through them one by one. In a way there is a checklist now: these are all changed files and I need to go and examine every one of them rather than doing a find and getting a list and maybe forgetting to look at some of them.,"Reflection
Satisfaction",,0,0,1,0,0,"<0,0,1,0,0>",0,276-276,0,0,1,0,0,0,0,0,0,0,
I: What is your take on correctness and predictability in refactoring tools; would you mind explaining how you interpret and think about those two concepts. [1:25:22],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Correctness is an ideal but I think my expectations are not always correctness. If i ask the tool to do an impossible refactoring I'd might rather it do part of it than say that's impossible I can't do it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So for example the one in the second,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes the inline. Yes sure it doesn't have sufficient code analysis to do the right thing but it said 'no I can't do that' instead of saying I'll try but I'm wrong.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: It could also have done this more complex change,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah I think I'm not worried about lack of correctness as long as that lack of correctness is apparent. If I did a change and it compiled and it was wrong then I'd be worried. But if I do a transformation and there's obvious incomplete stub-bits around then I see that the tool is behaving predictably - I think that is key - and I see where human attention is required. [1:26:53],"Reflection
Predictable",,1,0,0,0,0,"<1,0,0,0,0>",0,282-282,1,0,0,0,0,0,0,0,0,0,
The predictability is far more important. I can reason about tools that do anything as long as I can reason about what they did and fix their mistakes or give them different options or whatever. But if mental model of what the tool is doing is wrong then the tool isn't helpful because it might not be doing what I want it to do.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you have any examples of what is lack of predictability in tools? Imagined or experienced. [1:27:42],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Not quite refactoring but automated import management. It should always import the same thing given a term and then I can fix it. If it import random different things with the same name then I always have to double check its work not only when I know it has done the wrong thing.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: That's interesting because that may use some contextual information but you're saying you'd prefer the predictable..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
That's tricky. If it can use context and be right then I'm happy. But if it uses context and falls below some reliability treshold then I always has to check it and that increases my work.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What is your reliability treshold?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I don't know. I suspect that. I don't know.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is it about the number of times some level of badness ..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I think it has to do with the amount of work required to clean up the result too. If it is a lot of work and it happens infrequently I'm still going to be afraid of it whereas if it is easy to fix and it happens 50% of the times maybe that is still worth the tradeoff. I think it really is an effort-balance of how much work is it to do by hand and how much work is it to clean up.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Thank you that's all.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
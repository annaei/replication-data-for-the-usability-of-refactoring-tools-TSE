"Let me see if I can figure out IntelliJ. First step - that's actually something I haven't played with, since I'm an Eclipse guy from history. I just need to see if a couple of things works like I'm used to.",,,Predictable (11),Effective (5),Satisfaction (6),Trust (7),Efficient (3),Vector: ,Invoke (11),Row Range, Predictable (6), Effective (2), Satisfaction (1), Trust (6), Efficient (3),Not Predictable (5),Not Effective (3),Not Satisfaction (5),Not Trust (1),Not Efficient (0),Refactorings
T1 [02:57],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"We'll go find the actual classes that we're talking about. We have the few tests that we want to have here, and we want to basically get them out into another class. One thing I'd want to look at here is how the tests are structured to make sure that it makes sense where you want to put them, and of course come up with some type of name for the test class. [03:41]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I don't know all the different things that are here. But in most cases, I would take the approach of creating the class, then moving the specific tests across, so it's pretty simple. What could be useful in a case like this of course, is a refactoring that says I'd like to move these test to somewhere else. I don't know if that exists currently or not.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You were looking at the extract menu.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Exactly, so I don't know IntelliJ, but sometimes extract is like, extracting into another place. Move was of course something that I first hit on. I can move it into a class if I first create the class, but it'd be nice if I can do both at the same time. The other place that I would look at if there was an overall view of the class, like eclipse has.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: That would be structure down here.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Right. So the question would be if you can do something like this. [04:57]
 and basically select multiple of these and then be able to refactor them out - of course would make my life really easy. Now I don't think most of these tools have that ability, because even here, there is no option to move it because it's not actually looking at the hierarchy. But if you're looking at moving a chunk of things, that's one way I would go about it.","Invocation
Not Effective (""there is no option to move it “)",,0,1,0,0,0,"<0,1,0,0,0>",0,8-8,0,0,0,0,0,0,1,0,0,0,
I: Did you expect it to have it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"No, I didn't expect it to have it. I hadn't even thought about doing something like this before. Because the way I always thought about testing is testing on a class basis, so setting up the tests to match the classes more closely, not based on the function of the test.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Do you want me to actually finish this? 
 I: Yeah. 
 Alright. [06:24]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"One thing that I do find interesting in this is how these seem very related - because it's trim empty test versus just empty - so there will be something about whether it actually make sense to abstract them out, or if it makes sense to move them all here and rename the class. But without digging into each and every one, we'll just stick with moving each of those tests.",,Invoke (Move),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Move
I: So that's a design decision then?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Exactly. I want to do that. Does that actually work the way I want it to? Ah, yes.
 I: What happened now? 
 This isn't able to easily refactor it, because of course it's using a local - global - variable, so it cannot actually move the method without taking some information or exposing it across the two test classes.","Invocation
Not Effective (“This isn't able to easily refactor it”)",,0,1,0,0,0,"<0,1,0,0,0>",0,14-14,0,0,0,0,0,0,1,0,0,0,
"I: So, just to clarify, the error message was about using that variable?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yes, that's what the error message said, it wanted to make it public so it can move it across and be able to reference it. Because the only other way to do that is to copy the variable and get duplicated code across. But again, whether that should be opened up to be something that is available across classes is another design decision to be considered along the way. So just for fun, let's go back to this one. [08:13]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Interesting. There is just the testEmpty method which doesn't seem to be on your list.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: That's weird.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So I can try to do this one as well, and it has the exactly same problem, because it's referencing something that is already used within those other tests then you come back to the design decision whether you should be extracting it. It might make more sense to actually be consolidating all the tests into a single stringUtils.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: Ok. Are you comfortable trying to finish the task? 
 

 Yeah. I'll just do the craziness.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So what happened now? [09:16],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I've no idea what happened now. It didn't do anything. So it seems the first time it just made it accessible as a public, and now it will actually move it. So it's actually a bad workflow that it doesn't go to the next stage.","Invocation
Not Predictable (“no idea what happened now”) 
 Not Effective (“It didn't do anything.“) 
 Not Satisfaction (“it's actually a bad workflow”)",Invoke (Move),1,1,1,0,0,"<1,1,1,0,0>",1,22-22,0,0,0,0,0,1,1,1,0,0,Move
"I have my new class, stringUtilsEmptyTest, and in here now, I can go ahead and move my specific - one at a time, awesome. [10:04]
 I will just refactor that.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"That's testAnyBlank - allBlank - All empty. I wonder if there is a way to do multiple. It doesn't seem like there is, so I'm just going to roll with it. [10:39]",,Invoke (Move),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Move
I: Why did you cancel it now?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I wanted to go look at - kind of my thinking now is that why should I be asked again for making something, so I want to see what it did over here. And - one thing I'm actually wondering now out of curiosity, is whether this is actually being referenced. Because I think testBlank is being used [11:10] somewhere else. What I find interesting in this refactoring is why it had to become static, because that would tell me there is something in the original test-class which is not opening.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: When did it change to static?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The method that I moved got changed to a static method. Which tells me that it’s being called from the other class so it needs a static call across which requires other architectural changes. It is interesting that it lists no usages of it. Which means there should be no reason to make it static to make it a valid refactoring.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Does that make you more reluctant to use the tool?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"In this case, yes. It starts opening up additional questions from an architectural side, because if you end up making a bunch of things static for no good reason why would you use the refactoring tool because it's doing something that is not expected. If there is no references it should be able to move it.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"[13:14] In the end, for these ones, I would just copy-and paste and put them together just because I don't trust the move in what it actually does, and trying to figure out how it works.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: so at this point you want to change your approach?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I want to change for this one, knowing what it did there. I will change my approach to better suit my expectations and then found out if there is something happening that I was not understanding properly. But, from history, I used to copy and paste a lot because I would also want to see those kinds of breakages. The refactoring tools may try to show it to you or may not have a great way of showing to you, what it actually is affecting in other classes. So you only end up seeing that as part of committing. Sometimes it's easier to break your code to see how it's coupled together, because it may change your approach.","Reflection
Not Predictable (“I would also want to see those kinds of breakages. The refactoring tools may try to show it to you or may not have a great way of showing to you, what it actually is affecting in other classes”)
",,1,0,0,0,0,"<1,0,0,0,0>",0,33-33,0,0,0,0,0,1,0,0,0,0,
I: How would you usually approach this?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"From the test side it's a little more interesting, but when I used to do it I'd say, I want to move these specific fields and then just copy and paste. Understanding that they should be fully encompassing themselves you can find out what is broken and think about the architecture a little more. The more you use these refactoring tools, the more your architecture can start falling apart, because you start exposing things as static or public that should be isolated a bit more.","Reflection
Not Satisfaction (""The more you use these refactoring tools, the more your architecture can start falling apart”)",,0,0,1,0,0,"<0,0,1,0,0>",0,35-35,0,0,0,0,0,0,0,1,0,0,
"I: In the case of exposing it as public or static, are you worried it will break the behavior right now?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"No, I wouldn't be worried about breaking the behavior right now - from a behavioral standpoint very rarely would I see things as problems with breaking, especially with constants and such. If you're looking at a constant, and you make it static - sure - you have one copy across all your classes, and moving it around is not going to break behavior. Similarly if you make a method static. Normally that is not going to break behavior, it just changes how you call it.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"But if it starts to impact true variables, if you have a variable on that class and you make it static, then that would become something that is an instance-specific - if you have multithreaded application you can change the value globally instead of the specific one on the object.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"In most cases I wouldn't expect it to have detrimental breaking behavior depending on what it is, but it could have some kind of bad behavior in the future. It changes more around your architecture and how you build something, because if you expose things as public or static, they get used more. It is just natural to start using things that are easy to access.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Then you get to a place where you're doing bad API design and don't really understand how your system is connected.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So the way the tools change the code would impact how the code was used in the future and how it grows.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yes. Especially in organizations and open-source software. If you took something that should be internal and made it public, someone is going to use that as API, so you can't necessarily change it back, so you're stuck maintaining it, even if it's not necessarily something you want out there.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: What about taking the result and changing it back? For example, removing the static modifier in this case.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"In this case you could, but if it gets through and someone start consuming or building, then you can not.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
These ones will have problems because they reference FOO that I don't have a reference to because I did not use a refactoring tool,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"But because I have already moved one, I am fine to just do this.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: If you had used the refactoring tool, what would you have expected it to do?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"That it would have added this reference because it knows that there is a reference to that variable and that it is public, so it can be used across classes, and would have updated these variables to actually refer that.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Still says I cannot resolve FOO, because I need to go over here, I'll make it package protected. And that should be it.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Did the tests run before compile? 
 I: Yes.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"It says the the variable can not be resolved. did I mess something up? 
 I did - I put the wrong class name which is why doing it manually is bad..",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"This is one of the benefits, if you have a refactoring tool you trust, is that it can make sure these are correct. But making sure it exposes the changes it is going to make, and why, is a pretty big deal. That's one thing I always have. 
 The idea of visibility and knowing that is going on, is very important for me, rather than seeing it after the fact.","Reflection
Trust 
 Predictable (“making sure it exposes the changes it is going to make, and why, is a pretty big deal”)
",,1,0,0,1,0,"<1,0,0,1,0>",0,52-52,1,0,0,1,0,0,0,0,0,0,
I could always go and use the tool and use git to see what actually changed along the way..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why don't you like that approach?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Sometimes inspecting changes after the fact can be hard. There is going to be code that is unrelated to your refactoring, since normally refactoring tasks is done as part of other tasks. When you're looking at it after the fact you may also not be able to undo it if something doesn't look right, so it's better to have the information up-front. [23:46]","Reflection
Predictable (“When you're looking at it after the fact you may also not be able to undo it if something doesn't look right, so it's better to have the information up-front.“)
",,1,0,0,0,0,"<1,0,0,0,0>",0,55-55,1,0,0,0,0,0,0,0,0,0,
"As you see here, because the refactoring tool added static to my method, the first test that I actually moved it won't run.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Where is that one? 
 testIsAllBlank",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"so, as a part of this, you can see that using the refactoring tool actually does break the code functionally. If it wasn't on a test it could have had a different impact, but because it is a test it is a little different.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: It prompted you about making it static though.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"But when I said no, it didn't allow it. When I said no, it stopped the refactoring, so you either have to say yes, or not use it. If you say no it does not allow the refactoring, so therefore we had to go with it. But that's also why I reverted it, because I didn't like what it was doing.","Reflection
Effective (“ If you say no it does not allow the refactoring, so therefore we had to go with it”)
 Not Satisfaction (“I didn’t like what it was doing”)
",,0,1,1,0,0,"<0,1,1,0,0>",0,60-60,0,1,0,0,0,0,0,1,0,0,
I: Did you expect it to break the test?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I would not expect a refactoring to break a test especially for a move. That's bad.,"Reflection
Not Predictable (""I would not expect a refactoring to break a test especially for a move."")
 Not Satisfaction(""That's bad."")",,1,0,1,0,0,"<1,0,1,0,0>",0,62-62,0,0,0,0,0,1,0,1,0,0,
"I: Are you done? 
 Yes.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: what code changes did you do in order to solve this task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I added a new class, moved the methods across and opened visibility for a single field in stringUtilsTrimEmpty test, so it can be seen across, and updated the appropriate qualifiers. I could have also copied the variable across, but that would have ended up with duplication of data. But if I had been thinking about it on a grander scale I could have seen if the FOO was used anywhere else, and if not, moved it across as well. Depending on how it's used anywhere.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you know of any tools that could have automated any of the changes you made?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Other tools? Hm. Not that I can think of. I'm sure there are some. I know there are a lot of tools for refactoring, I used a lot more in Eclipse. The Eclipse stuff I've used is more proactive about telling you what it is going to do. But I haven't used IntelliJ enough to know, because there's a lot of people who like their refactoring abilities.","Reflection
Predictable (“more proactive about telling you what it is going to do”)",,1,0,0,0,0,"<1,0,0,0,0>",0,67-67,1,0,0,0,0,0,0,0,0,0,
I: Can you elaborate on what you mean by proactive?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Really showing you - the idea of a dialogue that shows you what you are going to do. Instead of - right you do it, but then it says here are the types of changes, but then you can review it and see exactly what is happening. It is not for all of the refatorings, but I know there are a few of them that gives you that, especially when it will make a more prominent kind of change.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: Which ones have you used in Eclipse? 
 Probably a big chunk of them. I actually have Eclipse open. 
 I: Would you mind sharing it from on top of your head?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Rename, Move, Extraction, of variables, methods. And the different types of renames - local vs global.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is there any you avoid using?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Not something that I kind of explicitly want to avoid, but there are always these cases where I avoid using it kind of based on looking at the code and what I am going to do, and maybe get a sense of what is going on before I make a change. If you create something and copy and paste it you can understand more of what impact your changes has by seeing if it breaks one place or does it break the entire project, and that changes some of your thoughts about potentially how you go about refactoring the architecture.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Can you elaborate on how your workflow integrates the different options? At what point would you decide to use a tool or to do the manual step?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"In a lot of cases, if it has to do with just extract methods or renaming, the tool will be on top of my list. If it is more architectural, like I want to move like, where this call happens, or how this is actually working, to somewhere else, then a lot - especially when I knew the codebase and kind of understand my thought process - if I thought it was going to be something minor I would use the tool and could reactively easy check and know what changes were made. but if it's something where I don't know how much it's used or how it is going to break, I would do the manual change.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"And sometimes I would do the manual change to see what it was, but knowing what changes may need to be done after, I may undo it and then use the automated tool. That's more about getting that proactive visibility of understanding what the impact will be.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you would do your manual change and see what break in order to understand the whole process.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Exactly. And sometime I would go back and use the tool and sometimes you just move forward with the manual approach, because some of the refactorings I did in history was to try to fix up the architecture. In some cases you don't want to update everything to point to the new location, you want to actually think through it in a different way for the different places. So when you're building an API you kind of want to break the old one, put the new one in place, and figuring out how it should be used. For example, one place in your code that is using it today may not be the appropriate way to use it if you are thinking about the overall architecture.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Sometimes you want to explicitly break it so you have to think as you are going through the process. but the simpler one, like renaming a class.. Extracting interfaces or superclasses can be really useful as well, because you're just moving things up higher.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is there any of the changes you made that you are unsure if you got right?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"From an architectural standpoint, if I should use the static foo or move it.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: If you were to do this again, how would you solve it?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Probably the same way. Like, if I was doing this on a daily basis I would probably have copied from the start instead of using the refactoring tool, but only if the tool was new to me I had to try it.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
T2 [31:30],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I first find the method, the ones we are looking at getting rid of, which is isAnyNotBlank and isAnyNotEmpty, which are here. And this comes back to kind of my thoughts about an architectural standpoint of thinking of how it is used. In this case I haven't even looked if there is any refactoring tool that would support this but there is potentially contextual information that is needed. like, knowing what the method does and what the replacement is supposed to do. to be able to put it together. I would manually delete these and see where it's broken. That has an interesting set of challenges, because there could be a lot of places that needs to be updated, but there's really kind of not a great way to do that. Now, there's a question of there should just be a not of the isAny-blank and kind of go down that path, but that decision has already been made.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Can you elaborate on contextual information?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Because of the way this is written you need to look at the code to see what it is trying to do. It may be the case that you just do a negated call, like not is any blank - so just putting the not symbol in front. But it also may not make sense - since it's a boolean one it's a little funny, but you may try to look at this to understand why this is used over the other case, because there may be something different if how they are. So if I'm looking at isAnyNotBlank then I'd want to look at isAnyBlank, and do they actually match with a proper negation. Looking at those now they have a full set of code instead of just writing a not on the other one, which would make a lot more sense.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I'm just going to delete it, and I 100% believe some tests are going to fail, because these methods are not actually inverses of each other. That's not isNotBlank.. is any not is any not empty.. ok. [35:24]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Then the question is, where is it used and how badly did I break things?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is that what you are expecting to see now?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"That's what I would expect to see, something to break, because that would mean it is used. Where would I see that?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The red bar is too small to see.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Is there a error view? 
 I: You have to recompile. 
 Alright, awesome, I love this.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What did you notice?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"What is interesting is that isAllEmpty uses the negated one and does the negation on it, which was .. the opposite of what I thought was going on when I looked. But I guess I looked at the wrong method. So what needs to be done is to reverse out the code for those two. Ok.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I will undo my change at this point. And then I'll break it in a different way. The way I'll break it now is to go to the isAllBlank and isALlEmpty methods and do this thing, and copy out the method signature for isAll and just delete that, and go to the isNotAll - if I can get this working - is any not blank .. and then do something like this. If you do something like this manually, there is the chance of forgetting to make other changes that will cause problems. So then I must go ahead and change the code. So I must do like, - isBlank, would be one option here. [39:17]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"and actually look at the context of the code which has it's own set of problems, right. So that's one thing, to get it inline and fix that. The code is written backwards from what most people would expect.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: what do you mean by get it inline?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"The negated version - it should all be opposite, so you should go through here and negate the boolean values. You may also change some of the other steps along the way. I need to go through and understand this code to make that change. I not a big fan of that idea.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You're not a fan of going through the code and understanding it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"No, I don't have a problem with that. I am not a fan of how to code was written, it was kind of backwards.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What made you think that it was backwards?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Most people go with something simple like isAllBlank first, and you usually don't have negated things as part of your API.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Another way you could go about fixing this is actually not removing that method, just making it private, so it can't be called from the ouside world, but it will still bloat your class.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So, isAllBlank - it is an empty array - interesting",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"so basically reading through this here, I change it such that isAllBlank - if there is empty, it is all blank, as we are going through the characters, if we find something that is not blank, we will exit early basically, and say that it is not true, because not all are blank, otherwise we will say it is true, because we got through and all are blank. That's that one. Now let's see, isAllEmpty. And I will do exactly the same with that. I do have this interesting thought - not 100% sure yet -",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why were you undoing now?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
isNotAny?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Because I'm looking at the wrong thing? No. Trying to get my head wrapped around everything. I think it'll be an issue thought, this was looking isAnyNotEmpty - oh it is isAnyNotEmpty..",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'll do the same thing here. [43:19],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
isAllEmpty ..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'll do the same types of changes here. Basically negating the whole thing. Then we can redo the tests.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I will go through the tests and see what happens.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Now of course the tests breaks, and that makes sense because we actually had proper tests for it. In this case we don't need the tests any more because this should be the case that they are already tested by another test, but that's something I should look into. For the purpose of this I will assume I know the code base well enough to say it is tested at both sides. Doing this again. [45:35]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"My tests passed. I think I removed the methods - even thought I didn't use any refactoring tools, but it is kind of - it requires a little more knowledge when you are removing something. Especially in this situation: you need to rewrite your code as part of the refactoring, because it is not a normal refactoring.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Which changes did you do in order to solve this task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I went and updated the StringUtils-class, and also updated the two existing methods that was already in place, with the appropriate code so they test for the positive case, like are-empty instead of is-not. Of course I updated the tests and made sure we didn't have any tests any more that referenced the wrong method.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Can you elaborate on how you updated the stringutils-class?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I took the method we wanted to keep - after I found out that it was a simple passaroo to the method we were getting rid of, I took the method we wanted to keep and moved that method signature across and then went through the logic and reversed the logic so it would be boolean-opposite.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you know of any tools that could have automated what you did?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"No. I don't think there would be any, because you needed to know the code. I think that would be an extremely hard one, because that actually have process defined.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Can you elaborate on what you need to know about the code?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"If you want to do a good job about it you need to understand what the code is doing, like what the checks actually are.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: The checks inside the body..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"The checks inside the body of the code. So you need to read the code and understand the logic of it. For this specific case, since it is simply negating a boolean, you may be able to do something like that, but I think it is a danger or risk in that, because if you're doing that you should probably have a bit more of an idea of if it makes sense and what else are happening. It might not be a good idea. But there are other tricks, like assigning a variable, and returning the variable not at the bottom. Like extracting a boolean out of the code, which just makes it ugly.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
T3,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So you should not have forceAccess anywhere in the FieldUtils-class.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Correct. [49:05],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The first thing I'll do is just to have a look at it to see how some of it works behind the scenes.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
One thing I have used in the past is adding arguments to methods and sending in a default value if it not there. [50:19],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
But of course it depends again on what I'm trying to do. I've never checked if there is a way to remove arguments. I'll just go ahead with change method signature and see if I can remove.,,Invoke (Change Signature),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Change Signature
"I'm going to go ahead and preview this time, because there is a preview button and that should tell me exactly what's going on.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"There is already another method that way, which means that - it may actually - it will collide - what I'll do in a lot of cases is go back and see what does that one do. It just sets it to false. Something that - I'd take two different approaches is to delete this method right off the bat. Another is kind of similar to what I did in the last one. But in this case I'll go ahead and delete this, and try to use the refactoring tool. I want to see what happens from it. With something like this it can be a lot easier with a refactoring tool to help remove some of that.","Invocation
Efficient (""it can be a lot easier with a refactoring tool“)
",Invoke (Change Signature),0,0,0,0,1,"<0,0,0,0,1>",1,133-133,0,0,0,0,1,0,0,0,0,0,Change Signature
I: Why is that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Kind of back to the same, understanding to happen. When I go ahead and do this, in the preview here I can see some of what's going on, and it's not necessarily just breaking it, it's kind of seeing it in different ways. Like when I break things and go and look at the errors, I should be able to get some of the same context here. Instead of having to manually delete everything by hand. And we'll kind of see what state it gets us into. I'll ignore the error and continue, because I can come back and fix the logic in that. It's more interesting about all the different places that has that changed.","Invocation
Predictable (“in the preview here I can see some of what's going on”)",Invoke (Change Signature),1,0,0,0,0,"<1,0,0,0,0>",1,135-135,1,0,0,0,0,0,0,0,0,0,Change Signature
"52:34
 I: So to clarify, the other time the error caused you to go back and make a manual change, but this error you was ok with. Why was that?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Previous time, it was a collision between the methods, so at that point I wanted to see if the other method was doing what I was expecting, of passing false along as a default, to understand how the behavior would change for any of those. In this case it was just that's is actually used as part of the logic and we know that we're going to get rid of that as the actual change and the question is what is the actual impact. [53:07]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Is this the one I just removed? Now I just need to kind of through, basically, this, which of couse has a slightly different UI, but it's kind of nice, because I can go through and see ..",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Different from Eclipse?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"No, different .. something I haven't seen before. I don't know if I've even used remove before, so this is kind of new from my side. Some of these things that actually seem interesting is that there are other methods throughout here that actually takes in that same type of parameter, that will also need to be refactoring because of this. Looks like readfield and writeField also need to have that removed. And then of course tests. There's actually, it looks like, a number of things that needs to be modified. The benefit with something like this is that the forceAccess-tests, we know that we can get rid of those. it would be nice if there was a way you could delete from here, to say, can I just get rid of these as part of the refactoring, when you're making a major change like this. But I'm just going to go ahead with the refactoring and go look at the readfield and writefield [54:48]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What was that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Just trying to see what the UI means here. It says invalid and it's not letting me get anywhere. I think that's actually the way - it's actually been refactored so those positions don't exist anymore. And here you can see there's just getField, but now you don't have the same fields being used, so I can go through the same process for these ones,",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: I'm curious about the errors that showed up over here, did you notice them?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yes, I noticed them, but I was going to come back and look at those after, because I know there is going to be errors in the getFieldMethod, because forceAccess isn't a variable any more and I'm kind of forcefully breaking the code. I'm taking the approach of what happens if I remove everything first, and try and actually break the rest of the classes and understand some of the impact on what it really means, then come back and fix logic. [56:01]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And of course there's already a method again of writeField. So let's go and have a look here again. I have the readField and WriteField. I know I have both. ReadField also default to false. And then I can go back and actually make those changes again. [56:47],,Invoke (Change Signature),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Change Signature
Preview that. Trying to see what other things I might be looking at here. Preview that again.,,Invoke (Change Signature),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Change Signature
I: What kind of information were you collecting from this view now?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I'm understanding what the changes are, so understanding that I can remove any test that has forceAcccess, because it is testing something we don't need to test any more. So knowing that there is another transitive dependency, and that it is called with the same kind of value we expect. Then I'll do the readField, just the same. [58:00]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I deleted that route already. Or maybe I deleted something else and I've broken it completely.,,Invoke (Change Signature),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Change Signature
"For the purpose of this, I'm going to do this and delete it out of the way.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I can come back and fix the errors that are specific, we're not going to forceAccess, so i'll fix that. here, WriteField, so in this case, I only want to update this if the field is accessible, otherwise we will just .. actually.. set accesssible workaround ..",,undo,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"59:56
 I: Why did you undo now?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"It's a little more complex logic than just setting the accessability, so I wanted to make sure I understood what changes was going on. Maybe this will do exactly the same as what we are getting rid of, under the scenes. This may not be completely in play .. because no matter what writeField will always set it accessible, because if it is true, it will set it accessible, but it was regardless going through some accessabilitystuff. I think in this case, I can bascially always use this.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Because they do the same thing?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yes, because there are similarities. Here we're setting the accessible workaround, and here it's still setting accessible if it's not accessible. Without knowing the code at all, no matter what the value is, setAccessible is being called again. If I'm looking at it I'm not sure it actually does what we want, because this still does forceAcccess, because it still adjusts modifiers, like visibility modifiers, but based on the task it should keep being functionally equivalent to what it was before.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
What did I break? [1:01:55],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I specifically didn't touch any of this code on purpose, but it really looks like something broke. [1:02:33]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"It's of my own doing, doing things too fast. Right now I'm trying to look at where that bracket is supposed to match up to. How do I fix this.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Now you're looking at the version control?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I am trying to compare it with the previous. What did I accidentally delete? [1:03:39],,git diff,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Oh I see what I did. That makes sense. I just missed a bracket along the way. I got myself into a happier state. Now I must go to the fieldUtilsTest, and over here I want to .. oh no. I want to find anything that has forceAccess on it, and I guess there's technically an error right now. The ones that are in error.. it's still going to be calling the method.. let me find out. Yeah, you can see they're still wanting to call the forceaccess - am I looking in the right place? Yeah. [1:05:11]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Where's all of these forceAccess, I thought I renamed that one. Maybe I didn't do the readfield yet. I'm actually not sure what I broke here, but we'll just do this.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I'm just going to manually update this, because I'm not sure what I did wrong, so I just want to see.. All the test methods have the right parameter, that's why I'll revert it manually, because if I use the refactoring tool it shouldn't do anything because those are already, technically incorrect references. But of course there's a few errors in here, because these didn't get updated in the local one, which means I did something wrong as part of my refactoring. So you're stuck with me doing it manually. Instead of reverting it all the way back, I'll stick with this idea of, I broke something, I'm far enough along, because I didn't do partial commits along the way or anything like that.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"1:06:51
 I: Would you usually do that?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Depending, there may be partial commits of saving your state before going to the next one in case you make a big change and something goes really wrong.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"1:07:07
 I: Why did you choose to not do it this time?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
No good reason. Even though you showed me the git stuff I didn't think of it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Another great thing with using a refactoring tool is that it updates your documentation. Back to these. [1:07:54],"Reflection
Satisfaction",,0,0,1,0,0,"<0,0,1,0,0>",0,168-168,0,0,1,0,0,0,0,0,0,0,
"Trying to recompile it since we've done some fixes, and then run the tests. Wrong first argument. [1:08:25]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now I'll go look at what other changes were made to this to see what I could have broken by doing someting incorrectly along the way. I think I deleted the wrong method when I did some of the refactoring. I need to go have a look here. fieldname ... is gone .. [1:09:16] so readfield..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"here we go. I accidentally deleted this one. Which I should not have. I thought I actually broke something because.. i'm just going to copy this and put it back. I'm sure there's a better way to do this than in this editor. But.. yay. Now I've got it compiling I think. And I'll try to run my tests. I think I got myself into my own trouble because .. Sometimes I like bigger screens and more space, or else you need alot more knowledge, since on a small screen you can't see that much around you.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"These are the ones I was supposed to go back to delete. They are tests that were refactored but they just had the true removed, which means that they are no longer valid. It made compiling code, which is interesting, because you kind of don't want that to compile, you want an easy way to get rid of that instead of needing to run the tests. One thing that is interesting, is that if these passed, that could actually be a bigger problem. But in most cases when you're removing functionality you're also removing the tests related to that functionality. [1:11:29]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Right now I'm doing this based on the failures, and the names because I know these are the ones that pass through true. This is one of the cases where a manual change is nicer than the refactoring tool because you can see the direct impact of what changed, especially within test cases like this, where you have something that is broken and you know that you'll remove the right thing.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: So to clarify, the broken state would be that they still retain the boolean argument.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"They retain the boolean argument, and would therefore be broken from a compilation standpoint. What's interesting is that this one still passes, but it should be removed as well because it has forceaccess, but this is a problem of the actual code itself. The forceAccess for that specific method doesn't necessarily change its behavior. But in this case I could just run it all and see that everything passes, and walk away from it. And in most cases that's what would happened. The path I took made me realize this potential problem that forceaccess didn't do anything, which is interesting. But right now it's probably just a duplicated test that could be removed.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
That covers the task.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I removed forceaccess.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: I'd like to just go back to the class and check that it's removed.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"It's still there. Oh I missed a couple I guess, interesting. Ugh. [1:15:04]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So I'd have to go back and basically do the exact same thing, so delete that method, refactor, change signature, do this, it's not used anywhere, awesome, refactor, This one.. Let's do the same thing. refactoring. [1:16:24]",,Invoke (Change Signature),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Change Signature
"This actually really cleans up this class as an aside. It seems like they could have gotten away with making forceaccess something higher-level, instead of making it static and passed in and it would have been much cleaner. One more.",,Invoke (Change Signature),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Change Signature
"Cannot perform the refactoring. Did it run the refactoring already? Looks like it ran the refactoring. Now I'll go ahead and compile this. I can see my actual errors here. So in this case I can just take out the code that was specifically for controlling access, I can break it this time. Maybe I broke it completely again? Did i push the wrong button? I did. [1:18:51]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Now I have to go fix the tests again, at least I should have to. But it doesn't actually seem that way from the information here, so I'll go ahead and run them. And now I actually have a problem with a specific test. That is a forceaccess one as well which can go away, because it's something that should fail. There we go. [1:20:46]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I'll say at this point, the tests are passing, I removed the field values, I'll call myself done this time.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"But verification of being done is hard, because at least in that class it was all individual methods, and it's not like it was a simple field removal, it's changing method signatures on everything.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What changes did you do in order to solve this task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"In fieldutils I removed all the pass-through methods that were simple without the boolean argument because those ones would collide with the new signature when I had removed forceaccess. I refactored all the method signatures in fieldUitls, so it removed that boolean, I removed the associated tests that were testing from the point of view of the forceAccess and updated the code to remove the forceaccess parameter throughout the code and updated the logic to ensure that it was consistent with the previous version if false was passed in.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why did you chose that approach to remove the pass-through methods?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Because all the logic was included in the ones that had the variables, so that was an approach to clean up the api. It's easier that you only have those methods in there. Another approach I could see is that you gone through and made all the other ones private, so you can't use them but you have an ugly class. It is simpler. And at the time, knowing we wanted to refactor it out, that was the right approach, because it would have been just code cleanup otherwise.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you know of any tools that could have helped you?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Not outside of the ones I was using for changing the method signature and see what was happening. I think with a different architecture the could be things that would help more. If it was not a static class, but one with it defined as a field, there would be a few more things you could see as a part of it. Especially within the refactoring, it would be simpler, but it has different visbility downstream.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What do you mean?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"If it wasn't all individual methods, if it was encapsulated in a class, it's much easier to remove it, because you can just delete that one variable and just clean up the appropriate logic. It is a different visibility to knowing that an entire object was doing that forceaccess, so when you're looking at the tests you can look for ones that are instantiating the object with the specific code instead. Maybe it's not anything different int he tooling per se, but it change the way you look at it and understand the impact of your changes.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You used change signature refactoring and the global git view. Why did you choose to use those particular tools?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I chose to use the change signature because it was easier instead of going through everything and change everything. The git diff was because I knew I broke something and I needed to find out what. I broke something not directly related to the refactoring, but as part of the changes I did as part of the change to the logic. Using the git view is hugely beneficial [for that].","Reflection
Efficient (""it was easier instead of going through everything”)
",,0,0,0,0,1,"<0,0,0,0,1>",0,195-195,0,0,0,0,1,0,0,0,0,0,
"I: How did you find the usage of change signature, did it do what you wanted?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Not completely. I think if I'd played a little more I could have excluded part of the refactoring. I'd like to say I want to go ahead with the refactoring in this area and not in this area, because if I could exclude the tests I could better see the impact of what tests are actually broken. But you want to have the proper changes done inside the code.","Reflection
Not Satisfaction (""Not completely.”)",,0,0,1,0,0,"<0,0,1,0,0>",0,197-197,0,0,0,0,0,0,0,1,0,0,
I: Is that a functionality you know from eclipse?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"No, I never actually used the remove, I've only ever used it from an addition standpoint.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: In this task when you used the change signature tool, it did result in compile errors, how did you feel about that?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I'm fine with that because the compile errors were specifically around the actual logic that had to be modified. Whenever you're doing something like change signature...if you're adding a field it does nothing because it does nothing until you implement the logic, but when the field is removed, the logic does something, and it's not something that can be magically removed because it may actually have a major change to your entire project or codebase. So I'm fine with the compile errors when it's inside the body, and I actually would have wanted them for the tests so I could go look at what it meant for certain tests.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: That would have helped you navigate and retain the meaning of them?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yes, I didn't want to write them down on paper.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is there any of the changes you made that you're unsure if you got right.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"What tests were removed. None of the tests I removed were kind of necessarily wrong - but whether there should be more tests removed, or .. one of the tests I took out was passing, and shouldn't..might not be right as it should be passing.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Can you elaborate on why you choose to use the change signature tool on this task.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Seeing the preview and liking to playing with tools. For this one it made it a little easier, because it was able to update all the tests, because any that passed in false as well was updated. That means that there may be duplicate code, because one may pass with false and one with true, but it was able to kind of update the core of the tests as well as all the internal calls. For all the passthroughs.","Reflection
Efficient (“made it a little easier”)",,0,0,0,0,1,"<0,0,0,0,1>",0,207-207,0,0,0,0,1,0,0,0,0,0,
I: What if there had been other callers of the methods in this codebase. How would that have fit into your workflow.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I don't think that would have changed it much. As I was doing the refactoring I was looking at the specific call points, and so kind of going through and seeing if there is one calling the passhtorugh by false, but the good thing with a preview like that is that yuo can see the ones that are true as well, and can go inspect them because there's a reason force was being used there.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: I'd like to ask a little about alternatives for tooling. Are you aware of the inline method refactoring?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I think so. Yeah sounds familiar.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: It's about the opposite of the extract functionality: it takes a caller and replaces the call with the body.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I see, it's like the opposite of extract. I've heard of it but i don't think I've ever used it.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Did you know of it from before?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Not really.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Would you consider using it on any of the tasks if you knew about it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yes, I could have used it on this task... becase... no I wouldn't have used it on this one. I would have used it on T2 because it would have been a lot easier.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: If you had used it on the second task, what would you have expected it to do? It had the negation.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"It would need to create basically a temporary variable to hold on to the true false. That adds a whole bunch of complexity, but it would have had to do that and then return the negation. I'd expect that. It would be cleaner if it does a perfect reversal, but it is very specific to the boolean case.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: If it had done the reversal, would you have trusted it?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
No.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why not?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Code can become very complex. So if it did a perfect reversal, you might be doing something like returning early, you may be returning early at some point. In some cases, like if you have a loop with continue or break and you negate it, the meaning change.","Reflection
Not Trust(""No"")",,0,0,0,1,0,"<0,0,0,1,0>",0,223-223,0,0,0,0,0,0,0,0,1,0,
I: So would the method body in the second task be an example of what you're talking about?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Maybe. I need to see it again. [1:32:43],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yes, a little, because there's logic, but because of the logic it's ok because they could just be swapped, but it's is not always the case. There is a lot of complexity taht could be added that change how this behave. You may need to look at it before doing the swap.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: For these kind of tasks that you did now, how would you usually make ure that your changes is correct?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Automated or manual testing and checking use cases. Code inspection, if it's not a too big change, you can read the code and check the logic.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You also mentioned architecture and design.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yes but also this, understanding that this got reversed properly is also just part of the inspection. This happens during code reviews, like, yes the tests pass, but looking at it and checking if there's something we got backwards. You need the multiple steps of understanding whether something is good or bad.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: do you have any concrete examples of what could be bad even though the tests are passing.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It could be that you just don't have a test for it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: In general what impacts whether you trust these tools.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Having used it, seeing what happens. The more you use it and seeing success from it, the more you expect that.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: what is success in this case.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"When you don't have to go back and doing a whole bunch of fixes on what it did - like removing static in the first case. Those kinds of things are like, if it starts working and your verification steps are all successful for a while, you just start accepting. I'll never really distrust a rename, I just expect it to work and I've used it so many times. When you get into the different refactorings you may learn that there are certain cases it is good for and certain cases it is not, so you learn what your level of trust is based on experience.","Reflection
Trust",,0,0,0,1,0,"<0,0,0,1,0>",0,236-236,0,0,0,1,0,0,0,0,0,0,
I: Do you have any examples to make that statement more concrete.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Maybe not for refactoring tools, but, I work with customers all day, and there's the saying you trust it as far as you can throw it. In the start you don't know how much you can trust it. The more you can use something and understand what it's doing, the more you gain trust it. You start small, and as you start to trust it you grow it bigger, and I think that's a common pattern with software. It takes time until you know whether something will work better.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So for refactoring tools you'd trust the 'smaller' one more?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"right of the bat I'd trust the simpler one, like rename - because it is like a find and replace in a way right, just a bit smarter - it's easier to trust those ones, but it's not to say I wouldn't try the other ones and figure out my trust based on their utility. It also depends on how often you do it. If you use something only once or twice it is hard to build an understanding or trust for it, but if it is something you use daily or weekly it's something you can start to get a feeling for and understand your trust level for.","Reflection
Trust 
 Predictable (“ it is like a find and replace in a way right”)",,1,0,0,1,0,"<1,0,0,1,0>",0,240-240,1,0,0,1,0,0,0,0,0,0,
"I: and your point about different cases, something you will have some special cases of where it is good or bad to apply it, do you have any examples of that?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Even the change method signature I did, it is questionable whether it was a good or bad case to use it. You’re trying to remove a parameter, and now you may have had some impact you didn't know about throughout the system. Whereas adding a parameter is an awesome use case because you're adding the parameter, you can default it to something across the calls and there's normally a reason why you add it, is because there are certain call paths you want to change behavior, so it makes it easy to go and find that. There's a difference between adding and removing as well: it changes your belief in the world. When it's removing you had to come back to fix the logic. Adding doesn't break anything until you start using the parameters, or like, using it in your logic. With the removal you have to go do fixes straight away, which is more complex. The trust is impacted by how much work you must invest after the fact. Going back to your question of trusting something that would do the extraction with the negation and it work every time, then that's great, but you need to build up that confidence. If you need to go and change it all the time you would stop using it.","Reflection
Not Predictable (“you may have had some impact you didn't know about throughout the system.”) 
 Trust 
 Effective",,1,1,0,1,0,"<1,1,0,1,0>",0,242-242,0,1,0,1,0,1,0,0,0,0,
"I: I'll ask more about your definition of success here. In the change signature it broke the compiling state of the class, is that an example of not success.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"No - and I think that is a hard thing to describe, because that was success for what I was trying to do.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So that did not diminish your trust?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"That did not diminish my trust. That actually increases my trust. It didn't try to modify my logic. The body of your method has the logic that matters to the program that is going to run. It didn't try to do something magic that it wouldn't know how to do depending on what that change meant. Removing forceaccess, it could have also gone to the true one. It didn't know what to do, so it could it is better that it didn't do anything. Something that could have been thought about, in terms of diminishing belief in it, is What it did to the rest of the code, because now you don't know which was true or false.","Reflection
Trust 
 Predictable (""It didn't try to do something magic”)
 Not Predictable (“What it did to the rest of the code, because now you don't know which was true or false. “)",,1,0,0,1,0,"<1,0,0,1,0>",0,246-246,0,0,0,1,0,1,0,0,0,0,
"I: But from a language point of view that is correct, because it kept it compiling.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Right. Software is not a simple binary structure. It is a creative piece of work, and creative pieces of work does not have the same definition. So from a language structure, yes, but that doesn't apply a working application.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: Do you have any other examples from your previous work of things a refactoring tool did that either diminished your trust, or that were in a sense incorrect, but you were still happy about it.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"A lot of times when you're doing things like extracting superclasses, it gets interesting. What's good is that when you extract someting higher level, if it needs a variable you can pull it along very easily. So having that up-front information builds my trust in it. I'm seeing that impacts, and either cancelling going back and changing what I'm trying to do or deciding to move forward and go with the changes it actually puts in place.","Reflection
Trust 
 Predictable (“I'm seeing that impacts,”)",,1,0,0,1,0,"<1,0,0,1,0>",0,250-250,1,0,0,1,0,0,0,0,0,0,
[1:43:31],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Final comments/qs?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I think it was fun.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
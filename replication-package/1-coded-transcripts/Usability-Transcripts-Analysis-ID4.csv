01:00,,,Predictable (9),Effective (4),Satisfaction (7),Trust (6),Efficient (8),Vector: ,Invoke (3),Row Range, Predictable (6), Effective (3), Satisfaction (3), Trust (3), Efficient (3),Not Predictable (3),Not Effective (1),Not Satisfaction (4),Not Trust (3),Not Efficient (5),Refactorings
"tests have been written
 For the tasks I should assume that the unit tests are correct and if they're failing that means that they are failing because of the tests. 
 I: Yes this is like an existing project. Let's imagine that this is between releases.
 Ok so someone has already .. ok. 
 Ok, so start with a plan, change it at will.
 I: Yes, it's very free. I might stop you before you complete the task because I'm interested in how you 
 If you think, you'll probably finish this anyway. 
 I am ready to begin the first task.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
[03:50],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
T1.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Locate the relevant tests.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'll just search for the - I'll just find.. testIsAnyEmpty..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm just going to assume that what you're giving me is correct that there's not some trick and that they all exist.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ok I see. There's two different test files and we wanna create a single test - we wanna extract these methods and put them into this test file.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
That sounds pretty straightforward. The simplest thing to do is just to hope that you can copy-paste them all from one place to another and see what breaks. There might be some declarations that aren't there. And there might be some kind of tester thing that is initialized. I assume StringUtils is just one - and StringUtilsTrimEmpty - I'm not sure why there's a separate class for this but there is. And yeah this sounds really straightforward. It sounds like it's just a copy-paste job. I think one of the harder parts - I think it's going to be easy to copy over and get that to work than it is to clean up the remaining stuff because there might be certain variables or such which are - I have to identify which ones are the ones only for the tests I extracted which I assume need to be removed because otherwise they're just redundant doing nothing but hopefully the IDE should catch that and say you're not using this any more. Ok I think that sounds good. How does this approach sound?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Good.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ok last thing do I .. because there's annotations.. So if I just create the test file and import junit ..then all the imports should come as well.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ok so where should I put this? Is there a stub already or should I make it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: there's no stub,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Interesting. The tests are all here but they decided to just leave them in different files. So I'll just follow convention instead of adding a different file. Because if they are expecting that then I'll do that. New file..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Actually it may be easier.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Especially if we're extracting StringUtilsTrimEmptyTest.. oh well.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Something I would do is if the test is small enough is just to copy paste one and delete a bunch of it,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What do you mean by copy paste one?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
[07:39] I will start with one class one of the files as my reference. I'll make a clone of it remove - because there's four in here - remove all the other ones and I'll find the other ones and copy them in here. It might be easier for me to just use StringUtilsTest but I think there was a bunch of stuff in there that I .. I'll se which one to use. And I'm worrying I'm overthinking things but I'll just copy this one. StringUtilsTrimEmptyTest - ok we should come up with a name for this. For emptyAndBlankStrings. So how about I call it StringUtilsEmptyBlankTest - not the best name but we can change that later. it is important with names. Let's see StringUtilsTrimEmptyTest and StringUtilsEmptyBlankTest - let's not even get into that StringUtilsTest feels like it should encompass everything and I don't understand the actual reason why they have a StringUtilsTrimEmptyTest but I'm just going to call it StringUtilsEmptyBlankTest.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I know that a lot of times people are hesitant to change stuff that already works because they don't want to break things.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ok we don't need all the stuff down here. Done. Goodbye.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In the interest of time I'm not going to read this.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ok so my step 1 was combining step 2 was cleaning up and I forgot I have two different classes to combine from. So I'll just start copying as I got. TestIsEmpty - wait we have already done these. So I'll just remove them. Oh how convenient that this comment line is already here. It looks like the only thing that is - oh what's the IntelliJ hotkey for removing imports? I remember in Eclipse. It looks like the only thing I need to do here is to remove imports because it looks like the only thing defined across classes is foo. Might need to update the documentation.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So that looks good right now. And then StringUtilsTest.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Where are we now. testIsAnyEmpty. Oh here it is. I'm going to copy now - testIsAnyEmpty .... how convenient that they are in this block together.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: so now you just cut them out?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah. I'm going to just separate these. That way I can at least know that that was the division.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is that doing something you're doing because you want to keep it in the final class or to help you think.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
To help me think. Actually I'm not sure if I want to keep it in the final class or not but for now it's just to help me think. That's why I only partially completed it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Back to here. I have removed it. No wait that is the wrong one that's already saved. Save let's see. Is there any, looks like all the imports are still the same looks like the variables are still the same the green lines are more about typos. Looks like there are some static pre-initialized things that will come up later well we'll see if I need them later. I just realized something I could have done in hindsight which is to - no wait I assume the tests were passing anyway.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: what was that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"In hindsight I should have ran the tests on both of them first to validate what the functionality was, but - because now I'm not seeing any errors, not any compilation errors, expected values. I'm just going to run this and see if it works. I assume the red is git [14:07] 
 Well this is Java and it should have compiled and it should have complained if there was something.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: you mention that you're not a power user of IntelliJ what do you usually work with?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It depends usually Eclipse. *lists keycombinations for Eclipse*,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Oh it's fast, hey I think that's good.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I think this works. I can't think of anything I've missed, this looks like a fairly straightforward approach.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Ok. Please tell me in your own words what kind of source code changes you did in order to solve the task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"What kind of source code changes? Method extraction, it's just simply moving methods from one place to another and cleaning up the previous classes to make sure that you're not leaving anything redundant behind. I guess technically I should run the other tests to make sure that they still run, but considering they are unit tests, each of them should be self contained. So code changes, literally just moving them around. No code changes, just copy-and-paste moving. And potentially looking for - like seeing if I missed anything but there weren't any.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Are there any changes you are unsure if you got right?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In general because I don't understand this fully I'm a little hesitant but considering all the tests are passing right now and I have a decent degree of confidence that it is working?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What do you mean by not understanding it fully?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I mean I haven't read everything. They are pretty simple tests I guess. It seems to simple.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Let's move on.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
T2: [17:15],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Locate the methods in StringUtils.java. Just checking if these are any of the ones we moved? This is weird I'm searching and it's not here.. Oh right! I'm looking in the StringUtilsTests and this is in the ..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"There is a command in IntelliJ to look for - ah that's it. [18:34] StringUtils that's the one then - what window am I in, this is just the tests. Here is StringUtils isAllEmpty here it is. Return negation of IsAnyNotEmpty - seems simple enough - and isAllBlank. There we go. So these methods that call other methods. And we ...remove methods isAnyNotBlank and isAnyNotEmpty - I'm just curious is there a reason why they didn't ask me to locate those methods first. It's been communicated to me that these methods are no longer necessary. Based on what I'm reading it's not like - this is what I am considering - if we remove these methods are we removing anything unintentionally like maybe something was - some methods call other methods so making sure nothing else was removed. I'm thinking right now, based on this, if I remove isAnyNotBlank and isAnyNotEmpty the biggest thing I need to worry about is if they are called in the tests but I have a feeling that is - oh wait what am I thinking - isAllBlank calls the negation of isAnyNotBlank - I see.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"They want to remove it and put all in here. The easiest thing I can think of doing is, if we want to just remove this from the API, we can just make them private methods, and that way we know that no one external calls them. That way because the emphasis is that it's confusing to use double negation maybe we do want to extract them to here but literally if I was asked for the simplest way to do this I was make them private and be done with it. But I'm not sure that goes against the spirit of this. I would ask for more clarification.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: In this case you should remove the method declarations.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
What I'm going to do since we have tests for this I'll look at the stringUtilsTest and look at isAllBlank.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: I'll remind you that you moved some tests so they might be in the other class.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ok so this is going to be in my new StringUtilsEmptyBlankTest.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"[22:13] The good news is if I remove this method, if anything goes wrong, it should break a lot of stuff in here, and that will be a good way to know. So what I'll do is, I'll run the tests, make sure it's passing, then the thing I'll do is remove it, and it'll break - we know it'll break -- then I'll fix it. Functionality should be preserved.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Consider they're just wrappers - the first thing I'll do is I'll copy. This is isAnyNotBlank and this is - wrong - isAnyNotBlank. Where did that method go..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I noticed I'm using find a lot because it's common across IDEs. What I normally do is I comment things out and leave them there until I have to remove them so I have a frame of reference.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why is that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"In case I ever need to refer to them after deleting them I don't want to undo it, if I need a reference point for something I got rid of.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: By reference point do you mean just for yourself?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah. It also makes it easier if I need to preserve something I don't want to delete it straight away. It's a bit of a hoarder mentality; I'll delete it later but I'll keep it around until I need to.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
ArrayUtils.isEmpty css return false,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Firstly I know that this is the negation of isAnyNotBlank,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"by the way, I want to check, is anyNotBlank used elsewhere? No, thank god.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you're checking if it's used elsewhere by searcing textually in this class?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes I know that there are certain things that could look for it but I guess I'm not as familiar as I thought. Analyze dependencies?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Here it's find usages.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ok! Looks like it's going to break a lot of stuff in testAnyNotBlank. Good to know. Well since we remove this we know it'll mess up. But that's what the tests are for. We'll fix and correct it. And I can read those tests while transition anyway.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
isAllBlank isAllEmpty,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
how is this used actually?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So we test isAllBlank and we test isAnyBlank. I guess if we remove it we don't really need those tests because that other methods is tested and everything should pass here so that's good to know.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I know that everything here is a negation of something else so what I can really do is just switch from return true to return false and return false to return true. Something that makes me wonder is that my math wasn't very good so I'm wondering if there's anything I'm forgetting so I know that just reverting things isn't necessarily the case let's see if ArrayUtils is empty return true - that seemes straightforward. And for each one run isNotBlank if it is not blank return false. Yeah that makes sense actually as soon as you find one return true so that means that you have to go through the entire thing to return false. Oh wait yeah because sorry it's a similar thing because as soon as you find one that is blank you know it is going to be false. it no longer fills your case. Similarly other way around. This isn't that complicated. And the last one is return true because it passes everything.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Did I revert this one yet? What I'm doing is I'm looking more into the code. I'm relying a lot on shortcuts I'm just going to look at the code and assume it's gospel as opposed to sitting back and writing the methods from scratch. That's probably more useful to understand the spirit behind it. At this point I just realised, I'm not understanding, I’m just flipping switches. Yes return false return true. Ok there's that.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm going to go back to here. They said that there was the class - is anyNotBlank we already know where this is used findUsages we know it's used here. I believe that because we are deleting this we should be able to just delete that test and the other tests should just pass. Teachnically I could just - I could just keep this and not remove that test yet. Where was it testIsAnyNotBlank. Ok. I'm just going to run it and see if this works. The other reasons I'm doing this is that if I notice there's something horribly wrong with my approach I'd rather know now rather than later.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: By 'doing this' do you mean running the tests?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes because I realise I only half completed the task but since I'm approaching them in the same way I'm running it halfway through because I don't want to finish the task and find out that they don't work and then have wasted a lot of time.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Everything passed.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Let's get back to the other one then. So that was blank and this is empty. Did I have another window open for the structure. IsBlank isAnyNotEmpty is the one i looked at earlier. By the way it is kind of confusing is-any-not-empty Honestly yeah why do people use it if you wanna use this why don't you just run the negation of that why have a separate method for it? I guess you're wrapping it anyway so it doesn't really matter. So I've decided to abandon my hoarding ways and just delete ahead of time.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: How come?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm not sure honestly I kind of did that instinctually. In hindsight it's probably because my first approach worked well and I feel comfortable doing that now. But this is given in hindsight so I know it's not reliable. isAll - is it isAllEmpty? Yes.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I also just realised I [comment] this one. Looks like my approach was pretty straightforward just revert everything. And we go here and because the approach worked so well here - and this is actually very easy now because my handy code editor started vomiting,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What do you mean by vomiting?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
All the error messages,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So what did that tell you?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
That something went wrong. One second why is StringUtils .. oh it hadn't updated. So I've been working a long time in non-compiled languages so the fact that I removed this it mean it updated pretty quickly to be like I cannot find the reference to this because it's a compiled language I can rely on the compiler as a nice I guess safety vaulve. I had already searched I knew it was used by only one other that's why I didn't keep it around.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I had kind of presearched so I knew it was only used by one thing that's why I didn't keep it around.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So the error messages are like ..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The compiler complaining I'm using that as a visual bag. Since I know it is about method removal the compiler will complain when the method is not being used so I can just go there when the method has been removed. I'm going to run the tests again just in case.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So when the compiler gives you the errors it sounds like that also helps you think rather than that being the final result so to speak.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I use a lot of different data points. But yes having the compiler complain is nice to me. Well I don't like having it complain but it's useful feedback.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Looks like it worked. I feel like I'm done: I removed it from the API so we don't need to test it any more I'm not using anything in the tests. And the tests have been updated. I guess technically what I should have done is look in StringUtils - I should have looked ahead of time - that by removing that method is there any imports or global variable declarations that are no longer used. And it looks like - no that's a static method so it could be used elswhere - and no - the methods are still there I literally just copy-pasted them over; I'm overthinking. Yeah I think it's done.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Can you explain in your own words the source code changes you did in order to solve this task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Let's see. I removed - moved functionality from one method to another and I slightly modified it to fit the new parameters and I removed the old method and any usages. And I ran the tests to ensure that the functionality was preserved. And I was fairly confident about this despite on record talking about the unconfidence because the tests are passing. And because the code itself looks very simple. It's literally just a negation of a wrapped function and now we unwrapped a function. So I guess another way to put it is I'm unwrapping a function moving it somewhere else and negating it; I'm just inverting a wrapped function.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You were reading it as well..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes I had to make sure that it was just a simple case of inverting the signs inside the code 'cause I know ahead of time you can do it with the final result but within - I guess I'm contradicting myself because you should just be able to invert them ..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you know of any tools that could have automated the changes you did?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
No but I'm also not a power user?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Did you do any repetitive code changes during the task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah it was pratically the same: copy-pasting deleting and flipping the return values.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: If you had a tool that could automate that would you trust it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm a self-admitted ludite someone who fears technology - ok that's a bit of an exhaggeration but for me it's like if I knew this tool existed and I'd used it enough.. I wouldn't trust the tool to work just because I was given a tool I'd have to see it work enough times before I trust it. But I always verify because I know that tools can be faul.,"Reflection
Trust",,0,0,0,1,0,"<0,0,0,1,0>",0,106-106,0,0,0,1,0,0,0,0,0,0,
I: So you'd just need to use it so you'd trust it in order to use it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If someone told me to use it I'd try it and the first few times I'd be slow and check the output each time but given enough time I'd start trusting it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is there any parts of the code changes you're unsure if you got right?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Just the signs because I'm worried I missed something. The return values I'm worried I left one by mistake but I'm pretty confident about them. That's the part I was most paranoid about making sure that the logic was still the same.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you were reading the names of the other functions to make sure,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
yeah just making sure it was doing what I thought it was doing.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
T3[38:50],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm trying to make sure I understand this correctly: There's an API for reading and editing fields and there's an argument that is called forceAccess and you check if forceAccess is true do some logic else do other logic. But right now we're like forceAccess should always be false. Again the lazy way - or the hacky way - the first thing you do as soon as you enter the argument you set it to false. But I guess the problem with that is that people will see the API and say why is this not working. I would like to read the methods first.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
This is a new class FieldUtils. Let's open the tests that's probably somewhere. reading: Locate the code and test - oh so this is the entire file! Ok let's see. forceAccess is a parameter under getField let's see where else. Wait how many methods are in here. ForceAccess is a boolean. Looking to see what else would use it. I'm assuming anything with a boolean in here is using forceaccess. Let's look at the tests real quick. So this probably seems like the most complicated of them all. There is testgetfield. Fieldutilstestgetfield. Which methods had the forceaccess? There's no default parameter right? It's not like if you don't fill it in.. no this is java you have to fill it in. If you want to set default parameter the last time I worked with java if you want to set a default parameter you just write a wrapperfunction called getfield and like prepopulate the default function. Like this one. Looks like there's already some default stuff. Yeah sorry a lazy approach is just to make the other one private so you can only use this one but I assume we don't want to do it that way.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You don't want to keep that kind of code quality.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
That's the lazy way. Now what we could do then.. So what's happening is that it's kind of similar to the last task in that that we're moving this in here and then removing all references to the forceaccess parameter being used. The way I think about approaching this now - by the way the previous task has kind of primed me for this - is that I would look for how getfield is being used - this particular getfield with this particular signature with the forceaccess because I already know there are usages of the default one - and I'll probably remove any usages where you set this to true because it looks like the default one is being used in the tests and I'm just going to validate that now. One usage.. line 59.. it's also used in readField .. this has gotten slightly more complicated.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Because what's going to happen is if I change something - unlike the previous task there were no internal I guess dependencies. There was nothing else in the same file calling it it was just the tests. Luckily one thing that will be helpful is that the compiler will complain when we remove this because it'll be like we're using this. But what will happen is that one approach I can do is to change that then find the broken stuff and fix it later the other thing I can do is what I'm doing right now which is to look ahead of the time to see what will break. Which personally I prefer.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: How come?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Because I like to at least know what I'm getting into before [starting]. It depends if I was really rushed I'd probably just start changing things but I feel - right now especially because I know that I have over an hour left - I am slowing down a little bit.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What do you mean by getting yourself into what are you considering then?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If I change this - I guess how daunting it is - is it going to be an easy change or a hard change; like I want to estimate ahead of time an estimate. It's like if my friends asked me to sign up for whitewater rafting I'd want to look into what that entails ahead of time instead of being like yeah let's go and then go oh no.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So what kind of things are you looking for here?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It's more involved that the last one because there's more in here. It's more potential for it to not behave as intented. That's really it. That was getfield readfield rightfield. It looks like though maybe I'm looking in the wrong place but it looks like we're just trying to find all the places that force-boolean is used. I know for a fact that the only place it's going to be called final boolean is in the method signature so I'll just search where it is.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: There's matches on the side there.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And we have 7 matches so it looks like it's going to be 7 places.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
There's two ways I could approach this: one way is to find the root-methods that are referenced by other methods start changing those first and then fix the other methods that are broken accordingly. The other way is to immediately go to the other methods just remove all the one that use the boolean and then go in there and finally fix up the last one. I'm not sure what approach is better honestly; one involves a lot more red lines than the other.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is that a good or a bad thing?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I am not sure. I talked earlier about how I do rely on the compiler. I would say that the easiest one is probably to start removing from the signatures everywhere especially since there are some pretty simple ones here. So what will happen is that because the default wrappers are in there it shouldn't break them it should still just work. So I'm going to start by - and I know that there will be some tests that use this so I'll fix that ahead of time. Ok so what I'll do. [49:11],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I am going to start by removing the field from all the method signatures and remove all the corresponding references to it and then fixing the more core functionality but as soon as I remove this I'll also fix the tests ahead of time. And to me this is a decent approach because there is already the default and the default parameter is false. I would say it would be more compllicated if the default parameter was true. One thing to also note ahead of time is that in here in the tests what's going to happen is.. Something is on my mind something will happen.. I'm not sure it's my gut feeling that something is missing oh right I haven't run the tests yet. I should do that first. Especially based on my current position the tests don't always pass.. But this is an open-source code base so I guess it makes sense to be confident ... Ok it's passing right now.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So let's get back to what the appoach. I'm just going to start by deleting the ...changing how we are defining the methods. I'm going to start with ... I feel like I am taking to long to deliberate where to start. This is not just for the experiment I can have a bit of inertia and once I commit to something.. but I haven't actually committed to something yet just hovering around. It's like this whitewater rafting course and I'm just like should I pay yet and I'm kind of like saving it for the last minute but this is actually committing. So let's see this is getField.. I've decided that I'm going to go with the approach that uses the red lines and start by changing this one because it is going to provide me with a visual reminder of where to jump. So getField - i'm just going to find usages again. Oh right ... I can change the signature using this tool can't I?,,"
 Invoke (Change Signature)",0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Change Signature
I'll be honest I've never used this. I guess I've used something similar in Eclipse. Remember I said I've self-confessed ludite tendencies like because I don't know the tool I might actually just - oh there's a preview. What happens if I just remove this?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You can remove it through the minus sign here.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
So what happens if I remove this? The problem is that it's already defined - ah of course we already have oh by the way I'll admit straight up I'm biased to look at this tool because I'm self-aware of being in a study of refactoring tools.,"Invocation
Predictable
 (“what happens if I remove this? The problem is that it's already defined“)",,1,0,0,0,0,"<1,0,0,0,0>",0,135-140,1,0,0,0,0,0,0,0,0,0,
I: So you wouldn't normally have looked at it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I might have if a co-worker had shown it to me. I think the thing with IDEs the reason I do some of this stuff in Eclipse is because I was shown some of these things when I was an intern. The fact that I've never had anyone sit me down and and say - I guess I've never devoted time at work that I should sit down and learn my IDE. It's mostly just let's get this done. I guess I've just used an approach that works.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Anyway. I feel like what's going to happen is what I'd do is just delete this method now then I know that some times with certain IDEs I am not sure if I remove a method it might complain somewhere else and it might not let me refactor if there already is compile issues.,"Invocation
Not Effective 
 (“it might not let me refactor”)",,0,1,0,0,0,"<0,1,0,0,0>",0,,0,0,0,0,0,0,1,0,0,0,
I: So what was you original plan you want to remove..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
What I'll do is I'll just remove this instead of running refactor I'll just remove it and just look myself. I guess I just trust what I can see.,"Invocation
Not Trust",,0,0,0,1,0,"<0,0,0,1,0>",0,,0,0,0,0,0,0,0,0,1,0,
I: Right. But you were considering for a moment to remove the overloaded the default method and then using the refactoring tool right?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes I did consider that but then I thought it might be problematic because sometimes I have had experiences like you do this and then you try to do something else and then it's like you can't do this because it's currently broken. [55:36],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I can just undo that I guess.,,Invoke (Change Signature),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Change Signature
parameter forceaccess is used in methodbody. Oh it's saying it's used somewhere - wait - what's that trying to say? Oh it's saying it's used - but that's fine; I'm going to do this and it's going to complain and I'm ok with that. Because I realise that there's no way to do this without something complaining. I feel like it's not going to be able to automatically remove it; besides there are some logic changes too.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Continue.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Alright!,"Invocation
Effective",,0,1,0,0,0,"<0,1,0,0,0>",0,146-152,0,1,0,0,0,0,0,0,0,0,
As I mentioned there's some red stuff here. That's fine. If forceaccess set accessible true else continue. It looks like we don't actually need this which means the else is always going to be true. so the question is what does the continue do? The continue will just go back to the beginning of the forloop. I was just looking to see if I actually needed to even have this if-statement up here but it sounds fine. I think that this should be ok because what's happening is if this boolean is false we want to just continue anyway otherwise we want to just return the field. Sure that should work. Ok so now I'm surprised - I'm kinda shocked that there's not more red in here because did I automatically remove it already?,"Invocation
Not Predictable 
 (“surprised” ..”did I automatically remove it already?”)",,1,0,0,0,0,"<1,0,0,0,0>",0,,0,0,0,0,0,1,0,0,0,0,
I: What do you think the tool did?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Oh it probably already renamed everything that was using this. Ugh.,"Invocation
Not Satisfaction",,0,0,1,0,0,"<0,0,1,0,0>",0,,0,0,0,0,0,0,0,1,0,0,
I've just realized that I think one of the reasons I'm hesitant to use tools is because I don't know the full impact. If I were to look at a source control diff right now I would assume that we have some usages. There's going to be some very redundant test cases right now because they've probably been automatically renamed to use the default parameter right now. So if I were to look for getField in here ...,"Invocation
Not Predictable
 (“I don't know the full impact”)",,1,0,0,0,0,"<1,0,0,0,0>",0,,0,0,0,0,0,1,0,0,0,0,
what'll happen is that those test cases are probably going to break.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
If I hadn't used a refactoring tool and I would have just seen the red lines and known that this is exactly what I need to remove. What I'll do now is that I guess there's like a git diff thing I can use in here.,"Invocation
Not Efficient
 (“If I hadn't used a refactoring tool and I would have just seen the red lines and known that this is exactly what I need to remove.”)",,0,0,0,0,1,"<0,0,0,0,1>",0,,0,0,0,0,0,0,0,0,0,1,
I: You can go to - are you used to using git in the terminal?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I usually use git in some visualizer.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: There is a view for it here but I'm not sure where. Here?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I want to see git diff effectively.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Compare with same repository version is probably - or show current revision.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So what are you using this to figure out?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I just want to figure out what was changed.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So what the tool actually did?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah. Because look at all these things that had true in them which are now removed. I have a strong hunch that this test is now going to fail horribly because it assumed true but it's not going to test for that properly. I'm actually fairly confident that I should be removing this because - oh because literally the name is testgetFieldforceAccess. Everything else in yellow I'm just realising - I just think - why is it yellow?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: it's warnings,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
testgetFieldforceAccess I'll just remove it,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So in this case you used git instead of the compile errors?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah so I guess my previous goto for this kind of thing would be to know that this is what I need to remove because the compiler is complaining but because this kind of tool automatically did a lot more for me it kind of disrupted my flow. This was because it was the first time I was doing this. But this time you know what .. I'm going to be frank and say the next thing I'll do is to go back to my old approach. Because this I guess because of the nature of the task - I guess it's all about control and I feel I am out of control when things happen automagically.,"Invocation
Effective
 (“this kind of tool automatically did a lot more for me”)
 Not Efficient 
 (“disrupted my flow”)
 Not Satisfaction
 (“I feel I am out of control”)",,0,1,1,0,1,"<0,1,1,0,1>",0,165-165,0,1,0,0,0,0,0,1,0,1,
It's like for long time i resisted using ducktype languages because I didn't like that you didn't have to explicitly say what things were.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Was it different for you that it was in tests? 'Cause I don't think you checked this for the main file?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I did not check it in the main file. I should check it in the main file. But I know that in the main file if I removed it it should be ok because when I looked at it earlier for getField - because I pre-looked - I don't think I found anywhere in the code where it was hardcoded. It's always like I'll just take this parameter and pass it on. Because right now the big thing is if you have somewhere that automatically populates it with true instead of passing the parameter that's where it would be less useful. Actually thinking about that now I really think I do want to stick to my old approach. Because now instead I'm just getting this here which just says that this is redundant it's not used. [1:03:33],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ok so why is this failing. Probably because we have.. yeah it's because it's overloaded. [1:04:03],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
We now have two methods with the same method signature of course it is going to complain.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Oh it looks like intelliJ shows documentation warnings too. I'm just going to change that as well; I know it says you don't need to but I will.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ok let's go back. I changed one of the things already. Final boolean. Now I'm looking for boolean forceaccess. getDeclaredField. One thing I'm going to do - I'm going to change this; by changing this it tells me where the error is in here; I know that this - if forceAccess is true else return null so I know we don't need this any more this is never going to be true so this should only ah should only ever return null. Is that the case? We're only ever calling this with forceAccess ever set to false so it is the same as if the if check did not exist and only the else ever exist. And we're going to get that same complain; get declared field.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
By the way I just realised I have not rerun the tests unlike the first time I talked about validating my apporoach and I think it's because I got a little cocky. But it looks like we have had something change here so I'm just going to look at that.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: How are you navigating through the code now?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I am just looking at the red lines. [1:06:03],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
...That's all I don't want to change this. Down here. Right because of this...,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Ok so I've done a bunch of changes here I'm just going to rerun the tests. Technically I was supposed to run that after the first time to see if my appraoch worked.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: what do you mean by after the first time? After one change?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah. Here we go testGetDeclaredFieldForceAccess. This is the one with all the trues. For some reason it's giving me compilation errors. True true null true true. Yep these are all failed looks like they don't want to test these any more because we have a bunch of tests that cover it. And over here testWriteNameFieldForceAccess forceAccess true true true true. Yeah looks like we can just nuke this as well.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It was more like I would have run it to make sure my approach worked first.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What did you consider one thing here because you made a lot of different changes?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In this particular case yes because I had to keep going and keep going and kind of ended up like sprawling about. I guess it was more like.. so the first time I did it it was this assumption that because they were separate if I took an approach to the first half and reapplied to the second half I wanted to make sure that my approach worked and I think I was trying to replicate this here. But I wonder if I instinctively knew that there was going to be an issue. Because .. this test here is failing right now so I probably missed someting. but this is good feedback. ReadField. I think this is the one I haven't actually changed yet because it's counting as compilation error. It looks like it's going to.. what happens here. ReadField.. if... so what happens if it's false? So really it just returns field.getTarget. So this is just a wrapper for field.getTrget. And it's a validation. We don't care if the field is accessible. Wait do we care? This is always going to be false. So this if-condition will never validate to true. ....,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Alright. Why is there still red in here. Two errors found - ah here they are. well we no longer actually need this forceaccess. We don't need it in the documentation any more. And we just need to remove the overloaded method because now we have two methods with the same signature which is no good in Java and the last thing here is - oh this one by default was always called with false. Oh that's weird I wonder why they called it explicitly with declared false. Oh by above I think they mean the.. I wonder why they didn't use the default parameter there.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Right. So this entire test case just fails. But that's fine because everything here is expected to be true. Ok. Looks like everything is cleaned up. And one more for writeField. So what I'm going to do is I'm just going to clean up this up and then run the tests. I feel like because how entrenched it is - let's go back to here. So again it's the same because this is always going to be false. [1:13:13],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
[1:13:29] This is a method that's conflicting with this one again the exact same thing happened it was just running the wrapped version. I just realised something - I have been deleting things - but I just realised - I don't know what happened to my mindset I guess I just got hasty - but I just realised there was actually some preable here with some - these weren't just simply calling wrapped classes there were actually some logic in here that I might actually not have preserved. I feel like I need to go back here because - yeah there is some validation in here. It's not as simple as calling writefield with false we actually have a lot of validation here.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What made you realise that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I don't know why but I did just realise it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So what are you doing now?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
[1:14:15] I’m just going to undo a few things. But I'll also backtrack to the diff and just make sure that I actually remove - I'm going to read this class now. writeFiel field name while this has a field - OH now I realise what I'm doing here. I was deleting the wrong thing. This is what I was meant to delete. I just got confused because I saw some red but in actual fact that was just a case where it called false by default. I'm just going to change this real quick and then look at the diff now because I want things to get to a more consistent state. I think this was confusing in here. I had made an assumption that any time we were calling the false case the method invocation would not have false explicitly set but there was a particular case where it did and I think that threw me off thinking something had gone wrong but I think that if I check the diff it's actually going to be that everything I removed was correct.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you thought you made a mistake but you hadn't.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes I mistakenly thought I made a mistake. But I'm going to double check now. I don't know why they didn't just type return field here but ok. Maybe because it's OS code? Here that's what I changed. Here - yeah they just return getDeclaredField. Yay consistency please be more consistent. Same thing here. Same thing here. Like this was an example that - yeah it looks like I'm actually correct I didn't make a mistake. I got confused somewhere and I panicked a little but I didn't actually do anything weird.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you misinterpreted ..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I misinterepreted a change because I kinda went into autopilot and I started changing something else and I was like wait that's not what I'm actually supposed to be doing.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Oh it looks like - this forceaccess flag is actually gone. And if I look at the methods none of them require booleans as parameters which was an assumption I made and I very quickly just verify and back to here - we have a bunch of stuff that is broken.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Back to the tests?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah. I know that I need to remove this because it is all about testing that the broken is true. Because this is a well-written unit test - there is a lot of not-well-written unit tests that aren't actually unit tests - this test actually is very helpful because I know that I can safely remove it without losing functionality. That said I am going to do a diff but I'll run a test first.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Oh we have some - oh they're static final. They could be used elsewhere. I don't think that is part of the scope of this but I don't think this was broken before I used this.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What do you mean by broken? The warning?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes I'm pretty sure it wasn't ... You know it is part of refactoring you do want to take out stuff that isn't useful. I see this and I'm like why is this being used. But maybe it's being used somewhere and I'm just not aware of it. Where is it used actually? Only within the test. But technically anything within the same package could actually use it. I'm just going to double check when I look through the diff if any of them uses IO or D0. I think this one moreso than the other one made me look at the diff 'cause I haven't looked at it before but I think it's just because it is slightly more complicated. And because I tried doing something I didn't and I ended up being ..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Oh interesting it looks like the warning wasn't up here before so I'm going to assume one of these testclasses actually used it. What was the name of it? I0. Yeah. Well I'm actually going to remove these because they are reduntant they're not being used. In a production scenario I would run all the tests and they would break. But I'm also fairly certain that IntelliJ would have told me if someone else was using it. So let's go back up here. I don't think I've actually removed anything that's going to break. I've had to change documentation but it's because it was giving me compilation errors.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: That's ok.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm done.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What source code changes did you do in order to solve this task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
What I ended up doing was I changed the method signature for various methods but it effectively ended up being the same.. it was similar to the previous task of I approached it slightly differently instead of copying - cutting it out putting it into another method deleting the old method and changing it what I did was I stayed in the existing method removed the method signature changed things up and then deleted the overridden method. The reason I did that was compared to the other task which was kind of an inversion thing because this had to do with overridden methods instead the names were the same to me it made more sense instead of actually lifting the code into somewhere else - the other way to do the previous would have been delete this one and rename the other one but because it had the same name I just decided it was simpler to keep everything here and delete the overridden one or the shorter argument - the same number of argument version.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you said you changed the parameters..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I changed the parameters went to the logic and removed it also updated other methods that used the same thing checked the logic to make sure confirm that it was just a nothing was ever set specifically. And in the case that it was set specifically those were different methods and those were always set to false. And by doing that I knew that it wouldn't change because it was the same as calling it with the default so I made sure no behavior was changed major behavior was preserved. Then I updated the tests and I saw the tests and just relied on the compilation errors and I just removed them because they were not testing those cases any more.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you know of any tools that could automate any of these changes?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Well there was this intelliJ one that sort of did it but then I guess it messed with how I approached the problem so I decided not to use it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So what happened there? Can you elaborate?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah what happened is once I changed it I realised I - I guess in tandem with other tools I realised that I didn't actually know what was changed elsewhere like in the tests for instance. I guess it could have shown me that the tests were broken - but for me at this point with this particular task I liked using the compiler to show me where the error were. So what happened was I realized that I didn't - because I also didn't understand the previous test well enough I didn't understand what was actually changed and I had to do an external diff to compare it. To me it was easier instead of doing that to just use the visual diff of the red and do that. And that's because I found it more intuitive or I guess .. more .. less .. less reliant on other tools because I guess the java compiler is such an ubiquitous thing and I am just leveraging that.,"Reflection
Not Predictable
 (“didn't actually know what was changed elsewhere”)
 Not Efficient
 (“To me it was easier instead of doing that to just use the visual diff of the red and do that.”)",,1,0,0,0,1,"<1,0,0,0,1>",0,210-219,0,0,0,0,0,1,0,0,0,1,
I: It took quite a long time and it seems the tool could have done some of those changes faster?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It might have that's a thing I'm not .. 'cause I did change it and remove it but I still found I had to do some of those things manually. Based on what I did the first time around I evaluated it and I thought it was not that much faster with that I was doing. And I figured that my familiarity with my current thing would have made me just switch back to it. Is it worth it for me to use this I guess untested tool now and I decided that I'd rather just finish it up faster. I think we can conclude people are set in their ways.,"Reflection
Not Efficient 
 (“it was not that much faster with that I was doing.”)
 Not Trust 
 (“untested tool”)",,0,0,0,1,1,"<0,0,0,1,1>",0,,0,0,0,0,0,0,0,0,1,1,
I guess what happened was I was confronted with something that made me uncomfortable and made not as sure as my current process and so I decided to revert back to it. What happened once I reverted to my process I found it more intuitive and I thought it ended up being faster than the other one. Because with the other one I would have kept checking kept looking over my shoulder the entire time.,"Reflection
Not Satisfaction
 (“made me uncomfortable”)
 Not Efficient
 (“I reverted to my process … I thought it ended up being faster than the other one”)
 Not Trust 
 (“I would have kept checking kept looking over my shoulder the entire time. “)",,0,0,1,1,1,"<0,0,1,1,1>",0,,0,0,0,0,0,0,0,1,1,1,
I: You would have kept looking over your shoulder.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I would have felt more than normal like I might have missed something.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is that because you don't trust the tool?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah a little bit. Yeah like when I used the tool I was like wait did change and I ended up having to look.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Did you use the preview window?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah - what exactly happens - because I thought I used it and I didn't really see much. It kept taking me out of it and I thought - I think having something .. I think having like an active - instead of jumping back into the code I was expecting to see a before and after and I didn't see a diff and maybe there was one but I didn't see it and I was expecting to see a diff.,"Reflection
Not Satisfaction 
 (“was expecting to see a before and after and I didn't see a diff”)",,0,0,1,0,0,"<0,0,1,0,0>",0,,0,0,0,0,0,0,0,1,0,0,
I: Do you know of any other tools you could have used?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
No.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: How would you normally have solved this kind of problem?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Pretty much like I just did.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: If you normally don't use a tool for it how do you organise your source code changes? How do you ensure that you changed all the things you need to do..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Relying on the test results. Relying on unit tests looking at the tests as well and the last for me when I work in teams I will rely on code reviews as well. I always just double check my approach like hey I changed this and then have my team review it but I know that doesn't always work when everyone is busy. But honestly it's just looking at diffs and testing.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So git diffs and unit tests?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah. I'll make sure I look through it look through the unit tests and see that they're welldefined. Usually it's a little more complicated and there are other changes too so I usually go through the test cases more thoroughly.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: And if you make some small mistake change some code you shouldn't have changed or similar then now I think you were backtracking with your undo option,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I was lucky in a position where I could do that. Otherwise I would have looked at my diff and restored it from there.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Right. For this task is there any of your changes you're unsure you got right?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
During the task during the changes yes! There's was that point where I thought I had accidentally not taken out the overridden thing but other than that - which I quickly reconciled by looking at the diff - now I'm fairly confident that it is fine. I guess the only thing I'm unsure about but I did go through the diff of the test and I looked at what was tested..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: There are some other refactoring tools that sort of match this and I'm curious how you feel about those. Why did you pick change signature?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
That seemed like the appropriate thing because that is what I was doing.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What about Inline Method?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It sounds familiar. Which tool is that one?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Inline method takes the method of a method declaration and replaces a call to a method with its body so it essentially expands it. So it's similar to what you did in the previous one.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I see. Honestly probably because I didn't really know that one. It looks familiar because I've seen it but I've never used it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You didn't know what it did?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
...know.. I've seen it but I didn't know what it did. But that sounds way more useful and I probably should have used that because that is actually expanding the call like paste in does. I think it depends for me the more automagical it gets the less I trust it. To me Rename is simple. I like Rename I can quickly Rename I can see what is Renamed et cetera.,"Reflection
Trust
 Efficient (“quickly”)
 Satisfaction (“like”)
 Predictable (“see what is Renamed”)",,1,0,1,1,1,"<1,0,1,1,1>",0,239-241,1,0,1,1,1,0,0,0,0,0,
I: What is simple with it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It is effectively a very specialized find-and-replace - I guess they all are. To me it just feels like it doesn't do anything - it doesn't feel super fancy. Like compared to this method signature one where it changed a lot of different places - maybe because I'm just more familiar with it but it just seems more - I guess it's because it's more similar to .. I'm not sure.. why do I ..,"Reflection
Predictable
 (“it doesn't feel super fancy. Like compared to this method signature one where it changed a lot of different places”)",,1,0,0,0,0,"<1,0,0,0,0>",0,,1,0,0,0,0,0,0,0,0,0,
I: I am curious about the way you perceive these as different for example rename and change signature.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I think one of the reasons I chose change signature i that it seems kind of similar to rename to me it updates this method everywhere else that uses the same signature. [1:33:12],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
As to the other thing Inline Method that sounds like much - that's effectively what I ended up doing if you're using some nested method you may just copy and replace with inline and delete the old one - that might have been slightly faster I don't know how much faster though. I haven't used it that much so if I was to use Inline Method I'll be like so let's see. So if we had a case where you'd call here like target.. no wait ReadField so if I did what is it refactoring,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What do you expect will happen now before you do it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Based on what you told me I am assuming that it will effectively copy and paste the text in here.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Would that preserve the behavior you think?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Of what?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Of this method.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
No if it is as simple as I thought it wouldn't because it'll say return but then it will be the first like of the method. But I guess I don't know what intelliJ ..,,Invoke (Inline Method),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Inline Method
Inline and remove the method inline all and keep the method inline this only and keep the method. So ah to me what happens is I feel like this .. I wonder maybe it's my personal experience but we're not really taught this particular terminology. Either that or I didn't pay attention in class. But to me it's like - for example when I was asked in the questionnaire about more formal refactoring I guess it's like when I was taught design patterns I was like what are these things and it sounded more daunting then I was shown it and I was like ah and now I can use design patterns because I've learned the vocabulary. But it's not something I would have done ahead of time. And I think these refactoring patterns because I'm sure people talk about them but I haven't learned them in a course in university and I'm sure that's probably why. But I'm not sure. When I'm seeing this I'm trying to infer what it means by inline all remove the method inline all keep the method inline this and keep the method. I'm assuming inline all remove the method means find everything that matches this type of inline and remove it inline all and remove the method it's straightforward it's going to remove the method that this is calling so it's going to remove readField and inline this means that I'm going to inline this particular occurrences. I have a feel that it's just going to replace everything and return the end of the same inline field but we'll see.,"Invocation
Predictable (describes what they each do)",,1,0,0,0,0,"<1,0,0,0,0>",0,250-258,1,0,0,0,0,0,0,0,0,0,
[1:36:20] What did I press? I just pressed undo by the way. Yeah inline keep the method there is no preview but.. Uh.. what did it call beforehand? field and target. Oh yeah looks like it worked quite well.,"Invocation
Effective (“worked quite well”)",,0,1,0,0,0,"<0,1,0,0,0>",0,,0,1,0,0,0,0,0,0,0,0,
I: So now you just undid?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah I just undid because I wanted to see what the difference was. This is literally just me playing around with it trying to see what it's doing.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you wanted to go back in order to go back in order to compare this with the result of yor refactoring.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah and obviously I want to see what this method does. yeah so it literally just replaced it. Huh. That is quite useful. That would have saved me a lot of time.,"Reflection
Efficient (“saved me a lot of time”)",,0,0,0,0,1,"<0,0,0,0,1>",0,,0,0,0,0,1,0,0,0,0,0,
I: Do you think you would have used that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes because I feel like inline now that I'm understanding it it looks simple enough that yeah I would have probably done that if I knew that this tool existed then yeah,"Reflection
Satisfaction",,0,0,1,0,0,"<0,0,1,0,0>",0,,0,0,1,0,0,0,0,0,0,0,
I: Would you have prefered that to the change signature one?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes. Because change signature changes things in a lot of different places whereas this changes one thing here.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Because you selected to just use it here. So would you select to use it on each invocation then?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I might try it like that first since I'm just starting to get comfortable with it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you talked about whether you trust the tool or not but what about predictability what does it mean to you that a tool is predictable or that you trust it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Trust from me comes from having worked with it and understand it. Predict is more like actually like earlier when the context menu came up with three different options I think that is pretty predictable because I was like I think it's going to do this when I press this. Like rename is really predictable because it's like I'm going to rename this and I think at least in Eclipse it says I'm going to rename it here here here and here. Predictable is nice because it lets you feel in control. When something is unpredictable you don't. What happened with that method signature maybe it was the way I used it but it ended up being unpredictable and I was like I don't know what's going on and that leads to lack of trust. Predictable means that it behaves in a way that I can I guess it doesn't violate any assumptions.,"Reflection
Trust
 Predictable",,1,0,0,1,0,"<1,0,0,1,0>",0,264-264,1,0,0,1,0,0,0,0,0,0,
I: What about correct whether a tool is correct or not?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Obviously I like if a tool is correct. But for me if a tool is predictable enough I can sacrifise a little correctness because if I know what it's doing I can correct it after.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What is an example of correctness you can sacrifice?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Like for example if that inline tool had replaced that particular text and kept the return at the top and I'd had to manually delete it I'd been fine with that because I'd have known that it just replaces everything from here and out it's like a glorified paste.,"Reflection
Satisfaction(""I'd been fine with that"") 
Predictable(""I'd have known that it just replaces everything from here and out"")",,1,0,1,0,0,"<1,0,1,0,0>",0,268-268,1,0,1,0,0,0,0,0,0,0,
I: But you'd need something to tell you it was wrong like,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The compiler would tell me it was wrong,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So if there wasn't a compiler error,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Oh yeah so that's a thing that's a good point if there wasn't a compiler error I would definitely be more worried about correctness.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So for example with the tests they did something you didn't want when you used change signature,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: But you didn't get any errors. Well you got it when you ran the tests.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
And I did the diff first and looked at it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
What was the question?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: I was askind about what you were willing to sacrifise and I was trying to understand the tradeoff,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm willing to sacrifise some correctness if I have other things that can help me like - if it's something that is very rote very repetitive and it's super fast I would be ok as long as I've other tools in place to show it's incorrectness I'd be like sure this is incorrect.,"Reflection
Efficient("" if it's something that is very rote very repetitive and it's super fast "")",,0,0,0,0,1,"<0,0,0,0,1>",0,279-279,0,0,0,0,1,0,0,0,0,0,
I: What did you consider repetitive in this task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In the end I just ended up going remove find the next spot see what it was deleting,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So finding removing,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah and removing the test as well?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: And how do you usually make sure that a program is correct after you refactor?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Running tests. And just going through the diff more carefully. Not even just unit tests if it's a UI I'll just do a dev test first,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: For the first one do you know any tools that could have helped you with that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Which one was the first?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: The one with the tests.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Oh just copying and removing? I think there's like I think you can extract method I think that's the term? I think I've used that in certain cases. But to me this was simple enough that I'd just copy paste it.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What if it had been more complicated?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I don't know having a tool would have been nice but I probably would have still just copy pasted it and see what broke.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So if you were to for whatever reason were to use a tool for it you mentioned extract method is that what you would have looked for?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah. Or maybe Move Method is the term? I'm not sure. Extract I think is the one. Or it could have been Move actually.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: what about extract class?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I think I've heard this term but it's more .. I'm not sure how I'd even use it. I think having a tutorial would be useful. I've been working with duck typed languages recently where my IDE is more of a text editor with corrections than anything else.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: so for the first one I was curious how would you make sure that you weren't .. say if you forgot to remove them from the class there wouldn't be compile errors how would you notice that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I also look at diffs so I would notice that.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
fin [1:45:29],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
Sounds good.,,,Predictable (6),Effective (10),Satisfaction (4),Trust (2),Efficient (5),Vector: ,Invoke (12),Row Range, Predictable (3), Effective (4), Satisfaction (1), Trust (2), Efficient (2),Not Predictable (3),Not Effective (6),Not Satisfaction (3),Not Trust (0),Not Efficient (3),Refactorings
So I can just start poking around?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Yep!,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Test folder. Tests mixed in here. Those are just tests. Ok, these are all tests.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Is this actually just a copy of apache commons or something? Or is it built from scratch?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: are you familiar with Apache Commons?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"It's a long time since I used it. We used it on the first product I worked on. The we replaced it with Guava; we didn't want to mix them up. I've only really used some basic, no extensive use.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Ever looked at their code before?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"No. 
 Ok, it's a helper..",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Obviously I'm not going to read through all this code to start. That would take a million years. But it's Apache Commons style, there's a bunch of static methods to do various things that people like doing. These tests are very confusingly organized, but they have tests.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: what's confusing about them?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
That there is a folder in the tests called test. That confused me. That's just supposed to be called text.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Cool. Thanks for finding that.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
some code duplicated between tests and ..,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: That's probably my bad. It should not impact your work.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I'm not going to read all the code here, so let me just start on the first task and see what is needed for that.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So I guess we'll just.. ok, I'll close all these. I don't use a mac, so I'm bad at key shortcuts.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
i Do you use intellij?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I do now, for scala, but I used to use eclipse.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
T1,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So, stringutils test and stringutilstrimemptytest",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So I want to create a new test class, to house these, and then move this test over. So I'll have a look at the tests that exist to see if they're self-contained or use a bunch of private methods that are in these classes.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: why do you check that,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"If the tests are self-contained you just copy the tests to a new file, and that's it. But if the tests have been written in a way that use all these private methods, then we need to decide do we duplicate these into the new test class; would it be worth it to extract some sort of utility so they're shared amongst a couple different test classes, if they're super simple it's probably fine to duplicate them; if there is some complexity there so they might change, then it's probably better to extract to common usage. And also I just kind of want to see what the test is doing.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"There is the stringutilstrimemptytest. Ok, we're looking for the empty and blank related methods. that's pretty clear here. *reading* nice divider line. They are the four we care about here, and I can see that they are entirely self-contained, so I'm happy just copying them out of here and putting them into the new file. So for the StringUtilsTrimEmptyTest, *reading*",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Again, these are looking pretty simple, just invoking SUtis, they have their assertions, so as far as I'm concerned there's really nothing interesting to do here. I really just want to I'm just going to create a new file, identify all the tests that are here and copy them to the new file. That's it. So, I'll go ahead and do that.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So make a new java class. Did it say a name it wanted for it, didn't look like it, stringutilsemptyandblank, Yes sure (git)",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Take these, four, start on top, grab those, paste them in there, yep, want to import all that stuff, oh, they have a bunch of constants. Ok, great constant, that's fine, I don't feel like that needs to be shared, it's a test input",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you're just copying it over?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yep. This could be shared, but it doesn't provide any value to be shared. It can just be duplicated. Like, if someone is looking at this test, and they're saying I don't want to use foo, I want to use bar, they can feel free to do that to this test, and if [10:30] they want to do it to all they can do it to all, but there is no need to make that change anything in any other test. There is no value to that as far as I am concerned.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Can you just clarify what you mean by shared?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Currently this constant is shared amongst these test methods, and it's also duplicated now; I've duplicated it between the TEMPTYtest and my ENBLANKTEst, and so, if I was Azella, who says no code should ever be duplicated, and I notice I have bunch of -- like in here, there is a bunch of SUTIL-related tests, there's seven of them and I just created an eight, and so you could argue that, these tests are testing stringutils, there's probably a lot of common elements to them, and I wouldn't be surprised if, you know, we look at this this, there's static ... defines a bunch of test inputs, and so these test inputs may be useful to the other stringutil-tests, and so if there is some complexity behind it, it would make sense to not duplicate that complexity, but simply to extract it to a common location so all the SUTIL test classes could use it and benefit from it without having to copy the code around. It's especially important if that code will change, you don't want to change it ten times. But in this case, when it's literally just a constant, three letter string constant, there's no complexity here, it's just pulled out so you don't need to have string literals in the test. As far as I am concerned, if these tests were written with the foo-string literal was just embedded in these, I wouldn't have a problem with it, so having the constant duplicated makes no difference to me. So AFIK it's fine to just copy.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So that's simple, we've removed them from this test, we'll get rid of that separator, it's not separating anything, Oh, I guess they have a convention of docing their tests, I'll do something like that over here, utint-tests for stringutils for ..",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So now to stringutils-test, we had some other stuff here. And now I'm seeing in the StringUtilsTrimEmptyTest there is this more complex set of constants that gets statically initialised. If I see that these are used then I might extract them since I don't want to duplicate this kind of computation in a bunch of different places. If someone decides they want to change the way the tests work and they only update the one in stringutilstest, it wont be that great. Or, I've noticed that these are actually packageprivate, so we might actually just use these from StringUtilsTest, and some of the others that are private we may just make packageprivate and use them in the new test. SO the SUTilstest class could kind of serve as the common location where the other, more specialist sutilstestclasses get information from.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Let's see, we have isAnyEmpty, this divider so I expect that all the tests I care about is in here. *Counts* 8..down to uppercase,.. that's all the tests I care about. And these are all using literals, so there's nothing to deal with here, so I'm just going to copy these tests, and plop them in here.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"And so I notice that we have some tests using literals, and some are using static, and so I don't think this guy is all too useful, so I'm just going to inline that. I don't know the keyboard shortcuts, so I'm just going to .. .Refactor.. Yep. And we have some little silliness here, we don't need to concatenate those strings, we can just .. Oh and I see they're actually using this thing that I mentioned earlier, where they're using stringutils as a testbed. So these were copied from the trimempty test and it was referencing things from stringutilstest, so they're already doing the thing I mentioned earlier. Ok, so these are done, I'll run this test, make sure I didn't somehow break everything.",,Invoke (Inline Constant),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Inline Constant
I: Is there any other changes you made that you could imagine could have broken things?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"No. I don't think so. I did edit these two other files, but all I did was removing test methods, so the only thing that could break there is if one of the test methods were referring other test methods. I'd be very surprised if that happened, but I guess I can run the other file. Why is that .. oh, they were the only boolean assertions, so I guess we can remove those.. I'm used to my Eclipse deleting [unused imports].",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I've actually been noticing that in the scala code I've been working on recently, there's always a bunch of unused imports, even in the tests, I never think to look at the imports half the time.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Ok, so I deleted the imports here, it told me they weren't used, but better rerun the tests to make sure it's no super secret thing the IDE isn't telling me about.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Looks good. Probably just run the whole test suite. Should be pretty fast tests, since they're not, you know, hitting the network or anything. Ok, all the tests pass, I pulled out my new test class, I'm just going to commit these in case we touch these files again.",,"run tests 
 git commit",0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I believe I am done doing this.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What did you do in order to solve this task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I located the pieces of code that I wanted to move somewhere else; I inspected them to see if they had any dependencies, I found that they did not have any real dependencies, so I created a new test class to house them, I simply cut and paste the code from one file to another file;",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I noticed that I was now was of following two different patterns, where one set of tests were using literals and one set of tests were using constant. I prefer my code to be consistent, so I inlined that constant, so that all the tests kind of looked the same;",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I didn't even look at the content of these, so for all I knew I just duplicated a bunch of tests in this file. Like, I didn't even look at what these assertions were doing. So it could have been the case that this assertions, isBlankNull, were in the asserts from the other file. I sort of assumed it wasnt duplicated already so I didn't check that.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Given the directive to isolate these 12 tests, just cut and paste them and inline the constant, 'cause they had no dependencies. There were, no tendrils coming out of this refactoring. the code I was modifying didn't have any knock-on modifications.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What would be an example of a knock-on modification?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Like I discussed earlier, I was taking some methods out off a class and putting them into another class. So if in the original class, the methods were using a bunch of private methods or constants, and I pulled them out, then the most basic thing to do would be to copy the needed constants or methods out.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"But a knock-on refactoring that would come from that, is I'd probably not want to do that duplication, so I'd probably take those constants or methods, refactoring them perhaps into another utility class, or just make them visible so they could be accessed from the new class in the originating class, and so that's kind of, that wasn't part of my goal, but to facilitate that goal I would do an additional piece of refactoring work.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: would you consider that part of the overall refactoring then would it be separate?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I would not want to do them separately, I would want to do them at the same time. But I could accomplish the original goal without doing them, so in that sense they are additional.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: You said there weren't any real dependencies, were there sort of dependencies.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Context?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: You said you inspected the code you wanted to move, and there weren't any 'real' dependencies.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"oh, so the only dependency was this constant, so this code isn't self contained in that it relies on this constant. But this constant is not real, so what I meant by that is I guess, that it's not important, it's not somthing i had to wrestle with. I just copied the constant; there's no real impact of doing so. And then later, I found that I copied the constant, and I don't really want it any more so I just inlined it. I could remove that dependency without any thought. Removing that dependency doesn't really add any complexity to what I'm working on. And so in that sense its not real in that it is not impactful.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you know of any tools that could have automated any of the changes you made?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I do know that IDEs often provide class extraction tooling and I've never really used them that much. Especially since I'm not that familiar with IntelliJ, I chose to forego the automated tools that may be present, but I guess there may be tools that could, like, I could probably select one of these methods, and there might be like, yeah there's a move, so that probably would do what I wanted,",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"but when the task is this simple, and I'm unfamiliar with the specifics of what this does, I don't want to do it, because it might do something that is kind of not what I want, and I might backtrack and copy it anyway. I know there is -- so I used Eclipse for like 8 years - and i used the more basic refactoring tools in eclipse a lot, so renaming, extracting variables and methods, changing method signatures, it has a bunch of nice little tools for that.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"But there were some sort of extract class method functionality, and whenever I did it it would do something very strange, and it was never what I wanted, so I stopped using it.","Reflection
Not Effective (“would do something very strange”)",,0,1,0,0,0,"<0,1,0,0,0>",0,60-60,0,0,0,0,0,0,1,0,0,0,
I: Do you remember what it did?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Not really. It would create a class, and the class that I extracted it from.. they would be kind of cyclicly referencential in way that I didn't want, and I didn't really spend too much time figuring out why is it doing this, because it wasn't what I wanted ever, so I just kind of said I am not going to use this tool.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Did you ever try configuring it to not do that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"it was never worth it. The kind of operation - extract superclass maybe, I can't remember - something that create another class, and it never did it in the way I wanted.","Reflection
Not Satisfaction (“never did it the way I wanted”)",,0,0,1,0,0,"<0,0,1,0,0>",0,64-64,0,0,0,0,0,0,0,1,0,0,
I: There is an interesting Extract Class refactoring,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The IDE refactoring tools I used a lot in Eclipse were all scoped to the class I was working on. If I created new classes I tended to do it manually.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"When I started out, I didn't use any ref tools cause I didn't know they existed. For the tools scoped to a single class, like rearranging method signatures, extracting constants, fields, variables, those kinds of operations, I felt like I got an immediate boost in productivity by using them and they were very predictable. It was obvious just from looking at what it said it was going to do, I click on it and it does it, it did what I would have done manually, and it did it faster. For any refactoring that was more complex than those, maybe I did it once or twice, it didn't do what I envisioned that it would do, so I had a miss of expectations there, and it didn't increase my productivity, it got in my way, by doing something I didn't want.","Reflection
Efficient (“immediate boost in productivity”)
 Predictable (“they were very predictable”)
 Effective (“it did what I would have done manually”)",,1,1,0,0,1,"<1,1,0,0,1>",0,68-68,1,1,0,0,1,0,0,0,0,0,
I: What did you have to when it did something you didn't expect?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I would just click undo and it would go away. and then I'd go from there. I've been writing code for long enough to know that I can do this manually, and I can do it reliably manually, and it takes longer than it should, and I'm sure there would be a tool for it, but I was capable or fast enough to do it manually, to feel sure that it wasn't necessary to figure out this other tool to deal with it, it was never a need.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"The only ref tools I used all the time I could look at them and say oh that's useful. Anything that required me to get on its level to figure out what it is trying to do, I just didn't really bother with.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Did you ever encounter any strange behaviour in the local refactorings you mentioned? [28:09],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yes, there can be some problems where.. I guess not really strange but it wouldn't always do what you wanted, for example when extracting a local variable. For example, if you have a repeated string constant or something, or you call three different methods with the same input, and you extract that, I can't actually remember if it would Extract all or only the ones you selected, but sometimes you want one of those and sometimes you want the other. If the thing you're extracting actually has side effects, and you extract three invocations, that actually changes behavior so it is no longer a refactoring, so sometimes you want one and sometimes the other, and it would only do one of them. So sometimes I wanted to Extract 5 instances and it'd do only one, and then i'd need to go and replace the others, or if it extract more than I wanted I'd need to go and put back the ones I didn't want in the place they were extracted from. Otherwise I felt it was all pretty reasonable.","Reflection
Not Effective (“wouldn’t always do what you wanted”)",,0,1,0,0,0,"<0,1,0,0,0>",0,73-73,0,0,0,0,0,0,1,0,0,0,
I: You still kept using the tool even though you encountered that undesirable behavior?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I guess I encountered it rarely enough and it was still faster to use the tool and correct it - or I don't even know if it faster, but it felt better - it's all just a matter of perception - it felt better to use the tool, to just hit, whatever it was cmd + shift + l, type a name, hit enter and maybe.. it was something like 90% of the time it did what I wanted, and 10% of the time I needed to go copy paste something or delete something, and it worked really well.","Reflection
Effective (“worked really well”)",,0,1,0,0,0,"<0,1,0,0,0>",0,75-75,0,1,0,0,0,0,0,0,0,0,
"Conversely there's the Inlining tool in Eclipse, and when you do that, it will ask you, do you want to inline .. so you can select either the field you want to inline, or the instance (call) you want to inline and it will ask you, do you want to inline all occurrences or just this one occurrence, do you want to delete the field, stuff like that, and that workflow worked really well, and I guess for extract variable workflow worked less well.","Reflection
Effective (“workflow worked really well”) and Not Effective (“workflow worked less well”)",,0,1,0,0,0,"<0,1,0,0,0>",0,76-76,0,0,0,0,0,0,1,0,0,0,
"I remember a specific workflow I dealt with quite a bit was .. there is like a convert variable to field refactoring, which I've used mostly in tests a lot. Often you'll have tests set up code, and so you'll have 30 tests and 25 of them initialise some variable and use it, and so you're like, ok, they're initialising it mostly to the same value probably, so you extract it to a field, and the tests that don't use it don't use it, whatever, and you save 20 lines of code. so In doing that I found that I wanted to for example move the actual assignment of that value into a before-block or something like this, and the refactoring tools weren't aware of that I was doing this as part of a junit test that had beforeEach blocks, so it didn't reason about that. So I'd have to do that kind of cleanup after. What I'd really wanted to do, is to turn this variable into a field, initialise it somewhere else - because that's maybe the pattern in this class is everything is being initialised in the beforeblock instead of as the fields, and so it didn't always have - like the ref tool of course is not 'intelligent', it doesn't have all the context and it doesn't know what I'm going to do, so sometimes they would slip there as well.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Did you expect the tool to behave differently because you were in the context of a test?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"It wasn't an expectation, but it was an aknowledgement that .. I never expected it to do exactly what I wanted, but it was close enough, like it would do the first 80% of the work and then I would do the last 20% of the work. I was never like, ah, Eclipse why didn't you do exactly what I wanted - except in the case for that class refactoring where I didn't understand what it was trying to do; if I had taken the time to understand what it was trying to do I probably would have found a use for it, but it never felt necessary to do so.","Reflection
Efficient 
 (“it would do the first 80% of the work and then I would do the last 20%”)",,0,0,0,0,1,"<0,0,0,0,1>",0,79-79,0,0,0,0,1,0,0,0,0,0,
"I: I'd like to ask you about this term you used, predictable; can you elaborate what you mean by that in the context of refactoring tools.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Kind of more, broadly in the context of any tool, if there is a butten that says it's going to do something - of course it is going to be extremely brief in what it's going to communicate to me: it will just say ELV, or you know, convert variable to field, and I read that text, and I form in my mind an idea of what's going to actually happen; 'cause it's not going to actually say, extract the text to this line, and trunkate this part of it, or whatever; it's not going to describe it precisely because that would be ridiculous - so I have to form an idea of what it's going to do, and then if I invoke that action and it does exactly what I expect it to do, then I'm happy, because it was predictable in a way; but really what that means is, i was able to predict it. The predictability is a communication process, so it's not necessarily the case that something was unpredictable, it's that I failed to predict it. And if I consistently fail to predict what an action will do, I'm not going to want to use it.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: In the case of your tests, you'd looked up the refactoring menu and you found this Move action, what would you predict that it does in this context?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I'm actually not sure, because it just says Move. it doesn't say move to a different cass.. for all I know that could just reorder the methods textually int he class. My prediction is that it would prompt me for a class to move it to, and then it would attempt to move it, and that attempt may succeed or fail depending on what the method is referencing. So it may prompt me for additional action in a failure case there. But I'm not that confident in that prediction. I found that because we were talking and maybe something could have done that for me, so I'd try it out and if it was something entirely different I'd probably never try it again.","Reflection
Not Predictable (“I’m actually not sure”)",,1,0,0,0,0,"<1,0,0,0,0>",0,83-83,0,0,0,0,0,1,0,0,0,0,
I: Have you ever tried Move Method?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Not in IntelliJ.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: In eclipse?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Maybe, probably?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you ever do that manually?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I don't find that I very often move methods between classes. I don't find that to be as common an operation unless you're splitting a class into two, or something like this. That happens every so often, but I find that usually when you're doing such an operation; like maybe your task is refactor a class into two separate classes, or maybe you're extracting a superclass and you're going to have two subclasses now instead of one subclass, usually there are other things that needs to change, you're not just doing a move, you usually need to rethink things that are more intricate. So I guess my base assumption is that refactoring tools are not going to do the more intricate things that I'm eventually going to need to deal with, so I guess I just don't bother with them.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I'm guessing this move method functionality these IDEs have, it probably does something reasonable, but the reasonable thing it does is something I don't do that frequently, so I'm probably never going to learn to use the tool. Whereas I find that extracting a local variable for a literal or a chain of invocations, that's not a challenging thing to do manually, but it's something I do frequently enough that I want it to be as painless as possible.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I guess it's two ends of the spectrum for someone to want to use a refactoring tool: and the spectrum I fall hardest on is how frequently do I do an operation, and the other end is, how complex is that operation. 'Cause automating complex operations are obviously of great value, or seem to be, but the reliability of automating complex operations are much trickier to get right. I trust the simple things I need to do frequently, and I drive good benefit from making the simple things even simpler.","Reflection
Trust (“I trust the simple things I need to do frequently”)",,0,0,0,1,0,"<0,0,0,1,0>",0,91-91,0,0,0,1,0,0,0,0,0,0,
[37:42] T2,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"[38:00] I’m guessing .. these are just negations of one-another, so we can remove the negated versions, keep the original versions, and consumers can just negate their usages.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Any invocations would need to be dealt with. So what I'd like to do, is look in StringUtils, look where these are used -- I expect there could be other parts of the string library that could be using these anynot methods - and then depending on the implementation of the anynot I may just be able to inline them; so if the implementations of anynot just refers to isAll then I'd be really happy to inline that, because it'll just shove the desired invocation into the invocation of the methods I'm getting rid of. And then, what I'd do, is locate the tests of these methods and delete them, because we're testing allEmpty and allBlank, so yeah. That's what I'll do.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"[40:00] Go to stringUtils. isAnyNot. Ok, so it's the opposite of what I assumed. I assumed that isAllEmpty and isAllBlank were the base implementation, and the anyNot were derived from them, but it's the opposite. So what I'm going to do, because I do want to inline these in case there are other invocations. I want to see if I should swap these",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I could copy the implementation of anyNotEmpty into isAllEmpty and redefine isAnyNotEmpty isAllEmpty. But first I'll see if they're referenced anywhere outside of this, because if they're only referenced in the tests and string utils, then I can just inline it, I don't need to swap and inline it.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Alright, so StringUtils use them and they are used in the tests. Check isAnyNotBlank, find usages, and again, only referenced in StringUtils, In one spot for the negation, and in the tests. So now my plan is, I'm going to delete the tests, and then I'm just going to delelete the isAnyNot-methods, and then they'll be inlined into the isAll-methods, and then I think I'm done. Alright, so we have my empty and blankTest and any empty, just delete the anyNotEmpty. nd anyNotBlank. Now all .. will this rerun my find? Oh look at that, that's cute",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now I can see they're only used in stringutils. So now I can inline this.,," 
 Invoke (Inline)",0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Inline
"Ah, not supported when return statement interrupts execution flow. I don't know what that means. But I'm guessing it's because this [!] is here. So what I'm going to do is extract this get a result value and then I'll probably be able to inline this.","Invocation
Not Predictable (“I don’t know what this means”)",Invoke (Extract Local Variable),1,0,0,0,0,"<1,0,0,0,0>",1,99-99,0,0,0,0,0,1,0,0,0,0,Extract Local Variable
I: Can you please explain that one more time?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I attempted to inline isAnyNotBlank. The IDE told me I'm not allowed to do that, because, here's an error message that I didn't really understand. But my best guess at what that error message migth mean is that it can't inline it because this negation is mutating the return value, so what I want to do to basically test if that's what's happening is I will eLV for the invocation, and then I'll be returning not the invocation, and I expect I'll be able to inline it when I am just assigning it to a value.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So, we'll just Extract Variable, oh I want to extract the not negated value; I'll just call it result for now 'cause I'm not expecting I'll keep this.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you're just doing this to kind of debug your process?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Ultimately I want to inline isAnyNotBLank. It didn't let me do that, so I figured if I changed the code to work in this way where it wasn't negating the returned value, it would let me inline it. So I'll inline it here, and then I'll see if I maybe want to get rid of this result. So inline that, no ok it doesn't like that.","Invocation
Not Satisfaction
 (“It doesn’t like that”)",Invoke (Inline),0,0,1,0,0,"<0,0,1,0,0>",1,104-104,0,0,0,0,0,0,0,1,0,0,Inline
"Inline interrupts the execution flow. So now I'm going to have to go look, and I'm guessing the problem is in fact that there's multiple return statements here, so it can't inline this. But at this point, now that I'm in isAnyNotBLank, and i know that I'm just negating the return value, and it just has three return statements,",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I could just copy this code and change the three return statements to be the opposite. So I've tried to use the tools, it didn't let me do it, I was wrong about why it didn't let me do it, but now I look at it, and I see that it can't inline multiple return statements, because that's, it makes sense, but I want to negate the functionality of this, so I can just negate the return statements.","Invocation
Not Efficient (“I can just…”)
 Not Effective
 (“tried to use the tool and it did not let me do it”)",,0,1,0,0,1,"<0,1,0,0,1>",0,106-106,0,0,0,0,0,0,1,0,0,1,
"So now I'm getting back, can just delete all of that, getting rid of all of this very nicely written documentation, and now I should have an error somewhere, navigation by errors, always good. I guess I can probably find my .. and now I'll just paste this in, and I need to change these three: false goes to true, true goes to false, and false goes to true. So now I need to do the same thing for isAllEmpty.",,Manual Inline,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So, isAllEmpty does the same kind of deal here, it's negating the returnValue from isAnyNotEmpty, so I'll hop over there and just cut this out .. and delete that, and .. *mumbles* There we go. false goes to true, true goes to false, and false goes to true.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So now I've done this refactoring, I've deleted the tests, so now I'm going to run these tests, because they should also test isAllBlank, isAllEmpty, because they are testing the code that i modified.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Alright, so I'm also going to pop over to stringutils, because I'm just going to make sure that the documentation looks good. Because, since the implementation was referring to the other version, there is a chance the documentation was also referring to the other version. But it looks like it's not. So I don't think the documentation needs updates, this should be implemented correctly, now I'm just going to have a quick peek at this to see if this maybe can be simplified.. ok so if you pass in nothing, ok.. What's the contract here? Should return true. So if you pass in nothing, should return true, if any of of them are empty return false, otherwise return true, so this seems like a fine implementation, there's nothing .. So I believe I'm done.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What code changes did you do in order to solve this?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Ultimately the code changes I made were deleting tests for the methods that were to be deleted, then copying the contents of the methods that were to be deleted into where they were being invoked, and changing all the return statements in that code, because all the consumers of those methods were negating the returned valye from the methods to be deleted.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you know of any tools that could have automated it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"[48:45] I do not. The one tool I thought may be able to automated this refused to, because it can't inline method invocations with multiple return statements or perhaps return statements that are organized in a certain way that interrupts execution flow. I would expect, that to inline something like this, you would probably need to define a variable, and then change all of the return statements to assignments and then return that variable. So an alternative way to accomplish this would have been to change those return statements to the variable that was assigned, and then I could have inlined it. It seemed like more work for no gain. So no, I'm not aware of any tools that could have done what I just did. It seems a fairly easy thing, what I just did, so I would not be surprised if there was a tool, but I'm not aware of one.","Reflection
Not Effective (“one tool I thought may be able to automate this refused to”)
 Not Efficient (“more work for no gain”)",,0,1,0,0,1,"<0,1,0,0,1>",0,114-114,0,0,0,0,0,0,1,0,0,1,
"I: You changed the order in which you planned to do your changes at some point. You said you were first going to do the code changes in StringUtils, then remove the tests, then after you realised the way this was organised you flipped the order, went and deleted the tests first, can you elaborate on that?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I think when I knew I was deleting these methods, what I was most concerned about was whether these methods were invoked kind of all throughout the library. And so, once I saw that wasn't the case the order didn't really matter, and I had it open, and the only reference was the test, so I thought, I'll just go and delete the tests. I think when I gave that ordering I weren't too concerned about the relative ordering of those two operations, I was mostly concerned about what other places in the library might be dealing with this, and so once that wanished, I guess I flipped the order, but it didn't really matter.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is there any other changes you did that you're not sure you got right?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"No, I'm fairly confident I did this correctly, and one of the reasons I'm confident about that is that the test suite seems pretty ok and I'm kind of trusting the tests. And I do that a lot with refactoring. One of the key points with refactoring is that no functionality should not change -- in this case we deleted methods, so that did change something. But if I Inline something nothing should actually change, just the code that does the action should change, and so if the tests behave the same before and after a refactoring, I'm usually pretty confident. Especially, I feel this refactoring was pretty simple. The only, I guess ""tricky"" part, was negating some return statements. For example, there are just three statements per method in this case, and I'm pretty sure I got it right. But if there were more statements than this, I might want to run the tests with code coverage, to make sure the branches are covered. but because this is simple and I actually understand the implementation here, I'm pretty sure I got it right.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"But if there were more statements than this, I might want to run the tests with code converage, to make sure the branches are covered. but because this is simple and I actually understand the implementation here, I'm pretty sure I got it right.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
T3 [52:18],,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"This task is asking me to remove a parameter from a bunch of different methods and have all the methods behave as if the parameter has been passed in as false. Before I formulate my plan I would like to see how the parameter is used in the different methods. I can see in the first one that it's just used once, so I am pretty confident that I have a couple of different options for how to approach this, but I want to see if it's used in more interesting ways, then I may want to change my plan. It looks like it's largely passed through to the getDeclared fields methods. And it's used in a few other places. So for most of the places where it's used directly, and not just passed through, it's mostly just a case in an if-statement, so since I'll be setting it to false, I'll be essentially deleting half of the if-statement.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I will find the base methods -- the methods that use it directly -- I am going to remove this from the method signature, so remove it from the parameter list, and then I am going to delete half of the if-statements, where I will presumably now have an error, because I deleted the thing it is using. Once all the direct things are done then it's just changing the signature of all the other methods and they won't have any real changes, they'll just pass this in.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Here's one of the direct usages. We'll go to change signature.,,Invoke (Change Signature),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Change Signature
"Thinking, that's fine, can I tell it to just do that? Yeah. So now I have compile error, which is fine. This is always false. Since it's always false, this if-statement will never be executed, so it will always just call -- if this was passed in as false -- it would always just call memberutils.setAccessibleworkaround so I'm just going to delete this. Alright, so move on to the next one. Not going to deal one yet, want to do all the direct accesses. Alright so here is one. Do the same thing. Change signature. Continue. So this is false, so it will always just continue once it finds an inaccessible fields. The same deal, ... documentation .. it's always false.. Why is this mad at me. Aah. Ok. I have made an error.","Invocation
Effective (“can I tell it to just do that? Yeah”)
 Satisfaction (“which is just fine”)",Invoke (Change Signature),0,1,1,0,0,"<0,1,1,0,0>",1,124-124,0,1,1,0,0,0,0,0,0,0,Change Signature
I: What did you discover now?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I have discovered that by removing this field I now have degenerate signatures. There are multiple methods of the same signature. Now I'm going to undo my refactoring 'cause I have no idea what that was passing in before. It claims to be accessible, so I assume it was passing in false, but I just want to check. Yes, undo that change. So it's passing in false. Ok.",,Undo,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Seeing this, this kind of makes me want to change my approach. Now it kind of seems better to inline this so it goes up here. Because if that's doing exactly what I want, it's making the method be as if false was passed in, but I'm already half way done, so I'm not going to do that. Instead, I'm going to delete the methods that are just calling the method I'm modifying. Redo.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Just delete that, because now this one behave as that one did.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"[59:35] This is something where, I was very defensive about this on the previous refactoring where I wanted to see where all these were used, and on this one i didn't do that for some reason. So that kind of bit me in the but. This is the same, it clames to be accessible, I can just look at the diff here, it used to pass in false, so I can just delete that. Because that is what the new one does.",,git,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So you didn't go an look at these errors before right?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"[59:50] No, I didn't notice them until the third one. I was just moving a bit quick I guess. Here is another direct access. This time I have readField and I can see it's up here. So I want to ... I'm going to do it the other way not, because I'm kind of curious if this would work. I'm going to inline this. So by inlining this invocation this readField method will behave the way that I want it to behave and then I don't need the other one. Inline the invocation. Inline all and keep the method. I'm just going to inline this one, and then I'm going to delete this, 'cause I don't know if there are other references, so I don't know if this is a good idea or not. So now I can see that there's this if-false-end, so obviously that is never going to execute, because that is how booleans work. Just delete that. And then this one I'll just delete it. I didn't want to inline it into all invocations, because if something else was calling it, I now want to call this new one. I don't want to inline...if I inlined it into all I'd have it inline into potentially some other class, I didn't want that to happen. I only wanted to inline into that invocation. And now that I know I have some errors I'll see what's going on.",,Invoke (Inline Method),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Inline Method
I: How would you know if someone else uses it?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
In the library I'll get compilation errors.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I didn't want to inline all, because it would've changed these invocations, which I did not want to happen. And now these all have these forceaccees, so I'm going to have to remove them.","Invocation
Predictable (“because it would’ve”)",,1,0,0,0,0,"<1,0,0,0,0>",0,134-134,1,0,0,0,0,0,0,0,0,0,
I: Can you elaborate on that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Ok, so this invocation was attempting to call the method I deleted that had the forceaccess parameter. I had deleted that method, so it couldn't invoke it. But we want everything to behave as if forceaccess was false, and so this should call the method that didn't have the forceaccess parameter, because that method behaves as if forceaccess is false. This method also takes a forceaccess parameter, but I can just remove that by changing the signature.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So maybe I should have done this the other way around, but whatever.",,Invoke (Change Signature),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Change Signature
I: What do you mean by the other way around?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
[1:02:50] It might have been better - and I'm not entirely sure actually - if I had modified all the callers before modifying the methods that were being called.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Why do you think that could've been betteR?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Because then ... no it's all the same, because they have duplicates as well. it might have resulted in a process that was less driven by compilation errors. Because I just did that I can't actually inline this into the other invocation. So I'm just going to undo that..","Invocation
Not Effective (“I can’t actually inline)",Undo,0,1,0,0,0,"<0,1,0,0,0>",0,141-141,0,0,0,0,0,0,1,0,0,0,
I: So now you're backtracking your change in order to use the tool?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yeah.,"Invocation
Not Efficient (“backtracking your change in order to use the tool -yeah”)",,0,0,0,0,1,"<0,0,0,0,1>",0,143-143,0,0,0,0,0,0,0,0,0,1,
"Inline all and remove, inline all and keep - I guess it's only one invocation of this so it doesn't give me that option. Wait what did it just modify.. it was this one. Already forced access above don't repeat it here. Oh, because it calles readField and it used to pass forceaccess into get declared field, so this comment is now out of date, because there's no forcing of access. This error..it would never get down here if the field was inaccessible. So this one is the same thing, I can't really backtrack this 'cause I don't know when I made that change, so I'll just pop this up here - no what am I doing. I'm just going to delete this one, 'cause this has no value, it just used to call this method with the parameter, the parameter don't exist any more, so this can just be deleted. Ok, so I'm back to a state where I don't have any compilation errors, which is nice. Ok, so what do I actually have left. I have writeField, writeDeclaredField, ReadField, ok.",,Invoke (Inline Method),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Inline Method
"Now that I've gone through this and I've kind of shot myself in the foot a few times, I'm actually going to look at where this is used before I go and change things. So readField is used in the tests. I'll deal with that later. Oh, and it's also used in ReadField. I'm going to delete this one, and this already isn't using forcedaccess because it was only passing it through to other methods so I can remove it from the signature. Done.",,Invoke (Change Signature),0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,Change Signature
I already dealt with this one apparent.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Apparently?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"[1:06:13] Sorry, I don't have to deal with this because there are no forceAccess, so either it was never there or I've already dealt with it.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: Ok. So now, are you moving between either, let's say forceaccesses or compiler errors?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Now I don't have any compiler errors here. I was sloppy to start with.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"WriteField, this uses forceaccess, so I can just. What's better, I don't know. I'm just going to delete this one, because this one... hold on. Oh there's three writeFields. Oh no. Field target value, field fieldname.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: how did you notice that?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"[1:07:09] I had two writeFields on screen, and I had become accustomed to there being pairs of these methods, one which took forceaccess and one which did not. Suddenly I had two writeFields, and I saw one was calling another writeField, but it was not calling the writeField I had on screen. So I almost wanted to inline these into each other, which would not work because they're totally different. They don't even have the same signature. One takes a field, one takes a fieldname, so they're kind of unrelated it looks like.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I'm just going to delete the one that calls the other and then kind of change the base method.,,Invoke Change Signature,0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,#N/A
"Again, this is not even using forceAccess because it has been removed from all the methods that it is calling. Now we have writeDeclaredField which is the last one that has this. So I'm going to do the same thing, delete this, and change this. Ok. So now. I am noticing that the documentation for these are wrong. It is talking about the fact that an illegalAccessException can be thrown if the field is not made accessible. And that makes sense if you can make the field accessible, but you can't. Also these comments are still. And so seeing this - because I've gone through like three different ways of doing this refactoring - this tells me that documentation from the thing I removed was different. It presumably said that - no its documentation sucks also! So this method always passed in false, it claims that it will throw an illegalAccessException if the field is not made accessible, however, it provide no facilities to do so. So, but new documentation sucks, but it's the same as the old documentation so I'm not going to change it. I mean, it's probably a little worse now, because it's actually no way to make it accessible, whereas before the way to make it accessible was calling another method. But I'm not worrying about that.",,Invoke Change Signature,0,0,0,0,0,,1,,0,0,0,0,0,0,0,0,0,0,#N/A
"Now that I've done this, and I never looking at the tests, I will look at the tests because they're now presumably totally broken.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What are you looking for now?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"These tests used to invoke the methods that I changed. Because I changed their signatures, and they overlap with other signatures there's no actually breakages, but that probably means I have duplicated tests and broken test cases because there were tests that were passing in true, and now everything behaves as if false were being passed in. So if I just scroll down, I can see that I have a bunch of modifications here. So looking at them..","Invocation
Effective 
 (""I changed their signatures, and they overlap with other signatures there's no actually breakages”)",,0,1,0,0,0,"<0,1,0,0,0>",0,158-158,0,1,0,0,0,0,0,0,0,0,
I: So now you're using the git integration?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Yes. By invoking the refactoring tool it changed code I wan't looking at. So a good way to see those changes is through the git integration. it this wasn't in a git repository. I'd be more screwed than ... I'd be kind of screwed and this saves my bacon.,"Invocation
Not Predictable (“changed code I wasn’t looking at”)",git diff,1,0,0,0,0,"<1,0,0,0,0>",0,160-160,0,0,0,0,0,1,0,0,0,0,
"So I can see that this used to pass in through, and it makes sense; the test says testGetFieldForceAccess so it was forcing access. That's no longer a thing that we support, so I'm just going to delete this.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What would you have done if there wasn't git integration here.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"The test name tells me something about what it does, so I might have been able to extrapolate from that. Also if I'd run the tests then some tests would fail because they were attempting to do things that were no longer possible, so I could just delete them. However, the main problem would be the tests that are now duplicated, because there may have been tests that were calling the method without the forceAccessparameter, and there may have been tests calling it with false. So they may be duplicated, because they should now do effectively the same thing. So running the tests would let me get rid of some of them, but for the duplicated tests, I'd have to read through the code to find them I think. [1:12:23]",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I can search for the method names that I changed, which I don't remember because there was a bunch of them, and I wasn't paying that close attention, so that wouldn't really work. So yeah, I'd have to read the whole file and try to identify duplicates I think without the git integration.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"testGetFieldForceAccess-illegalArgumentException. So I'm expecting that this used to pass in false, and now it passes in nothing. Oh no it used to pass in true, so it was attempting to forceaccees in a way that didn't make sense. what is it doing? Oh, it's passing in a null value. It's doing invalid stuff. These are stuff that don't make sense any more because we're not forcing access, so all the ones that says forceaccess can just be deleted.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Down here again, this one is talking about forcing access and it's passing in true, so it can just go away. Again talking about forcing access, true, true, yeah these are all similar. This test is strange. It's a bunch of try-cases but it's passing in true, true, true...all trues. So this can be deleted. *reading names*",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"There are some more down here, thank you git integration, so yeah, forceaccess.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
Forceaccess.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So I'm not even checking any more, I can see that they have consistent naming conventions for these, so I'm just going to trust that. Are those modifications? Not sure, ok.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Now i've deleted all the invalid test cases I believe, so now I'm going to run this.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Ok, so the tests pass, but I'm expecting that I still have a bunch of duplicated test cases here, so I'm just going to scan through.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
getField.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: So now you're scanning through the actual code, not going through the git diffs?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"There are no git diffs any more, the only diffs left in the file are my deletions. But you're right if there had been any changes to remove that parameter there would have been a diff, so that tells me that these tests were not passing in false anywhere. They were always just using the no-arg-method to check those cases, because they were confident that the no-arg-method called it with false I presume. That kind of makes sense. They have kind of overloaded these testcases, which is convenient for me but a bad pattern, so I can see that they're calling getField on publicChild with these fieldNames and also on this privately shadowed child, they have a couple different inputs, but I don't see any duplicated invocations of getField. Or even if I didn't have git, I could look at this and say there's no duplication in here and it doesn't look like there's anything else that is actually testing getField. Other than these ones that are failurecases, where they are just testing their edgecases, these are invalid fieldnames, things like that. Similarly, getDelcaredField, then there are edgecases. So at this point, I think I'm done, but because that went so sloppily I'm not super sure. If there was anything using fieldUtils outside of FieldUtils and its test, it might be broken now, because it might have been using fieldAccess true. I'm going to see where FieldUtils is used. FieldUtilsTest, that's fine. That's the tests. So it's not being used anywhere else. At this point I'm confident that I didn't break anything else, because nothing else is using it, the testsuite passes, I believe I deleted all the invalid tests, and it appears that I haven't left a bunch of duplicated test cases. So I'm done. [1:17:54]",,"run tests
 git diff",0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What did you do in order to solve this task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Initially believing that the methods were not overloaded, I went to inline or remove the forceaccess parameter. Then finding that that caused there to be conflicting methods with the same signature, I had to go and delete those methods. Then I went to the tests and identify the tests that were now invalid, as they used to pass in true, and none of the methods behave as if true were passed in and I deleted them. I then searched for usages of this class to see if there may have been anything else that was using it that may need an update, and there were none. And so I did it totally backwards.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"What I should have done - and I think the reason i didn't do this was because I kind of had a peek and there looked like there was a bunch of methods, and I don't know, maybe I didn't want to check all of the methods - but what I should have done was looked where the methods were used. Even if I just picked one, getDeclaredFields, if I just found usages of that and found that it was actually referenced in this class, then I would have found it. Whereas I didn't do that, and I didn't have a hint that it would happen",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I think the reason why I did that for the stringUtils one and not this one, is because the stringUtils one tells me to do that basically, by saying, these two methods are related. And it literally didn't even occur to me to look for related methods without that hint, which is pretty funny.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"But what I should have done is looked for where these things are referenced, so I know what the impact of my refactoring is going to be. Instead I just went and started doing things and it cause a bunch of errors, that I had to figure out the best way to recover from. And none of them were that problematic really, it was just duplicated methods, and they were not duplicated in a dangerous way, because they both did the same thing, so I had a couple different ways to remedy that, so I could delete one, or I could inline one into the other. It didn't really matter, they were all doing the same thing, it was just invalid definition of the class.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: To clarify, you said that you inlined parameter. You did these code changes where you also changed the body of the method. What did you consider that part of? Was that part of your inline or part of your remove parameter.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"The way I decided to do this was that, I decided to remove parameter, and in my brain I knew that remove parameter, was basically saying anywhere this parameter was it would basically be false, and I had inspected the code and determined that the way this code was used, it was just used as an input to a few if-statements. So knowing that I knew that half of the if-statements would just be deleted in every case. So I just decided to delete the parameter, and then the IDE would, you know, tell me in bright red, here is where it is used, and then I could just delete it.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Alternatively, had I seen that it was beeing invoked in those kind of paired methods, I would have seen that the two cases are, you give me the parameter, or it gets passed in as false. In such a case, if I were to inline it to the places it was called with the false input, presumably, it would inline that false into where it was being referenced, and then I would just be able to delete that. I think the refactoring probably would have gone smoother if I had been inlining the 'real' implementation into the methods that were just calling it with the false input. But I formulated my plan without knowing or noticing that there were these other methods that were calling with these false inputs. And part of the reason why that happened I think is because I was very honed in on this parameter named forcedaccess. So when I was actually looking at the code, I didn't pull up an outline view or anything, I just searched for forceAccess. So all my brain was thinking about was the methods that use this parameter, and there was no other thought in the world.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: so you didn't think about inlining because you were focused on the parameter.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Exactly. Had I noticed - scrolling through here, had I noticed the duplicated methods there is a good chance I would have gone with the inlining approach.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: How would that have impacted your work with the tests later.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"If I did it in the same order, I think the work with the tests would have been the same. Oh - yeah because it would want to inline into the tests.. So what I would have done - and I did it for one of the method pairs - is when I did the inlining, I only inlined that one invokation. I didn't inline all invokations. and that would leave the tests with invocation errors. I would inline one and delete the other. Deleting the method would cause the compilation error in the test, and then I would go and delete the test basically. So it would have changed my interaction with the tests a little bit. But it would have meant that I would probably have used the compilation errors to identify the test to alter instead of the git diff - which was the only thing that saved me.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Can you talk a little more about the way you seemed to cluster your manual code changes during this task.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
What do you mean by cluster?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: it seemed that you first did the skimming we talked about, then you changed the signatures, and so you actually did a batch change like that - you changed a lot of the signatures.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
There was kind of two types of methods. There were the methods that had the forceaccess-parameter and then simply passed it through to another method with the forceaccess-parameter. And there were the methods that took the forceaccess-parameter and used it in an if-statement.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You called these the base methods.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yeah, in that they're the ones that are actually kind of leveraging the forceaccess-parameter. They're kind of at the bottom of the call hierarchy. when you call one of the other methods they'll call.. yeah whatever, they're at one end of the call hierarchy that i'm calling the bottom now. So you call one method that is just passing through this parameter, which calls another one, which, maybe .. to another one which has an if-statement. And the ones with the if-statements weren't calling any other ones. So I wanted to modify this first, because those were the ones where the control-flow would have to change. And all the other ones would just be to delete these parameters. And so if I worked my way from the bottom to top - worked my way from the signature of the base method, changed its body so that I believe that it's implemented correctly. So by removing the parameter, all the of the other ones that call it, their bodies have been changed, so I can just go and remove what is now an unused parameter from their signature. and so that's why I wanted to do it that way, from the more complex case where I'm modifying control flow, to the less complex case where it's just changing the type signature.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I noticed that these methods were calling each other so I was thinking about that kind of more complex implementation changes to less complex implementation changes. And that's probably why I didn't notice or think about the duplicate methods. I was assuming all these chained invocations were doing kind of different things, not doing the same thing. I didn't think about the overloading.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: And then you did the test cases, and then you searched for usages.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yes. Searching for usages should have been the base thing that I did, but I didn't, so I ended up having to double check the work at the end. Had I searched for usages I hopefully would have noticed the method overloading which would have changed my plan.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is this usually how you would have approached this kind of task?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I think the general approach, yes. Hopefully, while I am doing this most of the time I would notice more things. I guess I was kind of hurrying so I didn't notice them. But yes, if I was removing a parameter like this I would like to get a sense of where it is used. And I did get that sense, I just didn't get a complete picture of where it is used. And then I would move from that more complex and outwards. So I think it would have been about the same. In most cases yes.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you know of any tools that could have automated the kind of changes you did.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
The only change that was not - well there was deleting the test cases - but the other changes of as to modifying the method bodies and those statements - there might have been some dead code detection that could do that.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So if I had done the inlining, the I would have had dead code, 'cause I would have had if-false, or if-false and something else, and it might ahve offered me an option to delete the dead code. but because I didn't think of inlining, I didn't get to leverage anything like that. As far as deleting the tests, I don't actually know of any tools that would do that for me. Unless, like, yeah no. I can imagine a tool, that would - you know, if I inline a method, it would go, do you want to delete the tests associated with this, but I don't know of anything that would do that.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: If you were to use the inline tool, and inlined them everywhere, how would that have impacted the tests?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"That would have inlined them into the tests so if I were to do the inlining, I would not have done inline everywhere. I would have just done the invocation in the overloading method, so it would have just done it into the overloading method. And so I would have still kept the original method, which would have invalidated the tests, and then I would have dealt with that after. I would not use inline everywhere for something like that.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: And if you had other usages, how would you have gone about those?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I would modify those to call the method with fewer paramateres. After inlining. I would inline, delete the method with more parameters, and then I'd have to go and alter the other ones. Because this was kind of a hybrid inline-signaturechange, it feels like, there'd always be something I'd have to do manually.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"If I inline and delete, then there may be dangling invocations. If I change signature, then I have to delete the previously overloading one. And then I have, ... if you change the signature and then delete, then everything is calling the right method, and there wouldn't be dangling invocations, so there would be less work to do. But I didn't think about that when I made that choice. I just made that choice because I saw this hierarchy so it made sense to me to change the signature.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: If you were to do this all over again, which approach would you use?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I would probably, if I noticed the overloading, I would probably do the inlining approach.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: You just said that could be more work?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I said it could leave dangling invocations if it were used elsewhere, but I feel like dealing with those dangling invocations is very simple. It's just deleting the parameter that gets passed in and so I think I would still prefer that workflow, even though it does leave some fragments of manual works.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: And if you'd used the remove parameter approach?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"If I had used the remove parameter approach, which is basically what I did, then I end up with a conflict, and I guess I prefer dealing with the dangling invocations than the overloaded signature.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: When you did the signature change, that also impacted the test code, was that a concern?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yes, I think that is a concern, because that leaves ambiguity in tests code and I had to use git dif. Whereas if I do the inline and delete it makes it very obvious what the tests are doing, because they don't get modified at all, so you can deal with them separately. Of course, a better approach would have been to deal with the tests first, but I think in most cases I don't do that. In most cases when I do a refactoring - when I think about refactoring, I'm usually not modifying tests, because usually ... in a sense this is not a 'true' refactoring, because it changes functionality, changes capability, and so usually when I approach refactoring, I am just touching code, often not touching any tests, and then just run the test suite and it should validate that nothing has changed. So I would probably still have left the tests for last.","Reflection
Not Satisfaction (“leaves ambiguity in the tests code”)",,0,0,1,0,0,"<0,0,1,0,0>",0,213-213,0,0,0,0,0,0,0,1,0,0,
"I: if you were to refactor code that are directly used by tests, that wouldn't be a refactoring?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Well, no. The test might change, but the difference between that and this - that's the same thing. These two both had test changes - and it's true that both of these reduce the API footprint of the library, they both removed capability. But this one feels like a much more significant change, the last one, because anything you can do in task 2, before and after, you can still kind of do it, like you just get a boolean result. Whereas this actually changes what you do, like you can no longer access certain functionality. So this feels like a less pure refactoring, although fundamentally they are not pure refactoring. I still think, no matter what, when I do refactoring tasks I approach the tests last. Because a lot of refactoring end up being fairly pure.. the tests usually don't have to change much, if at all. In both of these cases, the only changes to the tests were removing tests. However, I coould definitely envison a world, where - like there is no, for task 2, the only possible change to the tests is deletion. Becaue we are just removing a couple of methods. In T3 it could be that the tests needed further modifications beyond deleting whole test cases. There might have been some test duplication after the refactoring, whereas there was no risk of test duplication in after T2's refactoring. This one had a higher, more possiblities for test impact on task 3. But in either case, I would leave the tests for last.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Do you always organise your code changes such that it is the not-test changes versus test changes?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Not always, when I'm writing new code I usually write tests along the way.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: Sure, but when you are refactoring.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yeah, when I'm refactoring, I think so. Sometimes I'll look at the test to get a sense of what I'm doing as I approach it - which I didn't do this time - but yeah I would usually just deal with the code and then the tests are an afterthought, because there's usually not a huge impact to the tests for most refactorings in my experience. Unless, I'm splitting a class apart, then I also have to split the tests, and I think I usually also leave that until after. Test driven development is nice, but I find that I generally don't ever do it.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: If you were to use tooling that weren't just scoped down to your local file, like you spoke about before, would you want them to treat the tests as the rest of the code?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I think - yes. I think for the kind of .. if I was extracting stuff to a new class, I think it would be quite a challenge to implement a refactoring tool that could deal with that in an intelligent way. Because usually, in my experience, - if you're taking a class and splitting it into a few classes, it's usually because it has quite complex code. And if you have quite complex code, and you're worrying about your tests, then you probably have quite complex tests. And so, if you're splitting that up, and you're trying to split up the test class, I think there's a good chance that wouldn't work very well, because - probably the test class has a lot of helpers, or even define its own like, static classes to do something, or you know.. sometimes the tests can become far too overwrought. So if you're bothering to refactor a piece of code into a bunch of different classes, the tests you'd also want to refactor, but I'd not anticipate that any kind of tool could refactor it in a way that could produce any kind of result that I would want. But of course, if such a tool exist, that'd be great. But if I just saw a tool that was like, ""split class"" and I trusted it would work, I'd still not trust that it'd make the tests be the way I want in the end.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: So then if I understood you correctly, you'd want it to split your source code class, but not touch the tests.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yeah, I wouldn't be confident that whatever it would do to the tests would be what I would want to do with the tests. And so I could imagine a world where it might do something and I might have to go in there and much around and do something more, because maybe it duplicated a bunch of stuff between the tests, or.. if there were a bunch of helpers that set up the tests, and maybe it duplicated those.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Like, let's pretend that you have a big class that takes some input, and the tests are mocking that input, and it requires extensive mocking to make that - maybe the things that are being mocked can produce other objects, and you need to mock those objects that are being produced. So for my kind of metatest, my big test, monolith that I have in the beginning, it has to mock a bunch of different method calls that could happen on this class I am refactoring. So if I split that class, and both classes I produce still take that input, both tests would need to mock up that input. But perhaps those tests, the classes that I split apart, they deal with different aspects of the input, and so each test will now deal with less mocking. So I would not anticipate a refactoring tool would dealk with that.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I would imagine that the best case would be, it would just duplicate the mocking and I'd just go and clean it up, which you know, isn't bad, but I'd .. if it did half the job for me, and I went to go do the rest of it, I feel like I'd be less confident at the end that I got it the way I wanted, because I didn't have to consider every aspect of every step of the path (*)",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"So if I refactor the tests myself, then I have to make every decision, I have to think, ok what's actually needed for this test, instead of going, ok, what's actually here that I don't want.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: So in that case, would it be better to leave the tests as they were?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I am not sure. I guess I haven't deal with a lot of.. This is a lot of guesswork, I'm really not certain. I guess the only reason why I hazard towards I want to handle the tests myself, is because I know that world very well because that's everything I do. The other world is kind of an unknown. I guess if it worked great, I guess I'm just not sure how likely I think that is.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: How would you usually keep track of your code changes when doing such a task like this?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"It depends on if I hit any scope jumps. If I'm doing a Refactoring, and I usually have an idea of what's going to happen, and I usually focus that idea to the actual source code and not the tests. So if I'm working along - and this happened like the day before yesterday - I was extracting a, we had some microservices, some of the microservices are kind of like web servers, so they deal with like authorization concerns, and there is a bunch of duplicated code around this duplication concern, and I noticed that the code had kind of drifted away, so initially it had been a copy, then it drifted, and I was like, oh this is no good. So I was going to introduce a common dependency. And I thought it would be a really simple self-containted dependency, and then as I started I realized oh it has all these extra things, it's actually kind of tricky, so there's a couple moments, where I had a very clear idea about what had to happen, and then it turned out I needed to do more. So assuming that that kind of scope-jump does happen -",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: you called that a scope-jump?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yeah, you suddenly realise, that to accomplish your goal the scope of your work needs to be much larger, so it kind of changes the scope of your change. It's not a term I use day-to-day I just pulled it out of the air..",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"If I have a clear idea of what I'm going to do and it seems like that's happening, what I'll usually do is execute my refactoring, stage those changes, because I feel like it is a complete piece of work. Then I'll look at the tests and make sure they look okay, and I'll run the tests. Let's say I'd made an error, or I was wrong and there were some knock-on effect that I did not anticipate, then I start to deal with those. I like to do that because it gives me a baseline: here is my idealized version of the work and here is the real work that has to happen afterwards. That lets me understand where I might have made a miss in my assumption or understanding of the problem I'm trying to solve. Then I can also kind of look at the changes I made once I thought I was done versus the changes I made when I am actually done and maybe I want to take a different approach entirely when I have that kind of comparison. Assuming there is no big jump: form an idea of what I want to execute, execute that idea, and I don't hit any bumps along the way, kind of seal that in a way, validate what I've done, and then do additional work. Then compare those two and see if my initial path was actually the right one based on the other additional changes I had to make in order to achieve my real goal.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: So the additional work may actually be things that are required to make the code run or compile?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yes, maybe I find that in my refactoring I actually changed a behavior I didn't know existed or, I guess there may be broken references. I guess if there is compiler type errors I'll usually see them and incorporate them into my first pass, but I feel like the other, is kind of two passes, it looks like I'm done, and so finding out if I'm actually done. When finding out if I'm actually done I may actually find that there's more that has to be done or needs to be done, in order to achieve the higher level goal. I don't think you usually go into a refactoring where your goal is remove a parameter. Usually it's like, your code is hard to understand. And doing that refactoring you may find that your code is hard to understand, and once you get into your code you may find that if you remove a parameter the code would be better. And as you go through those actions and remove the parameter, simplify some stuff. And then maybe you realise that oh actually, maybe this did improve it, but now that I've worked in it, maybe there's an entirely different approach that would have been better.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: And then, would you need to roll back the things you had already done?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
It depends. I don't think I throw away a lot of refactorings.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: When you don't throw them away, do you just kind of navigate from there and out?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"It depends. If you made an improvement that is actually a good improvement, then you'll probably go for it and work on what's next. But sometimes you might find that your approach is totally off, but I do think that is pretty rare.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: So this pattern you are describing now, does this match how you were working on the third task.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Not really, and I think the main problem with that was that I formed my picture of removing the parameter, and I hit that bump of the overloaded methods, and that bump needed to be resolved immediately. So I wasn't going to go through it and leave a bunch of overloaded methods because you wouldn't be able to run the tests, nothing would compile, it would be a showstopper.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: So that became part of your little, say, package.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Yeah. So then, that's when I said I believe I am done, and then I went to look at the tests. And then I also went and looked for usages, to see if there is anything else going on. But because I am not a maintainer of this code, I think if I was more immersed in this code I'd have more ideas about things to try out and things like that. I didn't execute that plan, and I don't think I follow that in a rigid way, but I think it's something I do end up doing fairly commonly.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I: When you do refactor, especially if you use tools, how do you ensure that the tools are correct?",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"Tests. I've rarely been done wrong by the refactoring tools, except for like I talked about earlier, when it does something I don't want. It's very rare that I .. but I does happen, you inline or extract something and it had side effects and you don't realize it. I rely on tests and code reviews to catch that. Like if inline something and I'm naive and I don't understand how it works, and they say that it's actually very important that it happens in this way, it's very important that we call this method in the if-statement instead of extracting it to before the if-statement - that's actually something that happened before where I have if(a || method-invocation) and the method-invocation has side effects, and I think the line is too long and I extract it, but then the side effect happens all the time instead of just .. and that's something that I think, often that kind of stuff is not very well tested for. I mean, you usually don't have 100% test coverage. That's when I rely on my coworkers for code reviews, to say, that's actually not a refactoring, that changed something.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is that something you expect the tool to manage?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"No, I never expect the tool to manage that.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: Is that - fine?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"It has served me well the past eight years. And I remember actually a very specific example of that situation I described, with an if-statement and an or, and I remember - it's so funny - because there's the logical or and the bitwise or - and you can use the bitwise or on boolean and no one does it because it doesn't shortcircuit, and then you put in the bitwise or operator to not shortcircuit this call that has side effects, that's like ..",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"I don't find myself working with that kind of fragile code very much. 99% of the time I don't have to worry about these kind of things and I don't have any side effects or that kind of stuff happening, but then for that 1% I can only really rely on tests and code reviews. I don't really expect the tool to warn me about that of thing.",,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What would you say are dealbreakers for you when using tools?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"The main thing is that I understand what the tool is trying to do. Or the tool behaves in a way that I predict. It's that predictability. I generally don't want a tool to do things that I would never want to do. So like, there are like, repeated patterns that as you work as an SE, you find that you're often doing these operations and they are repetitive, and you'd like them for them to be automated in a nice way. These operations are often simple things, because the simple things are what you do most commonly, and so for the more complex things, you see some complex operation and you think that is automatable. But because it is more complex, there is more variance in what outcomes you actaully want, and so I shy away from those kind of things.","Reflection
Predictable (“or the tool behaves in a way that I predict”)",,1,0,0,0,0,"<1,0,0,0,0>",0,252-252,1,0,0,0,0,0,0,0,0,0,
It's about trust and predictability.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
I: What do you mean by trust?,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
"That I trust it will be realiable. If something has a lot of variability in what it could do, I can't predict or trust that the outcome will be what I want. Then I have to spend a bunch of time verifying that what it did is what I want, and I'd rather just do what I want instead of ask a computer to do something that I might want and then check to see if it's what I want and then correct it to be what I want, that seems like more effort.","Reflection
Trust (“trust it will be reliable”)",,0,0,0,1,0,"<0,0,0,1,0>",0,255-255,0,0,0,1,0,0,0,0,0,0,
fin.,,,0,0,0,0,0,,0,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
,,,,,,,,,,,0,0,0,0,0,0,0,0,0,0,
"<0,0,0,0,1,0,0,0,0,0>",ID3,"When you change something there may be a risk for side effects that is why I am weary to trust the tool and using it. [1:42:46]
I: It sounds like you are unlikely to trust the tool?
That is too strong a statement. If it is small changes I can just do it by hand. If I am wasting too much time then I would do it. [1:43:29]","Reflection
Efficient
 (“If I am wasting too much time then I would do it.”)"
"<0,0,0,0,1,1,1,1,0,0>",ID3,"I just did.
I: Yes manually. Did you consider checking the refactoring menu. [1:49:46] Why did you not consider using it?
So I would inline this into this.. How would I do this? I have never used this before. Here is the refactoring menu. So it says it has 20 occurrances. What do I even do here? This is like - this is not even the function it is usages of it? Will this change the invocation? This is not what I want. This is already discouraging me from pursuing it forward. Only if I discover that what I want to do is impossible or taking too long then I would research.","Invocation
Not Predictable
 (“What do I even do here”)
 Not Satisfaction 
 (“already discouraging me from pursuing it forward”)
 Not Effective 
 (“This is not what I want. “)
 Efficient 
 (“Only if I discover that what I want to do is..taking too long”)"
"<1,0,1,1,1,0,0,0,0,0>",ID4,"I see. Honestly probably because I didn't really know that one. It looks familiar because I've seen it but I've never used it.
I: You didn't know what it did?
...know.. I've seen it but I didn't know what it did. But that sounds way more useful and I probably should have used that because that is actually expanding the call like paste in does. I think it depends for me the more automagical it gets the less I trust it. To me Rename is simple. I like Rename I can quickly Rename I can see what is Renamed et cetera.
I: What is simple with it?
It is effectively a very specialized find-and-replace - I guess they all are. To me it just feels like it doesn't do anything - it doesn't feel super fancy. Like compared to this method signature one where it changed a lot of different places - maybe because I'm just more familiar with it but it just seems more - I guess it's because it's more similar to .. I'm not sure.. why do I ..","Reflection
Trust
 Efficient (“quickly”)
 Satisfaction (“like”)
 Predictable (“see what is Renamed”)Reflection
Predictable
 (“it doesn't feel super fancy. Like compared to this method signature one where it changed a lot of different places”)"
"<1,1,1,0,1,0,0,0,0,0>",ID4,"Of what?
I: Of this method.
No if it is as simple as I thought it wouldn't because it'll say return but then it will be the first like of the method. But I guess I don't know what intelliJ ..
Inline and remove the method inline all and keep the method inline this only and keep the method. So ah to me what happens is I feel like this .. I wonder maybe it's my personal experience but we're not really taught this particular terminology. Either that or I didn't pay attention in class. But to me it's like - for example when I was asked in the questionnaire about more formal refactoring I guess it's like when I was taught design patterns I was like what are these things and it sounded more daunting then I was shown it and I was like ah and now I can use design patterns because I've learned the vocabulary. But it's not something I would have done ahead of time. And I think these refactoring patterns because I'm sure people talk about them but I haven't learned them in a course in university and I'm sure that's probably why. But I'm not sure. When I'm seeing this I'm trying to infer what it means by inline all remove the method inline all keep the method inline this and keep the method. I'm assuming inline all remove the method means find everything that matches this type of inline and remove it inline all and remove the method it's straightforward it's going to remove the method that this is calling so it's going to remove readField and inline this means that I'm going to inline this particular occurrences. I have a feel that it's just going to replace everything and return the end of the same inline field but we'll see.
[1:36:20] What did I press? I just pressed undo by the way. Yeah inline keep the method there is no preview but.. Uh.. what did it call beforehand? field and target. Oh yeah looks like it worked quite well.
I: So now you just undid?
Yeah I just undid because I wanted to see what the difference was. This is literally just me playing around with it trying to see what it's doing.
I: So you wanted to go back in order to go back in order to compare this with the result of yor refactoring.
Yeah and obviously I want to see what this method does. yeah so it literally just replaced it. Huh. That is quite useful. That would have saved me a lot of time.
I: Do you think you would have used that?
Yes because I feel like inline now that I'm understanding it it looks simple enough that yeah I would have probably done that if I knew that this tool existed then yeah","Invocation
Predictable (describes what they each do)Invocation
Effective (“worked quite well”)Reflection
Efficient (“saved me a lot of time”)Reflection
Satisfaction"
"<0,0,0,0,1,0,0,0,0,0>",ID4,"What was the question?
I: I was askind about what you were willing to sacrifise and I was trying to understand the tradeoff
I'm willing to sacrifise some correctness if I have other things that can help me like - if it's something that is very rote very repetitive and it's super fast I would be ok as long as I've other tools in place to show it's incorrectness I'd be like sure this is incorrect.","Reflection
Efficient("" if it's something that is very rote very repetitive and it's super fast "")"
"<0,0,0,0,1,0,0,0,0,0>",ID5,"Based on the name. The name was something like test forceacces writeField. Like, everything that had forceaccess in it could be removed. [1:14:59]
I: You looked at the refactoring menu. What made you look at the refactoring menu and not at the other tasks?
I felt like it would be a lot more work to remove this manually. There might be a lot of other places that use the method, and I would not want to manually delete or change the method call there.","Reflection
Efficient (“a lot more work to remove this manually”)"
"<1,1,0,0,1,0,0,0,0,0>",ID7,"The IDE refactoring tools I used a lot in Eclipse were all scoped to the class I was working on. If I created new classes I tended to do it manually.
I: Why?
When I started out, I didn't use any ref tools cause I didn't know they existed. For the tools scoped to a single class, like rearranging method signatures, extracting constants, fields, variables, those kinds of operations, I felt like I got an immediate boost in productivity by using them and they were very predictable. It was obvious just from looking at what it said it was going to do, I click on it and it does it, it did what I would have done manually, and it did it faster. For any refactoring that was more complex than those, maybe I did it once or twice, it didn't do what I envisioned that it would do, so I had a miss of expectations there, and it didn't increase my productivity, it got in my way, by doing something I didn't want.","Reflection
Efficient (“immediate boost in productivity”)
 Predictable (“they were very predictable”)
 Effective (“it did what I would have done manually”)"
"<0,0,0,0,1,0,0,0,0,0>",ID7,"I remember a specific workflow I dealt with quite a bit was .. there is like a convert variable to field refactoring, which I've used mostly in tests a lot. Often you'll have tests set up code, and so you'll have 30 tests and 25 of them initialise some variable and use it, and so you're like, ok, they're initialising it mostly to the same value probably, so you extract it to a field, and the tests that don't use it don't use it, whatever, and you save 20 lines of code. so In doing that I found that I wanted to for example move the actual assignment of that value into a before-block or something like this, and the refactoring tools weren't aware of that I was doing this as part of a junit test that had beforeEach blocks, so it didn't reason about that. So I'd have to do that kind of cleanup after. What I'd really wanted to do, is to turn this variable into a field, initialise it somewhere else - because that's maybe the pattern in this class is everything is being initialised in the beforeblock instead of as the fields, and so it didn't always have - like the ref tool of course is not 'intelligent', it doesn't have all the context and it doesn't know what I'm going to do, so sometimes they would slip there as well.
I: Did you expect the tool to behave differently because you were in the context of a test?
It wasn't an expectation, but it was an aknowledgement that .. I never expected it to do exactly what I wanted, but it was close enough, like it would do the first 80% of the work and then I would do the last 20% of the work. I was never like, ah, Eclipse why didn't you do exactly what I wanted - except in the case for that class refactoring where I didn't understand what it was trying to do; if I had taken the time to understand what it was trying to do I probably would have found a use for it, but it never felt necessary to do so.","Reflection
Efficient 
 (“it would do the first 80% of the work and then I would do the last 20%”)"
"<1,0,0,0,1,0,0,0,0,0>",ID8,"Yes
I: Move method?
Not so much. I don't think I move methods that often. And I don't use the other ones that often so I don't know how they work. It can take just as long to figure out what it is going to do or how it does it, and I don't know what it's doing.. Not familiarity. Usually when I am refactoring, it is not easy. It is a complicated thing. It's more like the any-not-any-is-not. Stuff like that, where I have to think it out, and I'm changing something. Usually the refactoring..it is closer to rewriting than to refactoring. You know, it's like, we're not using a list, we need a queue. So now we put a queue in there. So there is more semantic changes, and no tool is going to .. I'll need to look through it. I have to look through it. Unless it showed me exactly what it was doing so I could look through that - that would be ok.","Reflection
Efficient 
 (“It can take just as long to figure out what it is going to do or how it does it”)
 Predictable (“Unless it showed me exactly what it was doing so I could look through that”)"
"<0,0,0,0,1,0,0,0,0,0>",ID9,"Using copy-paste trusting that my IDE would automatically manage my imports for me.
I: You indicated that you wanted to refactor-move them but ended up copy-pasting.
The more complicated the operation the more likely I would be to use the IDE's tools. Because the methods were not related to any other code it was more efficient to move them all at once. I think refactor-move lets you select multiple but it's just unnecessary when methods are independent.","Reflection
Efficient"
"<1,0,1,0,1,0,0,0,0,0>",ID9,"Yes because I could see that the method was right here. The two argument version.
I: So the refactoring did break the code but it was what you expected nonetheless.
Yes it was more helpful for the refactoring to result in code that did not compile than to say I can not do that.
I: how come?
It was more in line with the change I would have done manually. I would make the change, see that there was an in-collision and then resolve the collision. Asking me to modify unrelated code in order to delete the unrelated code feels like an extra step.","Reflection
Predictable
 Satisfaction 
 (“it was more helpful for the refactoring to result in code that did not compile than to say I can not do that. “)Reflection
Efficient (“Asking me to modify unrelated code in order to delete the unrelated code feels like an extra step.”)"
"<0,0,0,0,1,0,0,0,0,1>",ID9,"But I want both.
I: Can't you just click this..
But it's the speed of doing it. It's like is it going to be faster for me to use the tool with it's default and fix the things it get wrong or use the tool and it gets everythign right or do it by hand.
Several layers further down there's use the tool and click checkboxes to make it right. It really depends on the refactoring. I think that particularly is one I encounter a lot. It is more common in less well-scoped or less strongly typed code. Where the thing you want to rename is less clear.
I: It almost turns into find and replace.
Yes. Which I could do by hand if I wanted. I think another place where manual tools win are if you have - like trying to do transformations on things that are sort of code but not really like typically if you've got a bunch of constants or a static block of repetitive code I could try to use refactoring tools to change the signature or .. but it's faster to just find and replace or multi-cursor the new parameter where I want it because I know that there is some regularity in the structure I'm trying to transform that may not be apparent to an automated refactoring tool. [1:20:58]","Reflection
Efficient (“the speed of doing it”)Reflection
Not Efficient(“I could try to use refactoring tools to change the signature or .. but it's faster to just find and replace”)"
"<1,1,0,1,1,0,0,0,0,0>",ID9,"I: You mentioned trust as an aspect of these tools. What are some example of cases in which you don't trust the tools?
In my work I typically work in typescript and I know that the find references tool does not find all references so I know that any automated refactoring will miss some call sites. Sometimes it's still worth it to use the refactoring tool and find the remaining call sites myself but I know that I need to do my own search after to either verify or complete the remained of the transformation.
It is really a tool specific thing that if you know the tool well enough you recognize the bugs and you know you will hit them again. And maybe you stop using the tool. I don't have any big dogmatic that I don't trust the tool to do X it is just that over the years of using refactoring tools I've known there to be buggy tools I've seen them.
I: And you kept using them?
I kept using them. Because they are much faster than doing it by hand.
I: Which refactorings do you usually use them for?
The most common one is adjust method signature. Like reordering method parameters. Like that is trivial. I trust the tool to do it and it is a lot of work to do by hand. Or introduce a new parameter. If I can introduce a default parameter to all callsites. Maybe I have to go through and see what the real value is at each call site but the tool has identified the callsites for me and has injected a marker for you need to do some work here.","Reflection
Predictable (“if you know the tool well enough you recognize the bugs and you know you will hit them again”)Reflection
EfficientReflection
Trust 
 Effective 
 Efficient"
"<1,0,0,0,1,0,0,0,0,0>",ID10,"[1:57:30] Yeah. For example IntelliJs git plugin has a phenomenal ability to resolve differences, like better than git. But sometimes it's guessing using heuristics, like complicated machine learning magic I'm sure, and I know that when I turn to that particular tool it is actually a little less certain, only because the other tool git, didn't do it. So like because turning to the more sophisticated, more heuristic based tool, I know that I might not get the change that I want. Like, when these are merged together it might not be done right, whereas git will only do it if it knows it's right.
I: So in which cases do you choose to use refactoring tools and when do you choose not to use them?
[1:59:20] When I know the keyboard shortcuts. Extraction and inlining are awesome because I have easy keyboard shortcuts for extracting a constant versus a field versus a method versus a variable, as far as the IntelliJ’s shortcuts have no mnemonics going for them, these are some of the few where it has so it's easily to reach for them. That aside, the refactoring tool isn't that far off. Some of it is knowing what the refactoring is going to do. Like, when it says push IDT in, I don't what that is. and like, I've spent five years as a consultant teaching people how to program better, so I'm used to knowing this particular tool well, and introducing people to like refactorings and the notion that a refactoring is a small change of layout without a change of behavior and if you say that you're spending three weeks refactoring the codebase you're probably rewriting the codebase, and you're using the word refactoring. So, When would I look at an automated tool versus doing it myself, is familiarity with the tool, I know what it's going to do, I know the situations in which I am going to use it well?","Reflection
Efficient 
 (“Extraction and inlining are awesome because I have easy keyboard shortcuts”)
 Predictable 
 (“knowing what the refactoring is going to do.”)"
"<0,0,0,0,1,1,0,1,0,0>",ID11,"It is a process. I understand the code when I am doing this. If I have a tool that just does it for me - do I really know that it found everything? I am not sure. [1:15:44]
I would probably still be checking. Maybe it would be helpful. This took like, what, half an hour, so that could be done instantly maybe. [1:15:57]
But then I just spend the rest of the time verifying. Maybe there are time savings? There probably are time savings. Part of being a developer is figuring out how things work. I actually enjoy this stuff so it would be kind of taking the joy out of my job if I do stuff like that. You will probably get different answers from anyone else I guess.","Reflection
Not Predictable 
 (“But then I just spend the rest of the time verifying. “)
 Efficient 
 (“There probably are time savings”)
 Not Satisfaction
 (“it would be kind of taking the joy out of my job”)"
"<0,0,0,0,1,0,0,0,0,0>",ID11,"Nope. I have never used any tools for automated refactorings?
I: Why do you avoid using them?
I have never used them. I am not sure there is any one reason why. I am unsure how much time it would save me. It is something for me to look into I guess. These types of changes are fairy simple and doesn't really come up a lot. Task 3 I can see coming up. Task 2 would never come up. Task 1 this happens a lot moving stuff around.","Reflection
Efficient
 (“how much time it would save me”)"
"<0,1,0,0,1,0,0,1,0,0>",ID14,"I found those test methods and created a new class for them to go into, and I just resort to copy-paste them in, I did not take advantage of the refactoring tools.
I: You tried though?
I did try them, in a lot of cases they help. There is a small set of refactoring tools that I often like renaming variables and method signatures, classes, changing visibility. That's nice, in that you can make a change in one place, and it will find all the other references to that in other places and update them. It is tedious to do that by hand. Things break and whatnot.
Whereas, in this case, with tests they're not referenced anywhere - like you can just remove it and no one will know the difference - the only difference would be in imports, if they were only used by certain tests, but that's just a file level change. But multifile can take some digging around.
I: How does that impact your choice to use refactoring tools?
In this case the tools weren't adequate for what I wanted. So I'll just avoid that in the future.","Reflection
Effective (“it will find all the other references to that in other places and update them”) 
 Efficient (”tedious to do that by hand”)
Reflection
Not Satisfaction (“the tools weren't adequate for what I wanted”)"
"<0,1,0,0,1,0,0,0,0,0>",ID14,"There's no loop here. I think we can refactor this functionality so we don't have .. that would just make my other inlining easier..
I: Can you explain what you mean? [1:29:21]
I tried to inline this one, and it gave me the - doesn't like - because of the return statement interrupting the execution flow, which because of the previous experience I have a better understanding of what that means. So like this return statement here, in, I guess the middle of the code, makes it more difficult to refactor, so I'm wondering if I can refactor it like I proposed earlier and see if that would allow me to inline this function. I don't need to do that this, in this case it would be faster to just go for it, but I'm thinking that if I learn this part of the tool, this I guess minor refactoring, that would help me more in the long term.
I: What would usually impact your decision to approach the intermediate refactoring, or do it by hand?
Time, is the short answer. If three refactorings takes longer than modifying two or three lines, then I'll just modify them.","Invocation
Effective (""in this case it would be faster to just go for it”)
Invocation
Efficient(""If three refactorings takes longer than modifying two or three lines, then I'll just modify them."")"
"<0,0,0,0,1,0,0,1,0,0>",ID15,"Yes again just like eclipse it would help me extract things to a variable which is great but not something that would help me with the depth of the task I am doing. Change signature might help me - but it would change the signature of the method that I would want and what I would really want is to move things from one method to another. Like in fieldUtils I moved things from the read method with the parameter to the read method without the parameter and that I don't know if that would help me a lot in this case. But again - these tools are useful but in coding you have to just do things that your environment will not really do for you. [1:42:08]
I: Do you find that they usually don't actually solve your task?
Yes they are useful in some way and they save some time but when you are doing actual refactoring these tools are helpful in a way but they don't really get you to the point where you are done with this task.","Reflection
Efficient (“they save some time”)
 Not Satisfaction(“don’t really get you to the point where you are done with this task” )"
"<1,0,0,0,1,0,0,0,0,0>",ID19,"But of course it depends again on what I'm trying to do. I've never checked if there is a way to remove arguments. I'll just go ahead with change method signature and see if I can remove.
I'm going to go ahead and preview this time, because there is a preview button and that should tell me exactly what's going on.
There is already another method that way, which means that - it may actually - it will collide - what I'll do in a lot of cases is go back and see what does that one do. It just sets it to false. Something that - I'd take two different approaches is to delete this method right off the bat. Another is kind of similar to what I did in the last one. But in this case I'll go ahead and delete this, and try to use the refactoring tool. I want to see what happens from it. With something like this it can be a lot easier with a refactoring tool to help remove some of that.
I: Why is that?
Kind of back to the same, understanding to happen. When I go ahead and do this, in the preview here I can see some of what's going on, and it's not necessarily just breaking it, it's kind of seeing it in different ways. Like when I break things and go and look at the errors, I should be able to get some of the same context here. Instead of having to manually delete everything by hand. And we'll kind of see what state it gets us into. I'll ignore the error and continue, because I can come back and fix the logic in that. It's more interesting about all the different places that has that changed.","Invocation
Efficient (""it can be a lot easier with a refactoring tool“)
Invocation
Predictable (“in the preview here I can see some of what's going on”)"
"<0,0,0,0,1,0,0,1,0,0>",ID19,"If it wasn't all individual methods, if it was encapsulated in a class, it's much easier to remove it, because you can just delete that one variable and just clean up the appropriate logic. It is a different visibility to knowing that an entire object was doing that forceaccess, so when you're looking at the tests you can look for ones that are instantiating the object with the specific code instead. Maybe it's not anything different int he tooling per se, but it change the way you look at it and understand the impact of your changes.
I: You used change signature refactoring and the global git view. Why did you choose to use those particular tools?
I chose to use the change signature because it was easier instead of going through everything and change everything. The git diff was because I knew I broke something and I needed to find out what. I broke something not directly related to the refactoring, but as part of the changes I did as part of the change to the logic. Using the git view is hugely beneficial [for that].
I: How did you find the usage of change signature, did it do what you wanted?
Not completely. I think if I'd played a little more I could have excluded part of the refactoring. I'd like to say I want to go ahead with the refactoring in this area and not in this area, because if I could exclude the tests I could better see the impact of what tests are actually broken. But you want to have the proper changes done inside the code.","Reflection
Efficient (""it was easier instead of going through everything”)
Reflection
Not Satisfaction (""Not completely.”)"
"<0,0,0,0,1,0,0,0,0,0>",ID19,"What tests were removed. None of the tests I removed were kind of necessarily wrong - but whether there should be more tests removed, or .. one of the tests I took out was passing, and shouldn't..might not be right as it should be passing.
I: Can you elaborate on why you choose to use the change signature tool on this task.
Seeing the preview and liking to playing with tools. For this one it made it a little easier, because it was able to update all the tests, because any that passed in false as well was updated. That means that there may be duplicate code, because one may pass with false and one with true, but it was able to kind of update the core of the tests as well as all the internal calls. For all the passthroughs.","Reflection
Efficient (“made it a little easier”)"
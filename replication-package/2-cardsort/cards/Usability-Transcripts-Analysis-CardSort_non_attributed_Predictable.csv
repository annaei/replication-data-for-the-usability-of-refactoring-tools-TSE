,,,,"User Generalized, Tool Not ",Not enough info in UI,Incomprehensible error messages,preview with implications ,review and convince,adjust changes ,No alternatives,Duplicates,"Control Sum
(79 total - 27 discarded + duplicates)","User Generalized, Tool Not ",Not enough info in UI,Incomprehensible error messages,preview with implications ,review and convince,adjust changes ,No alternatives,Sorting
,,,,2,9,6,16,15,11,1,8,60,ID2ID8,ID2ID7ID3ID4ID8ID10,ID2ID7ID10ID14,ID2ID4ID10ID13ID14ID16ID18ID19,ID2ID4ID7ID8ID9ID10ID11ID12ID14ID19,ID4ID6ID7ID8ID9,ID16,
"<1,1,1,0,1>",ID2,"It's located in a read only container.
So at this point when you get an error like that it's like this is useless I don't know what to do with it. Am I actually going to go in there and start figuring out why JUnit-Assert-class is located... what. That's not helpful at all.
So even if I .. maybe if I just do this. And this is the thing once you try this a few times .. Oh there that's better. Then now it's like .. what am I moving am I moving the entire class? That's not what I want. Extract? Oh that didn't work. Extract .. Method? Well that's not what I want either. 'Cause that implies you just got a small section of code
At this point I'm like well I've got four more methods why don't I just move them? So what's the point. Unless I've been trained specifically on how to use these things. Let's see if this is actually going to work. This may fail because again it's a different file I'm pulling it from. What that's not what I want this is what I want. Let's see what happens now. Interesting what's happening here. Uuh cannot resolve foo. Now this is challenging. Ok where is foo defined oh here is foo. Who wrote this code seriously. Should not be using foo as a variable name. Now the question is I'll put this a the top here even though it's actually not used by any of the top tests this should actually work. Looks like it work. Run it. Done. Ok so I need isNotEmpty and isNotBlank and isBlank. Blank and isNotBlank. I'm having mouse issues.","Invocation
Not Predictable
 (“what am I moving am I moving the entire class?”)
 Not Satisfaction
 (“Not what I want”)
 Not Effective
 (“that didn't work”)Invocation
Not Efficient
 (“I've got four more methods why don't I just move them”)",1,1,1,,,,,2,,ID2,ID2,ID2,,,,,1
"<1,0,0,0,0>",ID7,"Alright, so StringUtils use them and they are used in the tests. Check isAnyNotBlank, find usages, and again, only referenced in StringUtils, In one spot for the negation, and in the tests. So now my plan is, I'm going to delete the tests, and then I'm just going to delelete the isAnyNot-methods, and then they'll be inlined into the isAll-methods, and then I think I'm done. Alright, so we have my empty and blankTest and any empty, just delete the anyNotEmpty. nd anyNotBlank. Now all .. will this rerun my find? Oh look at that, that's cute
Now I can see they're only used in stringutils. So now I can inline this.
Ah, not supported when return statement interrupts execution flow. I don't know what that means. But I'm guessing it's because this [!] is here. So what I'm going to do is extract this get a result value and then I'll probably be able to inline this.","Invocation
Not Predictable (“I don’t know what this means”)",,1,1,,,,,1,,,ID7,ID7,,,,,27
"<1,0,0,0,0>",ID2,"Yeah I have done this one before!
I: This is still not going to work but for stupid reasons.
Now it thinks it's an instance method and want to do move to component which nobody these days knows what is.","Reflection
Not Predictable
 (“move to component which nobody these days knows what is”)",,,1,,,,,0,,,,ID2,,,,,2
"<1,1,0,0,0>",ID10,"I: Yes sure, you are not in any way bound to the plan you made.
No. Silly.
Uhm, I don't really want to make this static. But this also gives me nothing. Ah, ok sad.
I'll make a new Java class I guess then. StringUtils - let's call it empty and blank. Unit tests for methods of StringUtils which been moved to their own test classes. Ok. Cool.
So then, heck, if what I want to do isn't working well, let's move it. Let me move it correctly here.
Great. Cool. So that isAnyNotEmpty. Let's go for isAnyEmpty. I don't really know what these comments are going for here. No, that's not really. Maybe you need a testing constructor. No sorry. What I want to do. I should be able to move it.
I: What did you expect this move refactoring to do here?
That's a great question. I would expect that move refactoring to be able to move an instance methods between two classes. And when it's talking about like, all candidate variables have types that are not in the project, I don't really know it means by candidate variables.","Invocation
Not Effective (“I don't really want to make this static. But this also gives me nothing.”)Invocation
Not Predictable 
 (“I don't really know it means by candidate variables. “)",,,1,,,,,0,,,,ID10,,,,,40
"<1,0,1,0,0>",ID10,"By going through the structure of the test.
And I see that there's still a whole bunch of orange sad marks here, but there's nothing red, so it still compiles. at the very least. Lest go to the top of the file and hit ctrl + shift + r to run the tests. It's compiling everything ... that's all fine and dandy. it's going to complain about - can be private, I'm sure that's fine, and stuff that's never used.
Ah, really? I would have expected it to say, I could remove all the unused things for you, but I don't see that there. No. Ok. Well, before I do that, I'm going to take a look at the StringUtilsEmptyTrimTest. Test one - let me not make the same mistake again. What kind of stuff do we have in here. [20:11] Type migration, make static. No. That's really frustrating.
I: Why is that frustrating?
The - again I don't really know what it means when it says candidate variables. Having the different types that aren't in the project, that doesn't mean too much to me. Like, I understand the thing about the type in theory, but what types are in the project. [21:14] Making it static and then moving it - like sure, let's try this. Sure. But I don't need it to be a static method. Okay, so, let me - before I make any changes there, let me be happy with my brand new file there. I know there are some trailing whitespaces they were already there. Ok.","Invocation
Not Satisfaction (“That's really frustrating.”)Invocation
Not Predictable (“I don't really know what it means”)",,,1,,,,,0,,,,ID10,,,,,41
"<1,0,0,0,0>",ID14,"Inline method is not supported when return statement interrups execution flow. What. Well I can do two refactorings then. I'll make a local variable.
I: Can you please explain what happened when you tried to locate it and why you're doing this now.
It gave me an error message which said that it cannot refactor it when it's part of the return statement. Which is bizarre to me.","Invocation
Not Predictable (""Which is bizarre to me.“)",,,1,,,,,0,,,,ID14,,,,,59
"<1,1,1,0,1>",ID3,"I just did.
I: Yes manually. Did you consider checking the refactoring menu. [1:49:46] Why did you not consider using it?
So I would inline this into this.. How would I do this? I have never used this before. Here is the refactoring menu. So it says it has 20 occurrances. What do I even do here? This is like - this is not even the function it is usages of it? Will this change the invocation? This is not what I want. This is already discouraging me from pursuing it forward. Only if I discover that what I want to do is impossible or taking too long then I would research.","Invocation
Not Predictable
 (“What do I even do here”)
 Not Satisfaction 
 (“already discouraging me from pursuing it forward”)
 Not Effective 
 (“This is not what I want. “)
 Efficient 
 (“Only if I discover that what I want to do is..taking too long”)",,1,,,,,,0,,,ID3,,,,,,7
"<1,1,0,1,0>",ID4,"I'll be honest I've never used this. I guess I've used something similar in Eclipse. Remember I said I've self-confessed ludite tendencies like because I don't know the tool I might actually just - oh there's a preview. What happens if I just remove this?
I: You can remove it through the minus sign here.
So what happens if I remove this? The problem is that it's already defined - ah of course we already have oh by the way I'll admit straight up I'm biased to look at this tool because I'm self-aware of being in a study of refactoring tools.
I: So you wouldn't normally have looked at it?
I might have if a co-worker had shown it to me. I think the thing with IDEs the reason I do some of this stuff in Eclipse is because I was shown some of these things when I was an intern. The fact that I've never had anyone sit me down and and say - I guess I've never devoted time at work that I should sit down and learn my IDE. It's mostly just let's get this done. I guess I've just used an approach that works.
Anyway. I feel like what's going to happen is what I'd do is just delete this method now then I know that some times with certain IDEs I am not sure if I remove a method it might complain somewhere else and it might not let me refactor if there already is compile issues.
I: So what was you original plan you want to remove..
What I'll do is I'll just remove this instead of running refactor I'll just remove it and just look myself. I guess I just trust what I can see.","Invocation
Predictable
 (“what happens if I remove this? The problem is that it's already defined“)Invocation
Not Effective 
 (“it might not let me refactor”)Invocation
Not Trust",,1,,,,,,0,,,ID4,,,,,,8
"<1,0,1,1,1>",ID4,"I see. Honestly probably because I didn't really know that one. It looks familiar because I've seen it but I've never used it.
I: You didn't know what it did?
...know.. I've seen it but I didn't know what it did. But that sounds way more useful and I probably should have used that because that is actually expanding the call like paste in does. I think it depends for me the more automagical it gets the less I trust it. To me Rename is simple. I like Rename I can quickly Rename I can see what is Renamed et cetera.
I: What is simple with it?
It is effectively a very specialized find-and-replace - I guess they all are. To me it just feels like it doesn't do anything - it doesn't feel super fancy. Like compared to this method signature one where it changed a lot of different places - maybe because I'm just more familiar with it but it just seems more - I guess it's because it's more similar to .. I'm not sure.. why do I ..","Reflection
Trust
 Efficient (“quickly”)
 Satisfaction (“like”)
 Predictable (“see what is Renamed”)Reflection
Predictable
 (“it doesn't feel super fancy. Like compared to this method signature one where it changed a lot of different places”)",,1,,,,,,0,,,ID4,,,,,,11
"<1,1,1,0,1>",ID4,"Of what?
I: Of this method.
No if it is as simple as I thought it wouldn't because it'll say return but then it will be the first like of the method. But I guess I don't know what intelliJ ..
Inline and remove the method inline all and keep the method inline this only and keep the method. So ah to me what happens is I feel like this .. I wonder maybe it's my personal experience but we're not really taught this particular terminology. Either that or I didn't pay attention in class. But to me it's like - for example when I was asked in the questionnaire about more formal refactoring I guess it's like when I was taught design patterns I was like what are these things and it sounded more daunting then I was shown it and I was like ah and now I can use design patterns because I've learned the vocabulary. But it's not something I would have done ahead of time. And I think these refactoring patterns because I'm sure people talk about them but I haven't learned them in a course in university and I'm sure that's probably why. But I'm not sure. When I'm seeing this I'm trying to infer what it means by inline all remove the method inline all keep the method inline this and keep the method. I'm assuming inline all remove the method means find everything that matches this type of inline and remove it inline all and remove the method it's straightforward it's going to remove the method that this is calling so it's going to remove readField and inline this means that I'm going to inline this particular occurrences. I have a feel that it's just going to replace everything and return the end of the same inline field but we'll see.
[1:36:20] What did I press? I just pressed undo by the way. Yeah inline keep the method there is no preview but.. Uh.. what did it call beforehand? field and target. Oh yeah looks like it worked quite well.
I: So now you just undid?
Yeah I just undid because I wanted to see what the difference was. This is literally just me playing around with it trying to see what it's doing.
I: So you wanted to go back in order to go back in order to compare this with the result of yor refactoring.
Yeah and obviously I want to see what this method does. yeah so it literally just replaced it. Huh. That is quite useful. That would have saved me a lot of time.
I: Do you think you would have used that?
Yes because I feel like inline now that I'm understanding it it looks simple enough that yeah I would have probably done that if I knew that this tool existed then yeah","Invocation
Predictable (describes what they each do)Invocation
Effective (“worked quite well”)Reflection
Efficient (“saved me a lot of time”)Reflection
Satisfaction",,1,,,,,,0,,,ID4,,,,,,12
"<1,0,0,0,0>",ID7,"Kind of more, broadly in the context of any tool, if there is a butten that says it's going to do something - of course it is going to be extremely brief in what it's going to communicate to me: it will just say ELV, or you know, convert variable to field, and I read that text, and I form in my mind an idea of what's going to actually happen; 'cause it's not going to actually say, extract the text to this line, and trunkate this part of it, or whatever; it's not going to describe it precisely because that would be ridiculous - so I have to form an idea of what it's going to do, and then if I invoke that action and it does exactly what I expect it to do, then I'm happy, because it was predictable in a way; but really what that means is, i was able to predict it. The predictability is a communication process, so it's not necessarily the case that something was unpredictable, it's that I failed to predict it. And if I consistently fail to predict what an action will do, I'm not going to want to use it.
I: In the case of your tests, you'd looked up the refactoring menu and you found this Move action, what would you predict that it does in this context?
I'm actually not sure, because it just says Move. it doesn't say move to a different cass.. for all I know that could just reorder the methods textually int he class. My prediction is that it would prompt me for a class to move it to, and then it would attempt to move it, and that attempt may succeed or fail depending on what the method is referencing. So it may prompt me for additional action in a failure case there. But I'm not that confident in that prediction. I found that because we were talking and maybe something could have done that for me, so I'd try it out and if it was something entirely different I'd probably never try it again.","Reflection
Not Predictable (“I’m actually not sure”)",,1,,,,,,0,,,ID7,,,,,,26
"<1,1,1,0,0>",ID8,"Just making sure those are specifically the ones I want. I don't need to check for more? et's see if these can be moved in bulk. I don't know if I can highlight more than one. [12:44]
I: Would you usually go and check that, or is it because of the refactoring study?
I don't know if I can do multiple at a time, what I might do is move one and then cut and paste the others. Eclipse is pretty good at pulling junk out. Type is not in project make static and move - no, I don't want that. So I guess I can't move. [13:35]
I: Did you notice that it was called move instance method?
Hmm
I: Do you know what this means?
No. I know what an instance method is but I don't know why it want to make it static. There are no variables. Foo is static. Right. [14:22]","Invocation
Not Satisfaction (
 (“no, I don't want that.”)
 Not Effective 
 (“I guess I can't move.”)Invocation
Not Predictable (“I don't know why it want to make it static.”)",1,1,,,,,,1,,ID8,ID8,,,,,,31
"<1,1,1,0,0>",ID10,"If I were to - I chose to delegate and I chose to preview here. I could show the conflicts in the view. I know where this is used in the method and I know that is this already defined in the class. If I click continue. What .. I wouldn't have considered clicking continue in that case.
I: Why?
It tells me that there are problems, which leads me to believe it is not able to do it.
So like, here, there is the method, with the signature that needs to be changed. And then there is the, uh, unclassified usage, sure, one usage in one file. But let me try it, let's se what the heck happens. Ok, this is an ambiguous call, of course. Why did it have .. Why does it have a forceAccess.. What.
I want to undo this and see what's going on here. Oh weird what. Why is it even. Ok.
So it changed the two methods in a way that I didn't expect, it feels bonkers. Right, cause you have a method that has getField with two parameters and one with three parameters. And when I say, I'm fine with the problems, deal with them for me. I still end up with two methods. But the three version is on top and the two version is on bottom.
I don't need this at all. This being a getField that takes a forceAccess. I don't need to delegate to getField, that's fine.
So this is a relatively simple manual cleanup that I could do. I just need to continue here. And there is another manual cleanup where this getField was taking. Oh wait, did I have three getFields? I ended up with three getFields. So the changing the signature ended up making a third method instead of changing my two, but the scroll position didn't change or give met any indication. Ok, that's delightfully bonkers. So now I have a getField-method.","Invocation
Not Effective (“leads me to believe it is not able to do it. “)Invocation
Not Predictable (“it changed the two methods in a way that I didn't expect”)Invocation
Not Effective (""I don't need this at all.”)Invocation
Not Predictable 
 Not Satisfaction (“bonkers”)",,1,,,,,,0,,,ID10,,,,,,47
"<1,0,0,0,0>",ID2,"There was a challenge with the overloading so I had to through and find the right one to delete. I messed that up at one point I deleted the wrong one. That was tricky. At some point because I didn't see the errors on the bar on the right hand side I went to the tests and they wouldn't compile. Again I had to remove things. [1:03:32]
I think there were a couple of places where I looked at the code saw that I'm removing the reference to forceaccess and well two or three lines can be removed because they're not doing anything anyway. Removing a parameter is a big deal. [1:03:56]
That would be a cool refactoring if you could automate it. Show me the implications of removing it.","Reflection
Predictable (“implications of removing it”)",,,,1,,,,0,,,,,ID2,,,,3
"<1,1,0,1,0>",ID2,"No. I guess it's interesting I don't even go to the refactoring menu. I think it is too complicated for a tool to automate so I don't even try. [1:07:21]
I: If a tool could automate it
If I knew about it! It's an education thing these things may sit in my IDE for years and I don't know what half this stuff is. Unless I was trained on it read a blogpost on it. These things doesn't happen enough. This particular example I do remember at least once actually more than that. Maybe every six months I deal with a situation like this. But is it worth learning a refactoring tool that you don't 100% trust when you can just do it manually. [1:07:45]
I: What do you mean by trust?
How do I know, like it's going to make the change and I need to go and review the change carefully and convince myself it made the right change.
I: What could go wrong?
It could incorrectly change the logic. Well it can't miss something - no it could. It may not remove all cases of forceaccess it may just remove some. It may change the logic incorrectly. Tools aren't perfect and we shouldn't trust that they are. That being said I do trust the IDE to underline things I've put a lot of trust in that. [1:08:35]","Reflection
Not TrustReflection
Not Predictable
 (“I need to go and review the change carefully”)Reflection
Not Effective(""incorrectly change the logic"")
Not Trust",,,,,1,,,0,,,,,,ID2,,,4
"<1,1,0,1,0>",ID2,"Not so much no. Partially because I'm not in the habit of using it. I have used extract method. It is very simple it says here are the parameters go. I'm trying to remember when I last used it - it must have been Java code. [1:11:56] I've been doing scala recently but I don't think I've done it there.
I: What makes you say that it is a simple refactoring?
It's small. It's like - all I'm doing is moving this chunk down there. What it has to do is, what dependencies does it have on other things in the scope and it makes those things parameters. It is simple because I understand exactly what's going on and I feel confident about it. That's a good point. [1:12:36]
I feel confident that it is doing the right thing and I can easily look at the final code and validate that it's right.","Reflection
Predictable
 (“I understand exactly what’s going on”
 Trust
 (“I feel confident about it”)Reflection
Effective
 (“it is doing the right thing”)
 Predictable
 (“easily look at the final code and validate”)",,,,,1,,,0,,,,,,ID2,,,5
"<1,0,0,1,0>",ID2,"Yes I do that all the time. I very frequently do that, it goes through and I can confirm .. I am suspicious but again I depend on the tests. [1:13:39]
I: Would you trust a tool to reduce logic like you did? During T2 and T3 you were reversing and reducing logical operations.
I think so. If it was like in my refactor menu and it was like reducing logic or something and i could easily see that it was a contained area. I think in the simple cases it's pretty straightforward to know that you know if it's false do this if it's true continue.. but I think your refactoring tool would have to know a lot of control flow analysis in order to do that and be trustworthy. And I would want to see them side by side this is your current state and this is what you will go to. That would be trustworthy. [1:15:10]","Reflection
Predictable
 (“this is your current state and this is what you will go to.”)
 Trust",,,,,1,,,0,,,,,,ID2,,,6
"<1,1,1,0,1>",ID4,"parameter forceaccess is used in methodbody. Oh it's saying it's used somewhere - wait - what's that trying to say? Oh it's saying it's used - but that's fine; I'm going to do this and it's going to complain and I'm ok with that. Because I realise that there's no way to do this without something complaining. I feel like it's not going to be able to automatically remove it; besides there are some logic changes too.
Continue.
Alright!
As I mentioned there's some red stuff here. That's fine. If forceaccess set accessible true else continue. It looks like we don't actually need this which means the else is always going to be true. so the question is what does the continue do? The continue will just go back to the beginning of the forloop. I was just looking to see if I actually needed to even have this if-statement up here but it sounds fine. I think that this should be ok because what's happening is if this boolean is false we want to just continue anyway otherwise we want to just return the field. Sure that should work. Ok so now I'm surprised - I'm kinda shocked that there's not more red in here because did I automatically remove it already?
I: What do you think the tool did?
Oh it probably already renamed everything that was using this. Ugh.
I've just realized that I think one of the reasons I'm hesitant to use tools is because I don't know the full impact. If I were to look at a source control diff right now I would assume that we have some usages. There's going to be some very redundant test cases right now because they've probably been automatically renamed to use the default parameter right now. So if I were to look for getField in here ...
what'll happen is that those test cases are probably going to break.
If I hadn't used a refactoring tool and I would have just seen the red lines and known that this is exactly what I need to remove. What I'll do now is that I guess there's like a git diff thing I can use in here.","Invocation
EffectiveInvocation
Not Predictable 
 (“surprised” ..”did I automatically remove it already?”)Invocation
Not SatisfactionInvocation
Not Predictable
 (“I don't know the full impact”)Invocation
Not Efficient
 (“If I hadn't used a refactoring tool and I would have just seen the red lines and known that this is exactly what I need to remove.”)",,,,1,,,,0,,,,,ID4,,,,9
"<1,0,1,1,1>",ID4,"Well there was this intelliJ one that sort of did it but then I guess it messed with how I approached the problem so I decided not to use it.
I: So what happened there? Can you elaborate?
Yeah what happened is once I changed it I realised I - I guess in tandem with other tools I realised that I didn't actually know what was changed elsewhere like in the tests for instance. I guess it could have shown me that the tests were broken - but for me at this point with this particular task I liked using the compiler to show me where the error were. So what happened was I realized that I didn't - because I also didn't understand the previous test well enough I didn't understand what was actually changed and I had to do an external diff to compare it. To me it was easier instead of doing that to just use the visual diff of the red and do that. And that's because I found it more intuitive or I guess .. more .. less .. less reliant on other tools because I guess the java compiler is such an ubiquitous thing and I am just leveraging that.
I: It took quite a long time and it seems the tool could have done some of those changes faster?
It might have that's a thing I'm not .. 'cause I did change it and remove it but I still found I had to do some of those things manually. Based on what I did the first time around I evaluated it and I thought it was not that much faster with that I was doing. And I figured that my familiarity with my current thing would have made me just switch back to it. Is it worth it for me to use this I guess untested tool now and I decided that I'd rather just finish it up faster. I think we can conclude people are set in their ways.
I guess what happened was I was confronted with something that made me uncomfortable and made not as sure as my current process and so I decided to revert back to it. What happened once I reverted to my process I found it more intuitive and I thought it ended up being faster than the other one. Because with the other one I would have kept checking kept looking over my shoulder the entire time.
I: You would have kept looking over your shoulder.
I would have felt more than normal like I might have missed something.
I: Is that because you don't trust the tool?
Yeah a little bit. Yeah like when I used the tool I was like wait did change and I ended up having to look.
I: Did you use the preview window?
Yeah - what exactly happens - because I thought I used it and I didn't really see much. It kept taking me out of it and I thought - I think having something .. I think having like an active - instead of jumping back into the code I was expecting to see a before and after and I didn't see a diff and maybe there was one but I didn't see it and I was expecting to see a diff.","Reflection
Not Predictable
 (“didn't actually know what was changed elsewhere”)
 Not Efficient
 (“To me it was easier instead of doing that to just use the visual diff of the red and do that.”)Reflection
Not Efficient 
 (“it was not that much faster with that I was doing.”)
 Not Trust 
 (“untested tool”)Reflection
Not Satisfaction
 (“made me uncomfortable”)
 Not Efficient
 (“I reverted to my process … I thought it ended up being faster than the other one”)
 Not Trust 
 (“I would have kept checking kept looking over my shoulder the entire time. “)Reflection
Not Satisfaction 
 (“was expecting to see a before and after and I didn't see a diff”)",,,,,1,,,0,,,,,,ID4,,,10
"<1,0,0,1,0>",ID4,"I might try it like that first since I'm just starting to get comfortable with it.
I: So you talked about whether you trust the tool or not but what about predictability what does it mean to you that a tool is predictable or that you trust it?
Trust from me comes from having worked with it and understand it. Predict is more like actually like earlier when the context menu came up with three different options I think that is pretty predictable because I was like I think it's going to do this when I press this. Like rename is really predictable because it's like I'm going to rename this and I think at least in Eclipse it says I'm going to rename it here here here and here. Predictable is nice because it lets you feel in control. When something is unpredictable you don't. What happened with that method signature maybe it was the way I used it but it ended up being unpredictable and I was like I don't know what's going on and that leads to lack of trust. Predictable means that it behaves in a way that I can I guess it doesn't violate any assumptions.","Reflection
Trust
 Predictable",,,,1,,,,0,,,,,ID4,,,,13
"<1,0,1,0,0>",ID4,"Obviously I like if a tool is correct. But for me if a tool is predictable enough I can sacrifise a little correctness because if I know what it's doing I can correct it after.
I: What is an example of correctness you can sacrifice?
Like for example if that inline tool had replaced that particular text and kept the return at the top and I'd had to manually delete it I'd been fine with that because I'd have known that it just replaces everything from here and out it's like a glorified paste.","Reflection
Satisfaction(""I'd been fine with that"") 
Predictable(""I'd have known that it just replaces everything from here and out"")",,,,,,1,,0,,,,,,,ID4,,14
"<1,0,0,0,0>",ID5,"Alright. So It is used in the code, but just considered as false, so this should be good.
I: What is this telling you?
It is a bit confusing. Those are probably methods that calls the function I am currently modifying. It just shows for this function what the change would look like. [45:57]","Invocation
Not Predictable (“confusing”)
 Predictable (“It just shows for this function what the change would look like.”)",,,,,,,,0,,,,,,,,,15
"<1,0,0,0,0>",ID5,"I am looking at the forceaccess flag where it is used. I am finding multiple functions with the same name that also has the same parameters.
I: Now you deleted one and undid it.
I didn't realise it was three functions. Before it was just two so it was relatively easy to just delete one, but now there is three so I have to ..","Invocation
Not Predictable (“did not realise..”)",,,,,,,,0,,,,,,,,,16
"<1,1,0,0,0>",ID5,"Yes, it removed the parameter.
I: Was that intentional?
Yes, it is what I expected, that if I remove a parameter it would also be removed from the calls of the methods.","Reflection
Effective 
 Predictable",,,,,,,,0,,,,,,,,,17
"<1,0,1,0,0>",ID6,"It's funny because all of these things - oh This is interesting. When I moved is still pointing to the old stringutils test-file. I can remove that.
I: Did that surprise you?
It did. I wanted to move the files and I think that when I moved it from here if there is a variable here with the same name maybe it would fetch the reference from here rather than from the old file. I understand that it's trying to not break my code. But then it starts to add dependencies between that I don't want.","Invocation
Not Predictable (“It did”)
 Not Satisfaction(“…that I don’t want”)",,,,,,1,,0,,,,,,,ID6,,18
"<1,0,0,0,0>",ID6,"If you do an edit -> find -> replace there is a bunch of ""foo"" and I don't want them. if there is a variable I want to use the variable every time.
I: So now you are using the textual search and replace but when you invoked it in the refactoring menu how did you expect it to be different from the one you use now?
I remember - I could have done extract constant but there was already a constant there. I'm not sure what would happen. Refactor, extract, constant. So it's now renaming to foo1 because there's already a foo there. Ok. Ctrl+z.","Invocation
Not Predictable (“not sure what would happen”)",,,,,,1,,0,,,,,,,ID6,,19
"<1,0,0,1,0>",ID6,"Then the other one. [37:13]
I: Are you expecting this to help you solve the exercise or to help you think?
To solve the exercise. It is a compiled language so whatever I use to build will show me errors and then I will use these errors as guidelines. I don't know if there is a delete method or something like that. I don't know if there is delete method or something like that. Refactor safe delete .. I don't trust safe delete.
I: How come?
I don't know like .. it's probably something I don't use that often but I prefer to see these things happening step by step because I know what's there, I can double-check any of the files that are to be changed and see if there are any other changes that need to be done in them.","Invocation
Not TrustInvocation
Not Predictable 
 (“prefer to see these things happening step by step”)",,,,,,1,,0,,,,,,,ID6,,20
"<1,0,0,0,0>",ID6,"Not necessarily. That depends on what the tool is doing. I think that .. you are asking if the tools would be able to do the small changes?
I: No. Say if the tool solved your problem say through a refactoring menu but it would take you through the code in the same way. Would you go and read the code in addition in order to be able to do all the readability?
I would do all the readability changes regardless. I would expect the tool to guide me through the code so I can double check the code and see how I can improve it. [1:51:52] If the tool is able to pinpoint me to all the location it is touching so I can backtrack to these places later that's fine. I don't want a button that just says it's done and then I don't know where unless I do a git diff or something like that.","Reflection
Not Predictable (“I don't want a button that just says it's done and then I don't know where”)",,,,,,1,,0,,,,,,,ID6,,21
"<1,0,0,0,0>",ID6,"I would do all the readability changes regardless. I would expect the tool to guide me through the code so I can double check the code and see how I can improve it. [1:51:52] If the tool is able to pinpoint me to all the location it is touching so I can backtrack to these places later that's fine. I don't want a button that just says it's done and then I don't know where unless I do a git diff or something like that.
I: You said that you wanted the tool to be very stepwise what did you mean with that?
When I'm doing a refactoring or let's pick the least complex example and expand from there. Say extract constant I use that refactoring because if I say replace all I see all occurrences and I see all of them flagged in that file. And that is stepwise for me because I see all the places the tool is touching and I can jump there later. But if a tool is like move to caller I want to see what kind of block is going to be moved and who else calls this function or at least see all the places of usages so I can touch these places later. Because otherwise how can I delete this and know where else needs to be checked. All these examples required deleting tests but none required flipping behavior. If a tool do not point me to a place where the flipping needs to happen then I would have the problem of doing a refactoring and not knowing if the behavior of the test should be the same or the behavior of the code.
I: What do you mean with flipping behavior?
Say you have return true and you have a bunch of tests with expect x to be true and because of some feature it should be false. When I run this code all of these tests will be broken. Some of the refactoring tools move the code and when I run the tests later I get an error and I don't know if I have to update the tests or. Ideally I would want to see all the places before doing anything. That's one of the reason I was flipping between. I wanted to only delete the tests when I was sure they were disposable. This should not be deleted this should be expect x to be false. [1:55:23] Right.
So ideally I would first update these guys before doing anything here so when I run them after the refactoring I would still get a green bar. And I expect tools to help me with that. When I say I'm moving these somewhere else I would expect the tool to say these are being used by x y z do you want to take a look at this? Or leave it there and let me navigate through the code. And once I understand that code I realise that what I want to do is fine I can say move forward. That's what I mean by stepwise.","Reflection
Predictable (“I see all of them”)Reflection
Predictable",,,,,,1,,0,,,,,,,ID6,,22
"<1,0,0,0,0>",ID6,"Yes. Extract method extract constant. None of the big ones.
I: What would be a big one?
Moving functionality from a child class to a parent. I wouldn't rely on a refactoring tool for that because of my workflow. I wouldn't know who is using that thing and I want to know because I want to improve my understanding of the code for the future.","Reflection
Not Predictable (""I wouldn’t know who is using that ..”)",,,,,,,,0,,,,,,,,,23
"<1,0,0,0,1>",ID6,"No it was the functionality that was wrong. But if I had done the refactoring before and I wrote the test later I would not have known if it was because of the refactoring or it was a bug there.
I: Can you summarize why you would usually use or not use a refactoring tool in this kind of task?
I use a refactoring when the changes are small enough that I am fully aware of where the code is going to change. Otherwise I prefer to do things manually. I konw it's more labor intensive but that helps me to get more familiar with the code and learn how I can improve the readability of the code. I'm picky with readability.","Reflection
Predictable 
 (""I am fully aware of where the code is going to change”)
 Not Efficient (“I know it’s more labor intensive”)",,,,,,,,0,,,,,,,,,24
"<1,1,0,0,1>",ID7,"The IDE refactoring tools I used a lot in Eclipse were all scoped to the class I was working on. If I created new classes I tended to do it manually.
I: Why?
When I started out, I didn't use any ref tools cause I didn't know they existed. For the tools scoped to a single class, like rearranging method signatures, extracting constants, fields, variables, those kinds of operations, I felt like I got an immediate boost in productivity by using them and they were very predictable. It was obvious just from looking at what it said it was going to do, I click on it and it does it, it did what I would have done manually, and it did it faster. For any refactoring that was more complex than those, maybe I did it once or twice, it didn't do what I envisioned that it would do, so I had a miss of expectations there, and it didn't increase my productivity, it got in my way, by doing something I didn't want.","Reflection
Efficient (“immediate boost in productivity”)
 Predictable (“they were very predictable”)
 Effective (“it did what I would have done manually”)",,,,,,,,0,,,,,,,,,25
"<1,0,0,0,0>",ID7,"I: How would you know if someone else uses it?
In the library I'll get compilation errors.
I didn't want to inline all, because it would've changed these invocations, which I did not want to happen. And now these all have these forceaccees, so I'm going to have to remove them.","Invocation
Predictable (“because it would’ve”)",,,,,,,,0,,,,,,,,,28
"<1,1,0,0,0>",ID7,"Now that I've done this, and I never looking at the tests, I will look at the tests because they're now presumably totally broken.
I: What are you looking for now?
These tests used to invoke the methods that I changed. Because I changed their signatures, and they overlap with other signatures there's no actually breakages, but that probably means I have duplicated tests and broken test cases because there were tests that were passing in true, and now everything behaves as if false were being passed in. So if I just scroll down, I can see that I have a bunch of modifications here. So looking at them..
I: So now you're using the git integration?
Yes. By invoking the refactoring tool it changed code I wan't looking at. So a good way to see those changes is through the git integration. it this wasn't in a git repository. I'd be more screwed than ... I'd be kind of screwed and this saves my bacon.","Invocation
Effective 
 (""I changed their signatures, and they overlap with other signatures there's no actually breakages”)Invocation
Not Predictable (“changed code I wasn’t looking at”)",,,,,1,,,0,,,,,,ID7,,,29
"<1,0,0,1,0>",ID7,"I don't find myself working with that kind of fragile code very much. 99% of the time I don't have to worry about these kind of things and I don't have any side effects or that kind of stuff happening, but then for that 1% I can only really rely on tests and code reviews. I don't really expect the tool to warn me about that of thing.
I: What would you say are dealbreakers for you when using tools?
The main thing is that I understand what the tool is trying to do. Or the tool behaves in a way that I predict. It's that predictability. I generally don't want a tool to do things that I would never want to do. So like, there are like, repeated patterns that as you work as an SE, you find that you're often doing these operations and they are repetitive, and you'd like them for them to be automated in a nice way. These operations are often simple things, because the simple things are what you do most commonly, and so for the more complex things, you see some complex operation and you think that is automatable. But because it is more complex, there is more variance in what outcomes you actaully want, and so I shy away from those kind of things.
It's about trust and predictability.
I: What do you mean by trust?
That I trust it will be realiable. If something has a lot of variability in what it could do, I can't predict or trust that the outcome will be what I want. Then I have to spend a bunch of time verifying that what it did is what I want, and I'd rather just do what I want instead of ask a computer to do something that I might want and then check to see if it's what I want and then correct it to be what I want, that seems like more effort.","Reflection
Predictable (“or the tool behaves in a way that I predict”)Reflection
Trust (“trust it will be reliable”)",,,,,1,1,,1,,,,,,ID7,ID7,,30
"<1,1,0,0,0>",ID8,"I: What do you mean?
With the quick fix I like seeing the error, it is easy to fix it and I know what it's doing.
If I cut and paste this and I get some errors, I know what quick fix it is applying, I know it is grabbing the import or whatever, I mean, sometimes moving or extracting - you can't always see what happens, it's just here and you can't see what changed. I guess I can use git, but sometimes it is better to just plow through and see that this thing is broken. Sometimes - certainly for us, we have a lot of packages, and we use maven, and if you move something from one package to another you have to go change the pom and change the thing, and now there's the wrong junit there, or whatever, so it will break anyway I guess. [20:41]","Reflection
Not Predictable 
 (“sometimes moving or extracting - you can't always see what happens, it's just here and you can't see what changed.”)
 Not Effective 
 (“if you move something from one package to another you have to go change the pom and change the thing, and now there's the wrong junit there, or whatever, so it will break anyway”)",,,,,1,,,0,,,,,,ID8,,,32
"<1,0,0,0,0>",ID8,"I added a file, and then moved some code from two different files into that new file. [34:15]
I: Do you know of any tools that could have automated the changes you did?
I thought there would be some, but they did not do what I expected. [34:31]","Reflection
Not Predictable (“did not do what I expected”)",,,,,,,,0,,,,,,,,,33
"<1,0,0,0,1>",ID8,"Yes
I: Move method?
Not so much. I don't think I move methods that often. And I don't use the other ones that often so I don't know how they work. It can take just as long to figure out what it is going to do or how it does it, and I don't know what it's doing.. Not familiarity. Usually when I am refactoring, it is not easy. It is a complicated thing. It's more like the any-not-any-is-not. Stuff like that, where I have to think it out, and I'm changing something. Usually the refactoring..it is closer to rewriting than to refactoring. You know, it's like, we're not using a list, we need a queue. So now we put a queue in there. So there is more semantic changes, and no tool is going to .. I'll need to look through it. I have to look through it. Unless it showed me exactly what it was doing so I could look through that - that would be ok.","Reflection
Efficient 
 (“It can take just as long to figure out what it is going to do or how it does it”)
 Predictable (“Unless it showed me exactly what it was doing so I could look through that”)",,,,,1,,,0,,,,,,ID8,,,34
"<1,0,1,0,0>",ID8,"If you could preview the change.
I: Here you used the preview.
Probably a more powerful preview. I want to do the change, but I want to know what it changed. It's more like, highlight all the lines that you changed to purple and keep going until I say stop.","Reflection
Not Satisfaction 
 (“a more powerful preview.”)
 Not Predictable (“I want to know what it changed”)",,,,,1,1,,1,,,,,,ID8,ID8,,35
"<1,0,0,1,0>",ID9,"Yes.
I: You mentioned that you trusted the IDE so if it let you do it you wouldn't have checked the body?
Right. I guess there is classes of things I trust it to do well. This is a simple method. There's no name conflicts, there's no multiple scopes interacting I trust that the IDE can do things like that. At least to the same degree that I trust that I can do things like that.
I: We just talked about how the change may change the code would that fall under your sense of trust.
If the IDE moves code and it looks like the code it started from I'm more likely to trust it. Because my mental model of the code hasn't changed it's probably doing the right thing. The more complicated transformations are happening the more manual review is going to need to happen.","Reflection
TrustReflection
Trust
 Predictable",,,,,1,,,0,,,,,,ID9,,,36
"<1,0,1,0,1>",ID9,"Yes because I could see that the method was right here. The two argument version.
I: So the refactoring did break the code but it was what you expected nonetheless.
Yes it was more helpful for the refactoring to result in code that did not compile than to say I can not do that.
I: how come?
It was more in line with the change I would have done manually. I would make the change, see that there was an in-collision and then resolve the collision. Asking me to modify unrelated code in order to delete the unrelated code feels like an extra step.","Reflection
Predictable
 Satisfaction 
 (“it was more helpful for the refactoring to result in code that did not compile than to say I can not do that. “)Reflection
Efficient (“Asking me to modify unrelated code in order to delete the unrelated code feels like an extra step.”)",,,,,,1,,0,,,,,,,ID9,,37
"<1,1,0,1,1>",ID9,"I: You mentioned trust as an aspect of these tools. What are some example of cases in which you don't trust the tools?
In my work I typically work in typescript and I know that the find references tool does not find all references so I know that any automated refactoring will miss some call sites. Sometimes it's still worth it to use the refactoring tool and find the remaining call sites myself but I know that I need to do my own search after to either verify or complete the remained of the transformation.
It is really a tool specific thing that if you know the tool well enough you recognize the bugs and you know you will hit them again. And maybe you stop using the tool. I don't have any big dogmatic that I don't trust the tool to do X it is just that over the years of using refactoring tools I've known there to be buggy tools I've seen them.
I: And you kept using them?
I kept using them. Because they are much faster than doing it by hand.
I: Which refactorings do you usually use them for?
The most common one is adjust method signature. Like reordering method parameters. Like that is trivial. I trust the tool to do it and it is a lot of work to do by hand. Or introduce a new parameter. If I can introduce a default parameter to all callsites. Maybe I have to go through and see what the real value is at each call site but the tool has identified the callsites for me and has injected a marker for you need to do some work here.","Reflection
Predictable (“if you know the tool well enough you recognize the bugs and you know you will hit them again”)Reflection
EfficientReflection
Trust 
 Effective 
 Efficient",,,,,,1,,0,,,,,,,ID9,,38
"<1,0,0,0,0>",ID9,"Yes the inline. Yes sure it doesn't have sufficient code analysis to do the right thing but it said 'no I can't do that' instead of saying I'll try but I'm wrong.
I: It could also have done this more complex change
Yeah I think I'm not worried about lack of correctness as long as that lack of correctness is apparent. If I did a change and it compiled and it was wrong then I'd be worried. But if I do a transformation and there's obvious incomplete stub-bits around then I see that the tool is behaving predictably - I think that is key - and I see where human attention is required. [1:26:53]","Reflection
Predictable",,,,,,1,,0,,,,,,,ID9,,39
"<1,0,0,0,0>",ID10,"Usually yes.
I: I'm curious about how you changed your strategy: you first tried one way, then you decided to change, why was that?
The first strategy, where I tried to move individual methods over, did not work as I was expecting, so I decided to change it.","Reflection
Not Predictable (“did not work as I was expecting”)",,,,,,,,0,,,,,,,,,42
"<1,1,0,0,0>",ID10,"So that's me using the shift shift to find everything, and I'll see if there is a method for testIsAnyNotEmpty. So I can't just inline and remove because my tests won't compile. I don't want to like change my production code and change my test and then run my tests and see if everything is fine.
A lot of my work is in ruby, so I can get away with not having things defined when I make statements like that. And then, so I would do that, I would keep this, then I would remove the body and see that the corresponding tests fail, and then I'd feel comfortable removing - like if only the tests for isAnyNotBlank fail - then I am comfortable removing the whole method definition and the tests themselves.
So Inline Method refactoring is not supported when return statement interrupts the execution flow. So sad. [43:31]
I mean that makes sense to some degree. I know that this refactoring tool, whether it is java or like rubyminds version, gets sad and confused when there's a few different return statemtemt. This itself refers to isNotBlank, which I think is fine, we're not touching isNotBlank. So, how many usages are there of this -
I: By the way, how did you expect the inline tool to actually inline this, or did you expect it to fail like it did now?
[44:30] I hadn't expected it to fail. I had expected it to pop up the dialogue box asking keeping or removing and when it tells me the return statements make the execution flow confusing and I can't do it automatically I go like, yes, that is concern that you have.
I: Right.
Let me split these vertically so I can take a look at - this is anyNotBlank - I want to keep isAllBlank. Nope, not there.
Right. Ok. 'Cause it's going to be tricky to line it potentially, here.
I: Why is that?
[45:43] I can understand why the different return statements and having the returns inside the for loop would make it difficult to have a cute little inline here, that's not really awesome. Uhm. I could be really cheeky and just drop visibility for this.","Invocation
Not Effective (“not supported”)Invocation
Predictable (“that makes sense to some degree.”)Invocation
Predictable (“I can understand why..make it difficult “)",,,,,,,,0,,,,,,,,,43
"<1,0,0,0,0>",ID10,"What am I doing wrong here? Again, this might be .. I don't know if this is java. I would expect for this to save to that local variable and then return that local variable.
I: Yeah, I don't know why that is not working.
That's fine, it just takes a second. Ok, how exciting. This is more what I expect, this inline all, and remove the inline all. Which makes sense. And I preview it, cool to see the implications, one here, one in the test. Which is cool, that makes it easier. Ah, do I really want to do it in the test? Just yet?","Invocation
Predictable (“This is more what I expect”)",,,,,,,,0,,,,,,,,,44
"<1,0,0,0,0>",ID10,"Yeah, sure. I cancelled it because I don't want to inline it into the tests. I want to come back here and think about why my next move was going to be. Understanding that it's still there, I can still choose it at this point, and I don't lose anything there. I could however just hit the delete key at this point and just not do this. I'll do that refactor, and remove my redundant imports. That's fun.
I: What was that?
Ending up with the delightful return not result - which is what I expect considering what the structure of isAllBlank was. So I could at this point put back in the multiple returns, which is probably what I'm going to do, because this is basically the state I want it to be in. I don't have a clever automated way to inline the negation. So I can do it here.. And then I want to - where is this being used - it's being used in this file, in this test file. Great. Awesome. Right there it is. Cool, let's run the tests and see if it works. [56:07]","Invocation
Predictable 
 (“which is what I expect considering what the structure of isAllBlank was”)",,,,,,,,0,,,,,,,,,45
"<1,0,1,0,0>",ID10,"So I inlined the method, and I said don't bother inlining it in these 9 occurrences. And the refactoring tool said fine, I'll leave you with this broken code base.
I: And that's not what you wanted?
That's not what I wanted. What should have done I guess, was to intentionally keep the original, then on the like, second completely different page, where the panel pop up at the bottom with the find results - not the find, whatever it is -
I: Usages?
Yeah, exactly. like then, say like, here are the nine occurrences I don't want you to change. But I had already committed to inline and remove by the time I got to the ones at the bottom, the preview panel at the bottom, and I was surprised by that. I was surprised by this inability to resolve this method. I wouldn't expect my refactoring tool to leave me in a state where my tool does not compile.
[58:00] Right, like the refactoring tool can do safe easy stuff where everything is fine, and being like, I'm not necessarily sure, like, at least the logic is the same, or like maybe the logic is the same but there may be some small semantic differences - and like I've seen ruby mind be like, hey this does have semantic differences. So I am particularly surprised that the refactoring tool leaves me in a state where my codebase does not compile.","Invocation
Not Satisfaction (“That's not what I wanted.”)Invocation
Not Predictable (“I was surprised by this inability to resolve this method.“)Invocation
Not Predictable (“ I am particularly surprised that the refactoring tool leaves me in a state where my codebase does not compile”)",,,,1,,,,0,,,,,ID10,,,,46
"<1,0,0,0,0>",ID10,"I: Leaf nodes of what?
The calling graph.
So let me undo some changes here. So if I find out who is actually calling this with my option F7, I find that it is actually there are two variants on it, versus readField and writeField. So let's take a look at readField. Option F7. So it has it's double version and its test. And writing is going to implicitly need reading. So let's go for the writing version. Ah, so I see the testWriteNameField - so let's go to writeField. How many callers do you have? You're good. Are you? You have a string version? Ok. Fine. In your string version, who is calling the string version? Just the non-forceaccess, and the one test. Great, I'm going to start here. And how many versions of writeFfield do we have? Oh goodie. We have an object string object boolean in the signature here. Yeah, let's go and try to remove - Let me actually think how I would do this. In the end I don't want this method to exist. I want all of it's content, except for - yeah. So rather than breaking all of that necessarily, forceasccess is only used here, inside of this method, so I'll just call this false, at least first. Now it says this is never used, which is fine. That's totally fine. I'm going to move this to the right. Let's go here. All these tests. Sure, some warnings, One test failed - the forceAccess-test failed. I think that's fine, I don't think I need the forceAccesTest. Does the forceAccessTest and the not-forceAccessTest test the same things? Before I remove the forceaccesstest. But like, I'm aware that there's, you know, time. Ok - safe delete forceacess? The following problems were found - it's already defined - delete anyway. Cool. You're going to be sad because you already have another definition of this. That's weird - did that change? Undo safe delete. this version throws illegalAccessException, and this does not","Invocation
Not Predictable (“That's weird - did that change?”)",,,,,1,,,0,,,,,,ID10,,,48
"<1,0,1,0,0>",ID10,"Oh, I don't know. I wouldn't have wanted it to not compile. There was a 'learn more' option that I didn't choose which might have shown me like here are what's calling it with these particular variables. I forget if, in java, if you have a variable that is unused, whether it still actually compiles - I think it does. Compared to other languages.
Now I have lost the actual thing that I was working on. [1:37:01]
WriteField. So in this testWRiteField here forceAccess, this is still what did I end up changing then. Right, there were objects, not just - write, there are different variants of writeField, I had forgotten that. This is why, when there are many things, I like to write down each thing so I know what I am doing. So I have forceAccess here. If forceAccess and field is not accessible then set accessible else setAccessibleWorkaround. So I get to decide at this point, do I want to - I'm treating it as if forceAccess is always false, then this is always false. So false and, which simplifies to false, which lets me remove the if-statement. And then I guess I can safely delete this. Here is the already defined in - quick view usages at this time - but that doesn't tell me anything. [1:39:19]
So, delete anyway. Then it will complain, because I have two writeFields, so I'll delete this one. Great. WriteDeclaredField just has the one caller, which is this - that is false so let's do the same thing, how is this used, getDeclared field, mark that as false, this doesn't care [1:40:20]
keyboard access - delete anyway. Great, that's never used - let's go back to the structure, see what else we have. Reading a declared field, that's before the get, just itself with the false call, perfect, I don't know if in java I can notify my. Yeah, sure. I typed true and I really meant to type false. Sure, rather than needing to visually find it. I already saw that. Delete that anyways. And of course you get weirded out by this. That feels weird, I don't know if I want to do that. I don't think I need to safe delete this, I can just regular delete this.","Invocation
Not Predictable (""that doesn't tell me anything.”)Invocation
Not Satisfaction (“of course you get weirded out by this. That feels weird, I don't know if I want to do that. “)",,,,1,,,,0,,,,,ID10,,,,49
"<1,0,0,1,0>",ID10,"keyboard access - delete anyway. Great, that's never used - let's go back to the structure, see what else we have. Reading a declared field, that's before the get, just itself with the false call, perfect, I don't know if in java I can notify my. Yeah, sure. I typed true and I really meant to type false. Sure, rather than needing to visually find it. I already saw that. Delete that anyways. And of course you get weirded out by this. That feels weird, I don't know if I want to do that. I don't think I need to safe delete this, I can just regular delete this.
I: What would the difference be?
I don't know. My fear is that safe delete would delete anything that calls it. And the - when it says search in comments and strings - when it says search for usages and delete method readDeclaredField. Like - I think it seems ok. But that one trick whenever I do automated code changes - the option there - like I always like to go to the 'show me what you're going to do before you're going to do it. and the 'ok' - like search for usages and delete method? Is that like - ok, what happens if there are usages, you're going to delete the method, but what's going to happen?","Invocation
Not Trust (“My fear is that safe delete would delete anything that calls it.”)
 Not Predictable (“Is that like - ok, what happens if there are usages, you're going to delete the method, but what's going to happen?”)",,,,1,,,,0,,,,,ID10,,,,50
"<1,0,0,0,1>",ID10,"[1:57:30] Yeah. For example IntelliJs git plugin has a phenomenal ability to resolve differences, like better than git. But sometimes it's guessing using heuristics, like complicated machine learning magic I'm sure, and I know that when I turn to that particular tool it is actually a little less certain, only because the other tool git, didn't do it. So like because turning to the more sophisticated, more heuristic based tool, I know that I might not get the change that I want. Like, when these are merged together it might not be done right, whereas git will only do it if it knows it's right.
I: So in which cases do you choose to use refactoring tools and when do you choose not to use them?
[1:59:20] When I know the keyboard shortcuts. Extraction and inlining are awesome because I have easy keyboard shortcuts for extracting a constant versus a field versus a method versus a variable, as far as the IntelliJ’s shortcuts have no mnemonics going for them, these are some of the few where it has so it's easily to reach for them. That aside, the refactoring tool isn't that far off. Some of it is knowing what the refactoring is going to do. Like, when it says push IDT in, I don't what that is. and like, I've spent five years as a consultant teaching people how to program better, so I'm used to knowing this particular tool well, and introducing people to like refactorings and the notion that a refactoring is a small change of layout without a change of behavior and if you say that you're spending three weeks refactoring the codebase you're probably rewriting the codebase, and you're using the word refactoring. So, When would I look at an automated tool versus doing it myself, is familiarity with the tool, I know what it's going to do, I know the situations in which I am going to use it well?","Reflection
Efficient 
 (“Extraction and inlining are awesome because I have easy keyboard shortcuts”)
 Predictable 
 (“knowing what the refactoring is going to do.”)",,,,,,,,0,,,,,,,,,51
"<1,0,1,0,0>",ID10,"[1:59:20] When I know the keyboard shortcuts. Extraction and inlining are awesome because I have easy keyboard shortcuts for extracting a constant versus a field versus a method versus a variable, as far as the IntelliJ’s shortcuts have no mnemonics going for them, these are some of the few where it has so it's easily to reach for them. That aside, the refactoring tool isn't that far off. Some of it is knowing what the refactoring is going to do. Like, when it says push IDT in, I don't what that is. and like, I've spent five years as a consultant teaching people how to program better, so I'm used to knowing this particular tool well, and introducing people to like refactorings and the notion that a refactoring is a small change of layout without a change of behavior and if you say that you're spending three weeks refactoring the codebase you're probably rewriting the codebase, and you're using the word refactoring. So, When would I look at an automated tool versus doing it myself, is familiarity with the tool, I know what it's going to do, I know the situations in which I am going to use it well?
I: Can you say something about the difference for you between trust, correctness and predictability when it comes to using the tool.
Sure. Refactoring tools where I can undo the change is fine. That's very low cost to actually try. Very occasionally I'll do a refactoring that doesn't have an undo option and that is frustrating. I am comfortable using a tool that isn't necessarily 100% correct when it tells me. There are all sorts of nice clever automated code changes that I'll use that aren't safe. In rubymind for example, and in intellij, you can swap arguments. So if you have a method with two arguments, and you have them in the other order, but rubymind doesn't go and change callers when you do that.","Reflection
Not Satisfaction (""I'll do a refactoring that doesn't have an undo option and that is frustrating”)
 Predictable (“I am comfortable using a tool that isn't necessarily 100% correct when it tells me.”)",,,,,,,,0,,,,,,,,,52
"<1,0,1,0,1>",ID11,"It is a process. I understand the code when I am doing this. If I have a tool that just does it for me - do I really know that it found everything? I am not sure. [1:15:44]
I would probably still be checking. Maybe it would be helpful. This took like, what, half an hour, so that could be done instantly maybe. [1:15:57]
But then I just spend the rest of the time verifying. Maybe there are time savings? There probably are time savings. Part of being a developer is figuring out how things work. I actually enjoy this stuff so it would be kind of taking the joy out of my job if I do stuff like that. You will probably get different answers from anyone else I guess.","Reflection
Not Predictable 
 (“But then I just spend the rest of the time verifying. “)
 Efficient 
 (“There probably are time savings”)
 Not Satisfaction
 (“it would be kind of taking the joy out of my job”)",,,,,1,,,0,,,,,,ID11,,,53
"<1,0,0,1,1>",ID12,"There was only one usage of the function. There was not many usages or many different kinds of usages. There was just one place in the same file. There was only one usage each. So it seemed like doing it manually and actually knowing what is going on was better than finding some automated way and not knowing what was going on. [40:39]
I: What do you mean by not knowing what is going on?
It's not that I don't trust the IDE but those refactoring things that are built in they're a bit magical for moving code around so if you haven't used it a lot you don't know where it will move it. It may move it to the wrong place. Again git is a good tool to show you changes so it should be easy to find where it ended up but if it doesn't do exactly what you want you have to try again and you may end up spending more time than just doing it. [41:24]","Reflection
Not Trust 
 Not Predictable (“f you haven't used it a lot you don't know where it will move it.”)
 Not Efficient (“if it doesn't do exactly what you want you have to try again and you may end up spending more time than just doing it.”)",,,,,1,,,0,,,,,,ID12,,,54
"<1,0,0,0,0>",ID13,"I used the search in file to look for forceaccess to get rid of the flag. I just deleted it. It was all deletions. I just searched for forceaccess, deleted the parameter - I realized I was very lucky that it was called by something else that had the flag set to false all the time, so I didn't have to repair all the tests. I was very sad that I'd have to go and repair all the tests. Although it would probably just have been a multi caret over all the false and just delete them. Probably wouldn't have been a big deal, but it was nice that I didn't have to. And then all the ones where it was set to true, that was no longer defined behavior, so I just deleted all those tests because they are no longer necessary. The only hiccup was, I thought - like I did make a mistake about the javadoc, I'm glad I caught that. That is very likely to have slipped past me. [1:09:08]
I: Do you know of any tools that could have automated any of the things you did? [1:09:15]
No. But when we were having this discussion earlier we saw something that said refactor change signature. It has parameters. So .. this leads me to believe that this would serve my purposes. I'm curious as to what it would do different from me just deleting it. [1:09:47] It would probably have some interactive editor, where it's like, you want to delete this parameter but it's being used here, what do you want to do. But to me that's not very different from what I did. I deleted the parameter, things turned red, and it turning red is the same as the editor asking me what do you want to do now that this is broken. [1:10:13]","Reflection
Predictable",,,,,,,,0,,,,,,,,,55
"<1,0,1,0,0>",ID13,"can I delete this?
what.
Show conflicts .. ok so this looks less handy than what I thought it would do. I was hoping it'll give me a little editor where it would show me, like this is where it is being used. But I hate this view. Every time this comes up my eyes glaze over, and I say ok, I'll just do force refactor instead of this safe refacoring. This is unreadable. [1:14:50]
I mean, sure it's neatly organised, but when you have a bunch of different levels.. no.
I: what information were you hoping would be present there?
I'm about to delete a parameter. Where is that parameter being used, and it's just showing me the hierarchy of .. which file, which class, method, you know all the way down to the parameter itself. I don't find that very useful for me. If I delete something I get these red underlines. They show up here in the view I'm used to seeing. They show up along here, on the side, aother view I'm used to seeing. I can preview them easily. That view - no bueno, I'm not a fan. [1:15:46]","Invocation
Not SatisfactionInvocation
Not Predictable 
 (“I’m about to delete a parameter. Where is that parameter being used, and it's just showing me the hierarchy of ..”)",,,,1,,,,0,,,,,ID13,,,,56
"<1,0,1,1,0>",ID13,"I think that would have had the same result. I don't .. I think the context switch just throws me off. When I'm moving from here to here, it's like walking into a new room, and you're like, what I'm I doing here. That happens when I open up a new tab. I like to stay as compartmentalized as possible. [1:25:21]
I: You mentioned that you usually use some refactoring tools, for example rename.
Sometimes, but not always. I found cases, especially with IntelliJ 2018 and forward, it's too aggressive. It renames too much. Let's say I have a method name, the same as some end point name being stored in a string, which is the same as some documentation stored in a comment. When I click refactor, rename, if I'm not cognisent of the end point it is going to rename that. Unless I have a complete model of the entire program, it is very likely that it will rename such strings. Sometimes it comes up with the view we talked about before, saying this is where it's being used, this is where its being used. I don't like that view. [1:26:36]
It would be nicer if it almost brought up like a slideshow showing all the places it's being used, and I could click through them and go like, oh, that's an endpoint, I don't want it there. Although, if the project is sufficiently large, that could become really inconvenient, that could be worse. If I could just get a slideshow like, within this package, that would be nice.
So I do use it, but I wouldn't say I'm 100% confident with it. I don't always trust it. [1:27:12]
I: Why do you mean by that, not trusting it.
I'm afraid it's going to do that thing where it's going to rename something in a string and break my program, or rename something in the documentation in some way that I don't want it to. Luckily with version control I can see these things. But sometimes it's easier to look for the references because it's just where it's being called, and I can just .. like, use that global search. Sounds bad when I say it now, but I'll do something like this.. [1:28:10]
If I do this, I'm more confident because I can see that these are all the method calls, I can go in and just replace one at the time. And this has an equivalent, ctrl shift r. And I can put this in here, and just go through and replace replace replace. [1:28:45]
I: This is a textual replace, right.
Yes. This, to me, in many ways feels safer, because I get a preview of what's happening as I'm doing it. While the global rename happens everywhere and I just have to trust that it did the right thing. I guess this is the exact slideshow I am describing. This is how I want things to be replaced when I'm afraid. [1:29:07]","Reflection
Not Satisfaction (“renames too much”)
Reflection
Predictable (“a slideshow showing all the places it's being used, and I could click through them and go like, oh, that's an endpoint, I don't want it there.”)
Reflection
Trust
Reflection
Predictable (“I'm afraid it's going to do that thing where it's going to rename something in a string and break my program, or rename something in the documentation in some way that I don't want it to.”)
Reflection
Trust",,,,1,,,,0,,,,,ID13,,,,57
"<1,0,0,0,0>",ID14,"No.
I: What happened now?
It didn't like my request to move it. It gave me, I guess an error message, saying it doesn't want to move it unless it is static. So that was unexpected. I am wondering if I can do something else to move it over without fiddling with static and not static.","Invocation
Not Predictable (""So that was unexpected.”)",,,,,,,,0,,,,,,,,,58
"<1,0,0,0,1>",ID14,"I'm thinking through my use of refactoring tools and wondering if there is a different tool I could have used. [53:05]
I: How would that tool be?
It was strange that Inlining didn't work there, that was strange. I guess it was because of the target function, because it was returning a constant. Maybe on a more complex method I could have .. I'm not sure it would have been faster.","Reflection
Not Predictable (""was strange”)
 Not Efficient (“not sure it would have been faster”)",,,,,,,,0,,,,,,,,,60
"<1,0,1,0,1>",ID14,"I definitely would have checked it. First time I would have checked it. But if the change they made is logically, or I go ""oh, well done!"" then I would use it again. I might glance over the second time, but once I get confidence I just hit the hot keys.
I: Is there anything that reduces that condfience rather than increases it?
Error messages. I almost said dialogues or prompts, but it really just slows down using it, which is a barrier to using it. It just takes an extra thought step, looking at a dialogue. If it starts modifying other files that I think should not be .. like if it search some obscure library and I find this other method that has the same name, and I renamed it for you, like noo you did the wrong thing and now I'm a little gun shy.","Reflection
Not Efficient (“it really just slows down using it, which is a barrier to using it.”)
 Not Predictable (“If it starts modifying other files that I think should not be”)
 Not Satisfaction",,,,,1,,,0,,,,,,ID14,,,61
"<1,1,1,0,0>",ID14,"testWriteField, testWriteFieldForceAccess, which I just removed.
If true and ifField is accessible and .. what is this test doing, it's different from the other ones.
Oh, I think it inlined it. Which is kind of what I asked for. [1:22:45]
I: What did you expect it to do here?
I kind of expected it - which now that I think about it was an incorrect expectation - I expected it to put in a ... method that .. err.
That was a learning step.
I was confused, because it's not actually calling writeField. I was looking at the code there and to modifying it a moment ago.
We don't actually need this entire test because we're getting rid of this functionality. I can just destroy this test. That's kind of what I was thinking when I started this. There is the test for writeField and there is the test for writeFieldForceAccess, and if we get rid of the forceAccess method we can get rid of the test. So it kind of did the wrong thing here, but I'm getting rid of the test here so it doesn't matter. [1:24:11]","Invocation
Effective (“kind of what I asked for”)
Invocation
Predictable
Invocation
Not Satisfaction (“kind of did the wrong thing”)
",,,,1,,,,0,,,,,ID14,,,,62
"<1,1,0,0,0>",ID14,"My goal now would be to repeat on what we just did on the other methods. I usually go top down through the file, since it's easier to make sure I don't miss anything.
And I'm looking for the forceaccess versions. Oh wait, I was going to do the bottom ones first. forceAccess... [1:25:29]
Oh yeah.. I feel like this refactoring on the previous method did what I wanted it to do. I'm a bit more confident about it now, and I'm just going to double check the refactored method, if there's anything I need to fix like this. field != null is true, why is it always true, .. because getField guarantees it's not.. How do you know it's always null?","Invocation
Effective (“did what I wanted it to do”)
 Predictable (“just going to double check the refactored method”)
",,,,,,,,0,,,,,,,,,63
"<1,0,0,0,0>",ID14,"[1:34:11] Wow. we use it a lot. That's not what I want.
I: That made you stop?
Yeah. It says in 22 occurrences. That's not what I want.
I: Is there a cutoff number for you?
It should be one. I really just wanted this one call to it to be inline. So I did the wrong thing there. What other thing could I do. [1:35:08]","Invocation 
Predictable",,,,1,,,,0,,,,,ID14,,,,64
"<1,0,0,0,0>",ID14,"if forceaccess and ..
readfield, what is the logic here. [1:50:40]
Ok we can get rid of that. Another one. I'm going to skip the preview button, I can usually undo if it doesn't do the thing I want. I have used preview before but I didn't get value from it, so I stopped using it.","Invocation
Not Predictable (“I have used preview before but I didn't get value from it, so I stopped using it.“)",,,,,,,,0,,,,,,,,,65
"<1,0,0,0,0>",ID16,"We want to remove the functionality that allows us to access fields that are private. this is controlled by a flag that is passed into these methods. So I will remove this flag. [51:09]
Let's start with getDeclaredField. I use change signature. And remove this parameter.
Ok, I'm going to preview this. It's giving me a warning, I'm going to say yes. I always forget, the preview in intelliJ does not actually show you what it is going to do. [52:05]","Invocation
Not Predictable (“does not actually show you what it is going to do”)
",,,,,,,,0,,,,,,,,,66
"<1,1,1,0,0>",ID16,"Rename, inline, extract method a lot. Occasionally push up or push down. There's also - like not really refactoring - but code generation, getters and setters, I use those a lot. Also eclipse has templates that you can use to quick insert code. I use them a lot.
I: For the refactoring tools, do you find that they are overall correct?
Not always. The biggest limitation are cases that don't work that ought to work. Like, it doesn't let you do that.
I: What are examples of that? [1:34:48]
Inline is probably the biggest one, saying that it can't do it when it should be able to. But sometimes there are mistakes too, like you do a refactoring and suddenly there are compilation errors. Occasionally you get just totally garbled code?
I: Do the tool usually warn you in those cases?
No, it just do it and then suddenly everything is messed up.","Reflection
Not Effective(“The biggest limitation are cases that don't work that ought to work”)
Reflection
Not Satisfaction (“Occasionally you get just totally garbled code“)
Reflection
Not Predictable (""it just do it and then suddenly everything is messed up.“)
",,,,1,,,1,1,,,,,ID16,,,ID16,67
"<1,0,0,0,0>",ID16,"I: How come?
It didn't occurr to me. I think at some point for T1 it did occurr to me at the end, but it was too late at that point. But in that case you would instantiate an object to access them from, but you don't want that here. I guess I could have used it and deleted the delegate methods. [1:38:19]
One thing I've learned to benefit from in eclipse, is to apply refactoring tools even when there are compilation errors. for example when there are duplicate local variables, you can rename one of them and it works as you would expect.","Reflection
Predictable (“even when there are compilation errors. for example when there are duplicate local variables, you can rename one of them and it works as you would expect. “)",,,,,,,,0,,,,,,,,,68
"<1,0,0,1,0>",ID18,"I've used rename, extract method and push up members to a superclass, but not too extensively. And I've used - IDK if it is a refactoring tool - but structure view.
I: How come you have used those?
They are relatively simple ones. An I know what the code will look like. A really big part of it, is I can pretty much visualize what the code is going to look like after applying those tools. I know the changes are going to be relatively local, whereas for change signature, I have no idea how the code is going to look, and doing this all in an automated way scares me a little. If I do this, am I easily going to go command z if I make a mistake. I guess in these complex cases I put more trust in myself than in the tool. [1:38:38]
I: Can you summarise what you just said?
For simple refactorings I know exactly what the changed code is going to look like. For complex refactorings that cut across a lot of files it is difficult to predict what the source code looks like after transformation. And that impacts my trust in the tools. [1:39:02]","Reflection
Predictable(“An I know what the code will look like.”)
Not Predictable (“ for change signature, I have no idea how the code is going to look”)
Not Trust (“in these complex cases I put more trust in myself than in the tool”)Reflection
Predictable 
 Trust",,,,1,,,,0,,,,,ID18,,,,69
"<1,0,1,0,0>",ID18,"One thing is how much I have used them in the past, another is if I can predict what the code is going to look like, clearly in my head, then I trust it more. If the tool follows what it is in my mind.
I: Do you have any examples of when that did happen or did not happen? [1:46:37]
Extract method is a good example, since I an just highlight a block of code, give it a name, and it is just going to pop here. But there are other weird ones, like if it has a loop in its body and I try to use extract method on that, and it kind of - either it does not work, or it gives me something, but the loop is not right.","Reflection
Predictable 

 Not Satisfaction",,,,,,,,0,,,,,,,,,70
"<1,1,1,0,0>",ID19,"I: Ok. Are you comfortable trying to finish the task? 
 

 Yeah. I'll just do the craziness.
I: So what happened now? [09:16]
I've no idea what happened now. It didn't do anything. So it seems the first time it just made it accessible as a public, and now it will actually move it. So it's actually a bad workflow that it doesn't go to the next stage.","Invocation
Not Predictable (“no idea what happened now”) 
 Not Effective (“It didn't do anything.“) 
 Not Satisfaction (“it's actually a bad workflow”)",,,,1,,,,0,,,,,ID19,,,,71
"<1,0,1,0,0>",ID19,"[13:14] In the end, for these ones, I would just copy-and paste and put them together just because I don't trust the move in what it actually does, and trying to figure out how it works.
I: so at this point you want to change your approach?
I want to change for this one, knowing what it did there. I will change my approach to better suit my expectations and then found out if there is something happening that I was not understanding properly. But, from history, I used to copy and paste a lot because I would also want to see those kinds of breakages. The refactoring tools may try to show it to you or may not have a great way of showing to you, what it actually is affecting in other classes. So you only end up seeing that as part of committing. Sometimes it's easier to break your code to see how it's coupled together, because it may change your approach.
I: How would you usually approach this?
From the test side it's a little more interesting, but when I used to do it I'd say, I want to move these specific fields and then just copy and paste. Understanding that they should be fully encompassing themselves you can find out what is broken and think about the architecture a little more. The more you use these refactoring tools, the more your architecture can start falling apart, because you start exposing things as static or public that should be isolated a bit more.","Reflection
Not Predictable (“I would also want to see those kinds of breakages. The refactoring tools may try to show it to you or may not have a great way of showing to you, what it actually is affecting in other classes”)
Reflection
Not Satisfaction (""The more you use these refactoring tools, the more your architecture can start falling apart”)",,,,1,,,,0,,,,,ID19,,,,72
"<1,1,1,1,0>",ID19,"Did the tests run before compile? 
 I: Yes.
It says the the variable can not be resolved. did I mess something up? 
 I did - I put the wrong class name which is why doing it manually is bad..
This is one of the benefits, if you have a refactoring tool you trust, is that it can make sure these are correct. But making sure it exposes the changes it is going to make, and why, is a pretty big deal. That's one thing I always have. 
 The idea of visibility and knowing that is going on, is very important for me, rather than seeing it after the fact.
I could always go and use the tool and use git to see what actually changed along the way..
I: Why don't you like that approach?
Sometimes inspecting changes after the fact can be hard. There is going to be code that is unrelated to your refactoring, since normally refactoring tasks is done as part of other tasks. When you're looking at it after the fact you may also not be able to undo it if something doesn't look right, so it's better to have the information up-front. [23:46]
As you see here, because the refactoring tool added static to my method, the first test that I actually moved it won't run.
Where is that one? 
 testIsAllBlank
so, as a part of this, you can see that using the refactoring tool actually does break the code functionally. If it wasn't on a test it could have had a different impact, but because it is a test it is a little different.
I: It prompted you about making it static though.
But when I said no, it didn't allow it. When I said no, it stopped the refactoring, so you either have to say yes, or not use it. If you say no it does not allow the refactoring, so therefore we had to go with it. But that's also why I reverted it, because I didn't like what it was doing.
I: Did you expect it to break the test?
I would not expect a refactoring to break a test especially for a move. That's bad.","Reflection
Trust 
 Predictable (“making sure it exposes the changes it is going to make, and why, is a pretty big deal”)
Reflection
Predictable (“When you're looking at it after the fact you may also not be able to undo it if something doesn't look right, so it's better to have the information up-front.“)
Reflection
Effective (“ If you say no it does not allow the refactoring, so therefore we had to go with it”)
 Not Satisfaction (“I didn’t like what it was doing”)
Reflection
Not Predictable (""I would not expect a refactoring to break a test especially for a move."")
 Not Satisfaction(""That's bad."")",,,,1,1,,,1,,,,,ID19,ID19,,,73
"<1,0,0,0,0>",ID19,"I added a new class, moved the methods across and opened visibility for a single field in stringUtilsTrimEmpty test, so it can be seen across, and updated the appropriate qualifiers. I could have also copied the variable across, but that would have ended up with duplication of data. But if I had been thinking about it on a grander scale I could have seen if the FOO was used anywhere else, and if not, moved it across as well. Depending on how it's used anywhere.
I: Do you know of any tools that could have automated any of the changes you made?
Other tools? Hm. Not that I can think of. I'm sure there are some. I know there are a lot of tools for refactoring, I used a lot more in Eclipse. The Eclipse stuff I've used is more proactive about telling you what it is going to do. But I haven't used IntelliJ enough to know, because there's a lot of people who like their refactoring abilities.","Reflection
Predictable (“more proactive about telling you what it is going to do”)",,,,,,,,0,,,,,,,,,74
"<1,0,0,0,1>",ID19,"But of course it depends again on what I'm trying to do. I've never checked if there is a way to remove arguments. I'll just go ahead with change method signature and see if I can remove.
I'm going to go ahead and preview this time, because there is a preview button and that should tell me exactly what's going on.
There is already another method that way, which means that - it may actually - it will collide - what I'll do in a lot of cases is go back and see what does that one do. It just sets it to false. Something that - I'd take two different approaches is to delete this method right off the bat. Another is kind of similar to what I did in the last one. But in this case I'll go ahead and delete this, and try to use the refactoring tool. I want to see what happens from it. With something like this it can be a lot easier with a refactoring tool to help remove some of that.
I: Why is that?
Kind of back to the same, understanding to happen. When I go ahead and do this, in the preview here I can see some of what's going on, and it's not necessarily just breaking it, it's kind of seeing it in different ways. Like when I break things and go and look at the errors, I should be able to get some of the same context here. Instead of having to manually delete everything by hand. And we'll kind of see what state it gets us into. I'll ignore the error and continue, because I can come back and fix the logic in that. It's more interesting about all the different places that has that changed.","Invocation
Efficient (""it can be a lot easier with a refactoring tool“)
Invocation
Predictable (“in the preview here I can see some of what's going on”)",,,,,,,,0,,,,,,,,,75
"<1,0,0,1,0>",ID19,"Having used it, seeing what happens. The more you use it and seeing success from it, the more you expect that.
I: what is success in this case.
When you don't have to go back and doing a whole bunch of fixes on what it did - like removing static in the first case. Those kinds of things are like, if it starts working and your verification steps are all successful for a while, you just start accepting. I'll never really distrust a rename, I just expect it to work and I've used it so many times. When you get into the different refactorings you may learn that there are certain cases it is good for and certain cases it is not, so you learn what your level of trust is based on experience.
I: Do you have any examples to make that statement more concrete.
Maybe not for refactoring tools, but, I work with customers all day, and there's the saying you trust it as far as you can throw it. In the start you don't know how much you can trust it. The more you can use something and understand what it's doing, the more you gain trust it. You start small, and as you start to trust it you grow it bigger, and I think that's a common pattern with software. It takes time until you know whether something will work better.
I: So for refactoring tools you'd trust the 'smaller' one more?
right of the bat I'd trust the simpler one, like rename - because it is like a find and replace in a way right, just a bit smarter - it's easier to trust those ones, but it's not to say I wouldn't try the other ones and figure out my trust based on their utility. It also depends on how often you do it. If you use something only once or twice it is hard to build an understanding or trust for it, but if it is something you use daily or weekly it's something you can start to get a feeling for and understand your trust level for.","Reflection
TrustReflection
Trust 
 Predictable (“ it is like a find and replace in a way right”)",,,,,,,,0,,,,,,,,,76
"<1,1,0,1,0>",ID19,"right of the bat I'd trust the simpler one, like rename - because it is like a find and replace in a way right, just a bit smarter - it's easier to trust those ones, but it's not to say I wouldn't try the other ones and figure out my trust based on their utility. It also depends on how often you do it. If you use something only once or twice it is hard to build an understanding or trust for it, but if it is something you use daily or weekly it's something you can start to get a feeling for and understand your trust level for.
I: and your point about different cases, something you will have some special cases of where it is good or bad to apply it, do you have any examples of that?
Even the change method signature I did, it is questionable whether it was a good or bad case to use it. You’re trying to remove a parameter, and now you may have had some impact you didn't know about throughout the system. Whereas adding a parameter is an awesome use case because you're adding the parameter, you can default it to something across the calls and there's normally a reason why you add it, is because there are certain call paths you want to change behavior, so it makes it easy to go and find that. There's a difference between adding and removing as well: it changes your belief in the world. When it's removing you had to come back to fix the logic. Adding doesn't break anything until you start using the parameters, or like, using it in your logic. With the removal you have to go do fixes straight away, which is more complex. The trust is impacted by how much work you must invest after the fact. Going back to your question of trusting something that would do the extraction with the negation and it work every time, then that's great, but you need to build up that confidence. If you need to go and change it all the time you would stop using it.","Reflection
Not Predictable (“you may have had some impact you didn't know about throughout the system.”) 
 Trust 
 Effective",,,,1,,,,0,,,,,ID19,,,,77
"<1,0,0,1,0>",ID19,"No - and I think that is a hard thing to describe, because that was success for what I was trying to do.
I: So that did not diminish your trust?
That did not diminish my trust. That actually increases my trust. It didn't try to modify my logic. The body of your method has the logic that matters to the program that is going to run. It didn't try to do something magic that it wouldn't know how to do depending on what that change meant. Removing forceaccess, it could have also gone to the true one. It didn't know what to do, so it could it is better that it didn't do anything. Something that could have been thought about, in terms of diminishing belief in it, is What it did to the rest of the code, because now you don't know which was true or false.","Reflection
Trust 
 Predictable (""It didn't try to do something magic”)
 Not Predictable (“What it did to the rest of the code, because now you don't know which was true or false. “)",,,,,,,,0,,,,,,,,,78
"<1,0,0,1,0>",ID19,"Right. Software is not a simple binary structure. It is a creative piece of work, and creative pieces of work does not have the same definition. So from a language structure, yes, but that doesn't apply a working application.
I: Do you have any other examples from your previous work of things a refactoring tool did that either diminished your trust, or that were in a sense incorrect, but you were still happy about it.
A lot of times when you're doing things like extracting superclasses, it gets interesting. What's good is that when you extract someting higher level, if it needs a variable you can pull it along very easily. So having that up-front information builds my trust in it. I'm seeing that impacts, and either cancelling going back and changing what I'm trying to do or deciding to move forward and go with the changes it actually puts in place.","Reflection
Trust 
 Predictable (“I'm seeing that impacts,”)",,,,,,,,0,,,,,,,,,79
,,,,,,,,,,,,,,,,,,,,80
,,,,,,,,,,,,,,,,,,,,81
,,,,,,,,,,,,,,,,,,,,82
,,,,,,,,,,,,,,,,,,,,83
,,,,,,,,,,,,,,,,,,,,84
,,,,,,,,,,,,,,,,,,,,85
,,,,,,,,,,,,,,,,,,,,86
,,,,,,,,,,,,,,,,,,,,87
,,,,,,,,,,,,,,,,,,,,88
,,,,,,,,,,,,,,,,,,,,89
,,,,,,,,,,,,,,,,,,,,90
,,,,,,,,,,,,,,,,,,,,91
,,,,,,,,,,,,,,,,,,,,92
,,,,,,,,,,,,,,,,,,,,93
,,,,,,,,,,,,,,,,,,,,94
,,,,,,,,,,,,,,,,,,,,95
,,,,,,,,,,,,,,,,,,,,96
,,,,,,,,,,,,,,,,,,,,97
,,,,,,,,,,,,,,,,,,,,98
,,,,,,,,,,,,,,,,,,,,99